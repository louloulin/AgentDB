Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:24:
     pub fn new(config: ClientConfig) -> ClientResult<Self> {
         // Validate configuration
         config.validate().map_err(ClientError::ConfigError)?;
[31m-        
(B[m[32m+
(B[m         // Create HTTP client
         let client = Client::builder()
             .timeout(config.timeout)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:34:
             .pool_idle_timeout(config.pool_idle_timeout)
             .build()
             .map_err(ClientError::HttpError)?;
[31m-        
(B[m[32m+
(B[m         // Create retry policy
         let retry_policy = RetryPolicy::new(config.max_retries)
             .with_base_delay(config.retry_base_delay)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:41:
             .with_max_delay(config.retry_max_delay);
[31m-        
(B[m[32m+
(B[m         let retry_executor = RetryExecutor::new(retry_policy);
[31m-        
(B[m[32m+
(B[m         Ok(Self {
             client,
             config,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:48:
             retry_executor,
         })
     }
[31m-    
(B[m[32m+
(B[m     /// Add a new memory
     pub async fn add_memory(&self, request: AddMemoryRequest) -> ClientResult<MemoryResponse> {
         let url = self.build_url("/api/v1/memories")?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:55:
[31m-        
(B[m[32m+
(B[m         self.retry_executor
             .execute(|| async {
[31m-                let response = self
(B[m[31m-                    .client
(B[m[31m-                    .post(&url)
(B[m[31m-                    .json(&request)
(B[m[31m-                    .send()
(B[m[31m-                    .await?;
(B[m[31m-                
(B[m[32m+                let response = self.client.post(&url).json(&request).send().await?;
(B[m[32m+
(B[m                 self.handle_response(response).await
             })
             .await
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:68:
     }
[31m-    
(B[m[32m+
(B[m     /// Get a memory by ID
     pub async fn get_memory(&self, memory_id: &str) -> ClientResult<Memory> {
         let url = self.build_url(&format!("/api/v1/memories/{}", memory_id))?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:73:
[31m-        
(B[m[32m+
(B[m         self.retry_executor
             .execute(|| async {
                 let response = self.client.get(&url).send().await?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:78:
             })
             .await
     }
[31m-    
(B[m[32m+
(B[m     /// Search memories
     pub async fn search_memories(
         &self,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:85:
         request: SearchMemoriesRequest,
     ) -> ClientResult<SearchMemoriesResponse> {
         let url = self.build_url("/api/v1/memories/search")?;
[31m-        
(B[m[32m+
(B[m         self.retry_executor
             .execute(|| async {
[31m-                let response = self
(B[m[31m-                    .client
(B[m[31m-                    .post(&url)
(B[m[31m-                    .json(&request)
(B[m[31m-                    .send()
(B[m[31m-                    .await?;
(B[m[31m-                
(B[m[32m+                let response = self.client.post(&url).json(&request).send().await?;
(B[m[32m+
(B[m                 self.handle_response(response).await
             })
             .await
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:101:
     }
[31m-    
(B[m[32m+
(B[m     /// Get health status
     pub async fn health_check(&self) -> ClientResult<HealthResponse> {
         let url = self.build_url("/health")?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:106:
[31m-        
(B[m[32m+
(B[m         self.retry_executor
             .execute(|| async {
                 let response = self.client.get(&url).send().await?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:111:
             })
             .await
     }
[31m-    
(B[m[32m+
(B[m     /// Get metrics
     pub async fn get_metrics(&self) -> ClientResult<MetricsResponse> {
         let url = self.build_url("/metrics")?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:118:
[31m-        
(B[m[32m+
(B[m         self.retry_executor
             .execute(|| async {
                 let response = self.client.get(&url).send().await?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:123:
             })
             .await
     }
[31m-    
(B[m[32m+
(B[m     /// Build full URL from path
     fn build_url(&self, path: &str) -> ClientResult<String> {
         let base_url = Url::parse(&self.config.base_url)?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:130:
         let full_url = base_url.join(path)?;
         Ok(full_url.to_string())
     }
[31m-    
(B[m[32m+
(B[m     /// Handle HTTP response and deserialize JSON
     async fn handle_response<T: DeserializeOwned>(&self, response: Response) -> ClientResult<T> {
         let status = response.status();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:137:
[31m-        
(B[m[32m+
(B[m         if self.config.enable_logging {
             debug!("HTTP response: {} {}", status, response.url());
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:141:
[31m-        
(B[m[32m+
(B[m         if status.is_success() {
             let body = response.text().await?;
[31m-            
(B[m[32m+
(B[m             if self.config.enable_logging {
                 debug!("Response body: {}", body);
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:148:
[31m-            
(B[m[32m+
(B[m             serde_json::from_str(&body).map_err(|e| {
                 error!("Failed to deserialize response: {}", e);
                 ClientError::InvalidResponse(format!("JSON deserialization failed: {}", e))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:152:
             })
         } else {
             let body = response.text().await.unwrap_or_default();
[31m-            
(B[m[32m+
(B[m             // Try to parse error response
             if let Ok(error_response) = serde_json::from_str::<ErrorResponse>(&body) {
[31m-                error!("Server error: {} - {}", error_response.code, error_response.message);
(B[m[32m+                error!(
(B[m[32m+                    "Server error: {} - {}",
(B[m[32m+                    error_response.code, error_response.message
(B[m[32m+                );
(B[m                 Err(ClientError::ServerError {
                     status: status.as_u16(),
                     message: error_response.message,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:183:
         let async_client = AsyncAgentMemClient::new(config)?;
         let runtime = tokio::runtime::Runtime::new()
             .map_err(|e| ClientError::InternalError(format!("Failed to create runtime: {}", e)))?;
[31m-        
(B[m[32m+
(B[m         Ok(Self {
             async_client,
             runtime,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:190:
         })
     }
[31m-    
(B[m[32m+
(B[m     /// Add a new memory (sync)
     pub fn add_memory(&self, request: AddMemoryRequest) -> ClientResult<MemoryResponse> {
         self.runtime.block_on(self.async_client.add_memory(request))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:196:
     }
[31m-    
(B[m[32m+
(B[m     /// Get a memory by ID (sync)
     pub fn get_memory(&self, memory_id: &str) -> ClientResult<Memory> {
[31m-        self.runtime.block_on(self.async_client.get_memory(memory_id))
(B[m[32m+        self.runtime
(B[m[32m+            .block_on(self.async_client.get_memory(memory_id))
(B[m     }
[31m-    
(B[m[32m+
(B[m     /// Search memories (sync)
     pub fn search_memories(
         &self,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:206:
         request: SearchMemoriesRequest,
     ) -> ClientResult<SearchMemoriesResponse> {
[31m-        self.runtime.block_on(self.async_client.search_memories(request))
(B[m[32m+        self.runtime
(B[m[32m+            .block_on(self.async_client.search_memories(request))
(B[m     }
[31m-    
(B[m[32m+
(B[m     /// Get health status (sync)
     pub fn health_check(&self) -> ClientResult<HealthResponse> {
         self.runtime.block_on(self.async_client.health_check())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:224:
         let client = AsyncAgentMemClient::new(config);
         assert!(client.is_ok());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_sync_client_creation() {
         let config = ClientConfig::new("http://localhost:8080");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:231:
         let client = AgentMemClient::new(config);
         assert!(client.is_ok());
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_url_building() {
         let config = ClientConfig::new("http://localhost:8080");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/client.rs:238:
         let client = AsyncAgentMemClient::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let url = client.build_url("/api/v1/memories").unwrap();
         assert_eq!(url, "http://localhost:8080/api/v1/memories");
[31m-        
(B[m[32m+
(B[m         let url = client.build_url("/health").unwrap();
         assert_eq!(url, "http://localhost:8080/health");
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:9:
 pub struct ClientConfig {
     /// Base URL of the AgentMem server
     pub base_url: String,
[31m-    
(B[m[32m+
(B[m     /// API key for authentication (optional)
     pub api_key: Option<String>,
[31m-    
(B[m[32m+
(B[m     /// JWT token for authentication (optional)
     pub jwt_token: Option<String>,
[31m-    
(B[m[32m+
(B[m     /// Request timeout
     pub timeout: Duration,
[31m-    
(B[m[32m+
(B[m     /// Connection timeout
     pub connect_timeout: Duration,
[31m-    
(B[m[32m+
(B[m     /// Maximum number of retries
     pub max_retries: u32,
[31m-    
(B[m[32m+
(B[m     /// Retry backoff base delay
     pub retry_base_delay: Duration,
[31m-    
(B[m[32m+
(B[m     /// Maximum retry delay
     pub retry_max_delay: Duration,
[31m-    
(B[m[32m+
(B[m     /// User agent string
     pub user_agent: String,
[31m-    
(B[m[32m+
(B[m     /// Enable request/response logging
     pub enable_logging: bool,
[31m-    
(B[m[32m+
(B[m     /// Connection pool settings
     pub pool_max_idle_per_host: usize,
     pub pool_idle_timeout: Duration,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:60:
             pool_idle_timeout: Duration::from_secs(90),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Set API key for authentication
     pub fn with_api_key(mut self, api_key: impl Into<String>) -> Self {
         self.api_key = Some(api_key.into());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:67:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set JWT token for authentication
     pub fn with_jwt_token(mut self, token: impl Into<String>) -> Self {
         self.jwt_token = Some(token.into());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:73:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set request timeout
     pub fn with_timeout(mut self, timeout: Duration) -> Self {
         self.timeout = timeout;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:79:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set maximum retries
     pub fn with_max_retries(mut self, max_retries: u32) -> Self {
         self.max_retries = max_retries;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:85:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Enable request/response logging
     pub fn with_logging(mut self, enable: bool) -> Self {
         self.enable_logging = enable;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:91:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Validate the configuration
     pub fn validate(&self) -> Result<(), String> {
         // Validate base URL
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:97:
         if let Err(e) = Url::parse(&self.base_url) {
             return Err(format!("Invalid base URL: {}", e));
         }
[31m-        
(B[m[32m+
(B[m         // Validate timeouts
         if self.timeout.is_zero() {
             return Err("Timeout must be greater than zero".to_string());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:104:
         }
[31m-        
(B[m[32m+
(B[m         if self.connect_timeout.is_zero() {
             return Err("Connect timeout must be greater than zero".to_string());
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:109:
[31m-        
(B[m[32m+
(B[m         // Validate retry settings
         if self.retry_base_delay.is_zero() {
             return Err("Retry base delay must be greater than zero".to_string());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:113:
         }
[31m-        
(B[m[32m+
(B[m         if self.retry_max_delay < self.retry_base_delay {
             return Err("Retry max delay must be greater than or equal to base delay".to_string());
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:118:
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:136:
         assert_eq!(config.base_url, "http://localhost:8080");
         assert!(config.validate().is_ok());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_config_with_auth() {
         let config = ClientConfig::new("http://localhost:8080")
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:143:
             .with_api_key("test-key")
             .with_jwt_token("test-token");
[31m-        
(B[m[32m+
(B[m         assert_eq!(config.api_key, Some("test-key".to_string()));
         assert_eq!(config.jwt_token, Some("test-token".to_string()));
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:149:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_config_validation() {
         let mut config = ClientConfig::new("invalid-url");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/config.rs:153:
         assert!(config.validate().is_err());
[31m-        
(B[m[32m+
(B[m         config.base_url = "http://localhost:8080".to_string();
         assert!(config.validate().is_ok());
[31m-        
(B[m[32m+
(B[m         config.timeout = Duration::from_secs(0);
         assert!(config.validate().is_err());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/error.rs:7:
 pub enum ClientError {
     #[error("HTTP request failed: {0}")]
     HttpError(#[from] reqwest::Error),
[31m-    
(B[m[32m+
(B[m     #[error("JSON serialization/deserialization failed: {0}")]
     JsonError(#[from] serde_json::Error),
[31m-    
(B[m[32m+
(B[m     #[error("URL parsing failed: {0}")]
     UrlError(#[from] url::ParseError),
[31m-    
(B[m[32m+
(B[m     #[error("Configuration error: {0}")]
     ConfigError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Authentication failed: {0}")]
     AuthError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Server error (status: {status}): {message}")]
     ServerError { status: u16, message: String },
[31m-    
(B[m[32m+
(B[m     #[error("Timeout error: {0}")]
     TimeoutError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Retry exhausted after {attempts} attempts: {last_error}")]
     RetryExhausted { attempts: u32, last_error: String },
[31m-    
(B[m[32m+
(B[m     #[error("Invalid response format: {0}")]
     InvalidResponse(String),
[31m-    
(B[m[32m+
(B[m     #[error("Network error: {0}")]
     NetworkError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Internal client error: {0}")]
     InternalError(String),
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/error.rs:51:
                 if e.is_timeout() || e.is_connect() || e.is_request() {
                     return true;
                 }
[31m-                
(B[m[32m+
(B[m                 if let Some(status) = e.status() {
                     return status.is_server_error() || status == 429; // Rate limited
                 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/error.rs:58:
[31m-                
(B[m[32m+
(B[m                 false
             }
             ClientError::TimeoutError(_) => true,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/error.rs:66:
             _ => false,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get the HTTP status code if available
     pub fn status_code(&self) -> Option<u16> {
         match self {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/error.rs:91:
     fn test_error_retryable() {
         let timeout_error = ClientError::TimeoutError("Request timeout".to_string());
         assert!(timeout_error.is_retryable());
[31m-        
(B[m[32m+
(B[m         let server_error = ClientError::ServerError {
             status: 500,
             message: "Internal server error".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/error.rs:98:
         };
         assert!(server_error.is_retryable());
[31m-        
(B[m[32m+
(B[m         let client_error = ClientError::ServerError {
             status: 400,
             message: "Bad request".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/error.rs:104:
         };
         assert!(!client_error.is_retryable());
[31m-        
(B[m[32m+
(B[m         let auth_error = ClientError::AuthError("Invalid token".to_string());
         assert!(!auth_error.is_retryable());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/error.rs:110:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_status_code() {
         let server_error = ClientError::ServerError {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/error.rs:115:
             message: "Not found".to_string(),
         };
         assert_eq!(server_error.status_code(), Some(404));
[31m-        
(B[m[32m+
(B[m         let config_error = ClientError::ConfigError("Invalid config".to_string());
         assert_eq!(config_error.status_code(), None);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/lib.rs:1:
 //! AgentMem HTTP Client SDK
[31m-//! 
(B[m[32m+//!
(B[m //! Enterprise-grade HTTP client for AgentMem memory management platform.
 //! Provides both synchronous and asynchronous interfaces with connection pooling,
 //! retry logic, and comprehensive error handling.
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:10:
 pub struct AddMemoryRequest {
     /// Agent ID
     pub agent_id: String,
[31m-    
(B[m[32m+
(B[m     /// User ID (optional)
     pub user_id: Option<String>,
[31m-    
(B[m[32m+
(B[m     /// Memory content
     pub content: String,
[31m-    
(B[m[32m+
(B[m     /// Memory type
     pub memory_type: Option<MemoryType>,
[31m-    
(B[m[32m+
(B[m     /// Importance score (0.0 to 1.0)
     pub importance: Option<f32>,
[31m-    
(B[m[32m+
(B[m     /// Additional metadata
     pub metadata: Option<HashMap<String, String>>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:32:
 pub struct UpdateMemoryRequest {
     /// New content (optional)
     pub content: Option<String>,
[31m-    
(B[m[32m+
(B[m     /// New importance score (optional)
     pub importance: Option<f32>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:42:
 pub struct MemoryResponse {
     /// Memory ID
     pub id: String,
[31m-    
(B[m[32m+
(B[m     /// Response message
     pub message: String,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:52:
 pub struct Memory {
     /// Memory ID
     pub id: String,
[31m-    
(B[m[32m+
(B[m     /// Agent ID
     pub agent_id: String,
[31m-    
(B[m[32m+
(B[m     /// User ID (optional)
     pub user_id: Option<String>,
[31m-    
(B[m[32m+
(B[m     /// Memory content
     pub content: String,
[31m-    
(B[m[32m+
(B[m     /// Memory type
     pub memory_type: Option<MemoryType>,
[31m-    
(B[m[32m+
(B[m     /// Importance score
     pub importance: Option<f32>,
[31m-    
(B[m[32m+
(B[m     /// Creation timestamp
     pub created_at: DateTime<Utc>,
[31m-    
(B[m[32m+
(B[m     /// Additional metadata
     pub metadata: Option<HashMap<String, String>>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:80:
 pub struct SearchMemoriesRequest {
     /// Search query
     pub query: String,
[31m-    
(B[m[32m+
(B[m     /// Agent ID (optional)
     pub agent_id: Option<String>,
[31m-    
(B[m[32m+
(B[m     /// User ID (optional)
     pub user_id: Option<String>,
[31m-    
(B[m[32m+
(B[m     /// Memory type filter (optional)
     pub memory_type: Option<MemoryType>,
[31m-    
(B[m[32m+
(B[m     /// Maximum number of results
     pub limit: Option<usize>,
[31m-    
(B[m[32m+
(B[m     /// Similarity threshold
     pub threshold: Option<f32>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:102:
 pub struct SearchResult {
     /// Memory data
     pub memory: Memory,
[31m-    
(B[m[32m+
(B[m     /// Similarity score
     pub score: f32,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:112:
 pub struct SearchMemoriesResponse {
     /// Search results
     pub results: Vec<SearchResult>,
[31m-    
(B[m[32m+
(B[m     /// Total number of results
     pub total: usize,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:129:
 pub struct BatchResponse {
     /// Number of successful operations
     pub successful: usize,
[31m-    
(B[m[32m+
(B[m     /// Number of failed operations
     pub failed: usize,
[31m-    
(B[m[32m+
(B[m     /// Results from successful operations
     pub results: Vec<String>,
[31m-    
(B[m[32m+
(B[m     /// Error messages from failed operations
     pub errors: Vec<String>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:145:
 pub struct HealthResponse {
     /// Overall health status
     pub status: String,
[31m-    
(B[m[32m+
(B[m     /// Timestamp of the health check
     pub timestamp: DateTime<Utc>,
[31m-    
(B[m[32m+
(B[m     /// Service version
     pub version: String,
[31m-    
(B[m[32m+
(B[m     /// Individual component health checks
     pub checks: HashMap<String, String>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:161:
 pub struct MetricsResponse {
     /// Timestamp of metrics collection
     pub timestamp: DateTime<Utc>,
[31m-    
(B[m[32m+
(B[m     /// Collected metrics
     pub metrics: HashMap<String, f64>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:171:
 pub struct ErrorResponse {
     /// Error code
     pub code: String,
[31m-    
(B[m[32m+
(B[m     /// Error message
     pub message: String,
[31m-    
(B[m[32m+
(B[m     /// Additional error details
     pub details: Option<serde_json::Value>,
[31m-    
(B[m[32m+
(B[m     /// Timestamp of the error
     pub timestamp: DateTime<Utc>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:194:
             metadata: None,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Set user ID
     pub fn with_user_id(mut self, user_id: impl Into<String>) -> Self {
         self.user_id = Some(user_id.into());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:201:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set memory type
     pub fn with_memory_type(mut self, memory_type: MemoryType) -> Self {
         self.memory_type = Some(memory_type);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:207:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set importance score
     pub fn with_importance(mut self, importance: f32) -> Self {
         self.importance = Some(importance);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:213:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set metadata
     pub fn with_metadata(mut self, metadata: HashMap<String, String>) -> Self {
         self.metadata = Some(metadata);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:232:
             threshold: None,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Set agent ID filter
     pub fn with_agent_id(mut self, agent_id: impl Into<String>) -> Self {
         self.agent_id = Some(agent_id.into());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:239:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set user ID filter
     pub fn with_user_id(mut self, user_id: impl Into<String>) -> Self {
         self.user_id = Some(user_id.into());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:245:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set memory type filter
     pub fn with_memory_type(mut self, memory_type: MemoryType) -> Self {
         self.memory_type = Some(memory_type);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:251:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set result limit
     pub fn with_limit(mut self, limit: usize) -> Self {
         self.limit = Some(limit);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:257:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set similarity threshold
     pub fn with_threshold(mut self, threshold: f32) -> Self {
         self.threshold = Some(threshold);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:274:
             .with_user_id("user1")
             .with_memory_type(MemoryType::Episodic)
             .with_importance(0.8);
[31m-        
(B[m[32m+
(B[m         assert_eq!(request.agent_id, "agent1");
         assert_eq!(request.content, "test content");
         assert_eq!(request.user_id, Some("user1".to_string()));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:281:
         assert_eq!(request.memory_type, Some(MemoryType::Episodic));
         assert_eq!(request.importance, Some(0.8));
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_search_request_builder() {
         let request = SearchMemoriesRequest::new("test query")
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/models.rs:288:
             .with_agent_id("agent1")
             .with_limit(10)
             .with_threshold(0.7);
[31m-        
(B[m[32m+
(B[m         assert_eq!(request.query, "test query");
         assert_eq!(request.agent_id, Some("agent1".to_string()));
         assert_eq!(request.limit, Some(10));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:10:
 pub struct RetryPolicy {
     /// Maximum number of retry attempts
     pub max_retries: u32,
[31m-    
(B[m[32m+
(B[m     /// Base delay for exponential backoff
     pub base_delay: Duration,
[31m-    
(B[m[32m+
(B[m     /// Maximum delay between retries
     pub max_delay: Duration,
[31m-    
(B[m[32m+
(B[m     /// Multiplier for exponential backoff
     pub multiplier: f64,
[31m-    
(B[m[32m+
(B[m     /// Jitter to add randomness to delays
     pub jitter: bool,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:44:
             ..Default::default()
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Set base delay
     pub fn with_base_delay(mut self, delay: Duration) -> Self {
         self.base_delay = delay;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:51:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set maximum delay
     pub fn with_max_delay(mut self, delay: Duration) -> Self {
         self.max_delay = delay;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:57:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set multiplier
     pub fn with_multiplier(mut self, multiplier: f64) -> Self {
         self.multiplier = multiplier;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:63:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Enable or disable jitter
     pub fn with_jitter(mut self, jitter: bool) -> Self {
         self.jitter = jitter;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:80:
     pub fn new(policy: RetryPolicy) -> Self {
         Self { policy }
     }
[31m-    
(B[m[32m+
(B[m     /// Execute a function with retry logic
     pub async fn execute<F, Fut, T>(&self, mut operation: F) -> ClientResult<T>
     where
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:94:
             max_elapsed_time: None,
             ..Default::default()
         };
[31m-        
(B[m[32m+
(B[m         let mut attempts = 0;
         let mut last_error = None;
[31m-        
(B[m[32m+
(B[m         loop {
             attempts += 1;
[31m-            
(B[m[32m+
(B[m             match operation().await {
                 Ok(result) => {
                     if attempts > 1 {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:110:
                 }
                 Err(error) => {
                     last_error = Some(error.to_string());
[31m-                    
(B[m[32m+
(B[m                     // Check if we should retry
                     if attempts >= self.policy.max_retries + 1 || !error.is_retryable() {
                         warn!(
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:117:
                             "Operation failed after {} attempts, last error: {}",
                             attempts, error
                         );
[31m-                        
(B[m[32m+
(B[m                         if attempts >= self.policy.max_retries + 1 {
                             return Err(ClientError::RetryExhausted {
                                 attempts,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:127:
                             return Err(error);
                         }
                     }
[31m-                    
(B[m[32m+
(B[m                     // Calculate delay for next attempt
                     if let Some(delay) = backoff.next_backoff() {
                         debug!(
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:134:
                             "Retrying operation (attempt {}/{}) after {:?}, error: {}",
[31m-                            attempts, self.policy.max_retries + 1, delay, error
(B[m[32m+                            attempts,
(B[m[32m+                            self.policy.max_retries + 1,
(B[m[32m+                            delay,
(B[m[32m+                            error
(B[m                         );
[31m-                        
(B[m[32m+
(B[m                         tokio::time::sleep(delay).await;
                     } else {
                         // Backoff exhausted
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:159:
     async fn test_retry_success_on_first_attempt() {
         let policy = RetryPolicy::new(3);
         let executor = RetryExecutor::new(policy);
[31m-        
(B[m[32m+
(B[m         let result = executor
             .execute(|| async { Ok::<i32, ClientError>(42) })
             .await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:166:
[31m-        
(B[m[32m+
(B[m         assert!(result.is_ok());
         assert_eq!(result.unwrap(), 42);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:170:
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_retry_success_after_failures() {
         let policy = RetryPolicy::new(3).with_base_delay(Duration::from_millis(1));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:174:
         let executor = RetryExecutor::new(policy);
[31m-        
(B[m[32m+
(B[m         let counter = Arc::new(AtomicU32::new(0));
         let counter_clone = counter.clone();
[31m-        
(B[m[32m+
(B[m         let result = executor
             .execute(move || {
                 let counter = counter_clone.clone();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:189:
                 }
             })
             .await;
[31m-        
(B[m[32m+
(B[m         assert!(result.is_ok());
         assert_eq!(result.unwrap(), 42);
         assert_eq!(counter.load(Ordering::SeqCst), 3);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:196:
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_retry_exhausted() {
         let policy = RetryPolicy::new(2).with_base_delay(Duration::from_millis(1));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:201:
         let executor = RetryExecutor::new(policy);
[31m-        
(B[m[32m+
(B[m         let result = executor
             .execute(|| async {
                 Err::<i32, ClientError>(ClientError::TimeoutError("Always fails".to_string()))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:206:
             })
             .await;
[31m-        
(B[m[32m+
(B[m         assert!(result.is_err());
         match result.unwrap_err() {
             ClientError::RetryExhausted { attempts, .. } => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:214:
             _ => panic!("Expected RetryExhausted error"),
         }
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_non_retryable_error() {
         let policy = RetryPolicy::new(3);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:221:
         let executor = RetryExecutor::new(policy);
[31m-        
(B[m[32m+
(B[m         let result = executor
             .execute(|| async {
                 Err::<i32, ClientError>(ClientError::AuthError("Invalid token".to_string()))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-client/src/retry.rs:226:
             })
             .await;
[31m-        
(B[m[32m+
(B[m         assert!(result.is_err());
         match result.unwrap_err() {
             ClientError::AuthError(_) => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/factory.rs:1:
 //! Configuration factory
 
 use crate::MemoryConfig;
[31m-use agent_mem_traits::{Result, LLMConfig, VectorStoreConfig};
(B[m[32m+use agent_mem_traits::{LLMConfig, Result, VectorStoreConfig};
(B[m use std::env;
 
 /// Configuration factory for creating configurations
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/factory.rs:12:
     pub fn create_memory_config() -> MemoryConfig {
         MemoryConfig::default()
     }
[31m-    
(B[m[32m+
(B[m     /// Create LLM configuration for a specific provider
     pub fn create_llm_config(provider: &str) -> LLMConfig {
         match provider {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/factory.rs:45:
             _ => LLMConfig::default(),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Create vector store configuration for specific providers
     pub fn create_vector_store_config(provider: &str) -> VectorStoreConfig {
         match provider {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/factory.rs:72:
             _ => VectorStoreConfig::default(),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Create configuration from environment variables
     pub fn from_env() -> Result<MemoryConfig> {
[31m-        let llm_provider = env::var("AGENT_MEM_LLM_PROVIDER").unwrap_or_else(|_| "openai".to_string());
(B[m[31m-        let vector_provider = env::var("AGENT_MEM_VECTOR_PROVIDER").unwrap_or_else(|_| "lancedb".to_string());
(B[m[32m+        let llm_provider =
(B[m[32m+            env::var("AGENT_MEM_LLM_PROVIDER").unwrap_or_else(|_| "openai".to_string());
(B[m[32m+        let vector_provider =
(B[m[32m+            env::var("AGENT_MEM_VECTOR_PROVIDER").unwrap_or_else(|_| "lancedb".to_string());
(B[m         let graph_provider = env::var("AGENT_MEM_GRAPH_PROVIDER").ok();
[31m-        
(B[m[32m+
(B[m         let mut llm_config = Self::create_llm_config(&llm_provider);
         let vector_store_config = Self::create_vector_store_config(&vector_provider);
[31m-        
(B[m[32m+
(B[m         // Set API keys from environment
         if let Ok(api_key) = env::var("OPENAI_API_KEY") {
             llm_config.api_key = Some(api_key);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/factory.rs:94:
         if let Ok(api_key) = env::var("PINECONE_API_KEY") {
             // Set Pinecone API key in storage config if needed
         }
[31m-        
(B[m[32m+
(B[m         let mut embedder_config = crate::memory::EmbedderConfig::default();
         if let Ok(api_key) = env::var("OPENAI_API_KEY") {
             embedder_config.api_key = Some(api_key);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/factory.rs:101:
         }
[31m-        
(B[m[32m+
(B[m         Ok(MemoryConfig {
             llm: llm_config,
             vector_store: vector_store_config,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/factory.rs:108:
             ..Default::default()
         })
     }
[31m-    
(B[m[32m+
(B[m     /// Create configuration from TOML file
     pub fn from_file(path: &str) -> Result<MemoryConfig> {
[31m-        let content = std::fs::read_to_string(path)
(B[m[31m-            .map_err(|e| agent_mem_traits::AgentMemError::config_error(format!("Failed to read config file: {}", e)))?;
(B[m[31m-        
(B[m[31m-        let config: MemoryConfig = toml::from_str(&content)
(B[m[31m-            .map_err(|e| agent_mem_traits::AgentMemError::config_error(format!("Failed to parse config file: {}", e)))?;
(B[m[31m-        
(B[m[32m+        let content = std::fs::read_to_string(path).map_err(|e| {
(B[m[32m+            agent_mem_traits::AgentMemError::config_error(format!(
(B[m[32m+                "Failed to read config file: {}",
(B[m[32m+                e
(B[m[32m+            ))
(B[m[32m+        })?;
(B[m[32m+
(B[m[32m+        let config: MemoryConfig = toml::from_str(&content).map_err(|e| {
(B[m[32m+            agent_mem_traits::AgentMemError::config_error(format!(
(B[m[32m+                "Failed to parse config file: {}",
(B[m[32m+                e
(B[m[32m+            ))
(B[m[32m+        })?;
(B[m[32m+
(B[m         crate::validation::validate_memory_config(&config)?;
[31m-        
(B[m[32m+
(B[m         Ok(config)
     }
[31m-    
(B[m[32m+
(B[m     /// Create configuration using the config crate (supports multiple formats)
     pub fn from_config_sources() -> Result<MemoryConfig> {
         let settings = config::Config::builder()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/factory.rs:128:
             // Start with default values
             .add_source(config::File::with_name("config/default").required(false))
             // Add environment-specific config
[31m-            .add_source(config::File::with_name(&format!("config/{}", 
(B[m[31m-                env::var("AGENT_MEM_ENV").unwrap_or_else(|_| "development".to_string())
(B[m[31m-            )).required(false))
(B[m[32m+            .add_source(
(B[m[32m+                config::File::with_name(&format!(
(B[m[32m+                    "config/{}",
(B[m[32m+                    env::var("AGENT_MEM_ENV").unwrap_or_else(|_| "development".to_string())
(B[m[32m+                ))
(B[m[32m+                .required(false),
(B[m[32m+            )
(B[m             // Add local config (gitignored)
             .add_source(config::File::with_name("config/local").required(false))
             // Add environment variables with prefix
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/factory.rs:137:
             .add_source(config::Environment::with_prefix("AGENT_MEM"))
             .build()
[31m-            .map_err(|e| agent_mem_traits::AgentMemError::config_error(format!("Failed to build config: {}", e)))?;
(B[m[31m-        
(B[m[31m-        let config: MemoryConfig = settings.try_deserialize()
(B[m[31m-            .map_err(|e| agent_mem_traits::AgentMemError::config_error(format!("Failed to deserialize config: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                agent_mem_traits::AgentMemError::config_error(format!(
(B[m[32m+                    "Failed to build config: {}",
(B[m[32m+                    e
(B[m[32m+                ))
(B[m[32m+            })?;
(B[m[32m+
(B[m[32m+        let config: MemoryConfig = settings.try_deserialize().map_err(|e| {
(B[m[32m+            agent_mem_traits::AgentMemError::config_error(format!(
(B[m[32m+                "Failed to deserialize config: {}",
(B[m[32m+                e
(B[m[32m+            ))
(B[m[32m+        })?;
(B[m[32m+
(B[m         crate::validation::validate_memory_config(&config)?;
[31m-        
(B[m[32m+
(B[m         Ok(config)
     }
[31m-    
(B[m[32m+
(B[m     /// Save configuration to TOML file
     pub fn save_to_file(config: &MemoryConfig, path: &str) -> Result<()> {
[31m-        let content = toml::to_string_pretty(config)
(B[m[31m-            .map_err(|e| agent_mem_traits::AgentMemError::config_error(format!("Failed to serialize config: {}", e)))?;
(B[m[31m-        
(B[m[31m-        std::fs::write(path, content)
(B[m[31m-            .map_err(|e| agent_mem_traits::AgentMemError::config_error(format!("Failed to write config file: {}", e)))?;
(B[m[31m-        
(B[m[32m+        let content = toml::to_string_pretty(config).map_err(|e| {
(B[m[32m+            agent_mem_traits::AgentMemError::config_error(format!(
(B[m[32m+                "Failed to serialize config: {}",
(B[m[32m+                e
(B[m[32m+            ))
(B[m[32m+        })?;
(B[m[32m+
(B[m[32m+        std::fs::write(path, content).map_err(|e| {
(B[m[32m+            agent_mem_traits::AgentMemError::config_error(format!(
(B[m[32m+                "Failed to write config file: {}",
(B[m[32m+                e
(B[m[32m+            ))
(B[m[32m+        })?;
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/factory.rs:161:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    use tempfile::NamedTempFile;
(B[m     use std::io::Write;
[32m+    use tempfile::NamedTempFile;
(B[m 
     #[test]
     fn test_create_memory_config() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/factory.rs:220:
 enable_memory_summarization = true
 importance_scoring = true
 "#;
[31m-        
(B[m[32m+
(B[m         let mut temp_file = NamedTempFile::new().unwrap();
         temp_file.write_all(config_content.as_bytes()).unwrap();
[31m-        
(B[m[32m+
(B[m         let config = ConfigFactory::from_file(temp_file.path().to_str().unwrap()).unwrap();
         assert_eq!(config.llm.provider, "openai");
         assert_eq!(config.llm.model, "gpt-4");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/lib.rs:1:
 //! # Agent Memory Configuration
[31m-//! 
(B[m[32m+//!
(B[m //! Configuration management for the AgentMem memory platform.
 
 pub mod factory;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/memory.rs:1:
 //! Memory configuration
 
[31m-use serde::{Deserialize, Serialize};
(B[m use agent_mem_traits::{LLMConfig, VectorStoreConfig};
[32m+use serde::{Deserialize, Serialize};
(B[m 
 /// Main configuration for memory management
 #[derive(Debug, Clone, Serialize, Deserialize)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/memory.rs:8:
 pub struct MemoryConfig {
     /// LLM provider configuration
     pub llm: LLMConfig,
[31m-    
(B[m[32m+
(B[m     /// Vector store configuration
     pub vector_store: VectorStoreConfig,
[31m-    
(B[m[32m+
(B[m     /// Graph store configuration (optional)
     pub graph_store: Option<GraphStoreConfig>,
[31m-    
(B[m[32m+
(B[m     /// Embedder configuration
     pub embedder: EmbedderConfig,
[31m-    
(B[m[32m+
(B[m     /// Session configuration
     pub session: SessionConfig,
[31m-    
(B[m[32m+
(B[m     /// Intelligence configuration
     pub intelligence: IntelligenceConfig,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:1:
 //! Configuration validation
 
[31m-use agent_mem_traits::{Result, AgentMemError, LLMConfig, VectorStoreConfig};
(B[m use crate::MemoryConfig;
[32m+use agent_mem_traits::{AgentMemError, LLMConfig, Result, VectorStoreConfig};
(B[m 
 /// Validate memory configuration
 pub fn validate_memory_config(config: &MemoryConfig) -> Result<()> {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:8:
     validate_llm_config(&config.llm)?;
     validate_storage_config(&config.vector_store)?;
[31m-    
(B[m[32m+
(B[m     if let Some(graph_config) = &config.graph_store {
         validate_graph_config(graph_config)?;
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:14:
[31m-    
(B[m[32m+
(B[m     validate_embedder_config(&config.embedder)?;
     validate_session_config(&config.session)?;
     validate_intelligence_config(&config.intelligence)?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:18:
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:22:
 /// Validate LLM configuration
 pub fn validate_llm_config(config: &LLMConfig) -> Result<()> {
     if config.provider.is_empty() {
[31m-        return Err(AgentMemError::invalid_config("LLM provider cannot be empty"));
(B[m[32m+        return Err(AgentMemError::invalid_config(
(B[m[32m+            "LLM provider cannot be empty",
(B[m[32m+        ));
(B[m     }
 
     if config.model.is_empty() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:29:
         return Err(AgentMemError::invalid_config("LLM model cannot be empty"));
     }
[31m-    
(B[m[32m+
(B[m     // Check provider-specific requirements
     match config.provider.as_str() {
         "openai" | "anthropic" | "azure" | "gemini" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:35:
             if config.api_key.is_none() {
[31m-                return Err(AgentMemError::invalid_config(
(B[m[31m-                    format!("{} provider requires an API key", config.provider)
(B[m[31m-                ));
(B[m[32m+                return Err(AgentMemError::invalid_config(format!(
(B[m[32m+                    "{} provider requires an API key",
(B[m[32m+                    config.provider
(B[m[32m+                )));
(B[m             }
         }
         "ollama" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:42:
             if config.base_url.is_none() {
                 return Err(AgentMemError::invalid_config(
[31m-                    "Ollama provider requires a base URL"
(B[m[32m+                    "Ollama provider requires a base URL",
(B[m                 ));
             }
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:54:
     if let Some(temp) = config.temperature {
         if temp < 0.0 || temp > 2.0 {
             return Err(AgentMemError::invalid_config(
[31m-                "Temperature must be between 0.0 and 2.0"
(B[m[32m+                "Temperature must be between 0.0 and 2.0",
(B[m             ));
         }
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:63:
     if let Some(max_tokens) = config.max_tokens {
         if max_tokens == 0 {
             return Err(AgentMemError::invalid_config(
[31m-                "max_tokens must be greater than 0"
(B[m[32m+                "max_tokens must be greater than 0",
(B[m             ));
         }
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:70:
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:74:
 /// Validate storage configuration
 pub fn validate_storage_config(config: &VectorStoreConfig) -> Result<()> {
     if config.provider.is_empty() {
[31m-        return Err(AgentMemError::invalid_config("Vector store provider cannot be empty"));
(B[m[32m+        return Err(AgentMemError::invalid_config(
(B[m[32m+            "Vector store provider cannot be empty",
(B[m[32m+        ));
(B[m     }
 
     if config.dimension == Some(0) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:81:
[31m-        return Err(AgentMemError::invalid_config("Vector dimension must be greater than 0"));
(B[m[32m+        return Err(AgentMemError::invalid_config(
(B[m[32m+            "Vector dimension must be greater than 0",
(B[m[32m+        ));
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Check provider-specific requirements
     match config.provider.as_str() {
         "lancedb" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:90:
         }
         "pinecone" => {
             if config.api_key.is_none() {
[31m-                return Err(AgentMemError::invalid_config("Pinecone requires an API key"));
(B[m[32m+                return Err(AgentMemError::invalid_config(
(B[m[32m+                    "Pinecone requires an API key",
(B[m[32m+                ));
(B[m             }
             if config.index_name.is_none() {
[31m-                return Err(AgentMemError::invalid_config("Pinecone requires an index name"));
(B[m[32m+                return Err(AgentMemError::invalid_config(
(B[m[32m+                    "Pinecone requires an index name",
(B[m[32m+                ));
(B[m             }
         }
         "qdrant" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:105:
             return Err(AgentMemError::unsupported_provider(&config.provider));
         }
     }
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:112:
 /// Validate graph configuration
 pub fn validate_graph_config(config: &crate::memory::GraphStoreConfig) -> Result<()> {
     if config.provider.is_empty() {
[31m-        return Err(AgentMemError::invalid_config("Graph store provider cannot be empty"));
(B[m[32m+        return Err(AgentMemError::invalid_config(
(B[m[32m+            "Graph store provider cannot be empty",
(B[m[32m+        ));
(B[m     }
[31m-    
(B[m[32m+
(B[m     if config.uri.is_empty() {
[31m-        return Err(AgentMemError::invalid_config("Graph store URI cannot be empty"));
(B[m[32m+        return Err(AgentMemError::invalid_config(
(B[m[32m+            "Graph store URI cannot be empty",
(B[m[32m+        ));
(B[m     }
[31m-    
(B[m[32m+
(B[m     match config.provider.as_str() {
         "neo4j" | "memgraph" => {
             // Valid providers
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:127:
             return Err(AgentMemError::unsupported_provider(&config.provider));
         }
     }
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:134:
 /// Validate embedder configuration
 pub fn validate_embedder_config(config: &crate::memory::EmbedderConfig) -> Result<()> {
     if config.provider.is_empty() {
[31m-        return Err(AgentMemError::invalid_config("Embedder provider cannot be empty"));
(B[m[32m+        return Err(AgentMemError::invalid_config(
(B[m[32m+            "Embedder provider cannot be empty",
(B[m[32m+        ));
(B[m     }
[31m-    
(B[m[32m+
(B[m     if config.model.is_empty() {
[31m-        return Err(AgentMemError::invalid_config("Embedder model cannot be empty"));
(B[m[32m+        return Err(AgentMemError::invalid_config(
(B[m[32m+            "Embedder model cannot be empty",
(B[m[32m+        ));
(B[m     }
[31m-    
(B[m[32m+
(B[m     if config.dimension == 0 {
[31m-        return Err(AgentMemError::invalid_config("Embedding dimension must be greater than 0"));
(B[m[32m+        return Err(AgentMemError::invalid_config(
(B[m[32m+            "Embedding dimension must be greater than 0",
(B[m[32m+        ));
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Check provider-specific requirements
     match config.provider.as_str() {
         "openai" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:151:
             if config.api_key.is_none() {
[31m-                return Err(AgentMemError::invalid_config("OpenAI embedder requires an API key"));
(B[m[32m+                return Err(AgentMemError::invalid_config(
(B[m[32m+                    "OpenAI embedder requires an API key",
(B[m[32m+                ));
(B[m             }
         }
         "huggingface" | "local" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:159:
             return Err(AgentMemError::unsupported_provider(&config.provider));
         }
     }
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:167:
 pub fn validate_session_config(config: &crate::memory::SessionConfig) -> Result<()> {
     if config.session_timeout_seconds == 0 {
         return Err(AgentMemError::invalid_config(
[31m-            "session_timeout_seconds must be greater than 0"
(B[m[32m+            "session_timeout_seconds must be greater than 0",
(B[m         ));
     }
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:178:
 pub fn validate_intelligence_config(config: &crate::memory::IntelligenceConfig) -> Result<()> {
     if config.similarity_threshold < 0.0 || config.similarity_threshold > 1.0 {
         return Err(AgentMemError::invalid_config(
[31m-            "similarity_threshold must be between 0.0 and 1.0"
(B[m[32m+            "similarity_threshold must be between 0.0 and 1.0",
(B[m         ));
     }
[31m-    
(B[m[32m+
(B[m     if config.clustering_threshold < 0.0 || config.clustering_threshold > 1.0 {
         return Err(AgentMemError::invalid_config(
[31m-            "clustering_threshold must be between 0.0 and 1.0"
(B[m[32m+            "clustering_threshold must be between 0.0 and 1.0",
(B[m         ));
     }
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-config/src/validation.rs:233:
     fn test_validate_embedder_config() {
         let mut config = EmbedderConfig::default();
         config.api_key = Some("test-key".to_string());
[31m-        
(B[m[32m+
(B[m         assert!(validate_embedder_config(&config).is_ok());
[31m-        
(B[m[32m+
(B[m         // Test invalid dimension
         config.dimension = 0;
         assert!(validate_embedder_config(&config).is_err());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:1:
 //! Adaptive Memory Strategy System
[31m-//! 
(B[m[32m+//!
(B[m //! Automatically adjusts memory management strategies based on usage patterns,
 //! context, and performance metrics for optimal memory system behavior.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:6:
[31m-use crate::hierarchical_service::{HierarchicalMemoryRecord, ConflictResolutionStrategy};
(B[m[32m+use crate::hierarchical_service::{ConflictResolutionStrategy, HierarchicalMemoryRecord};
(B[m use crate::importance_scorer::{ImportanceFactors, ScoringContext};
 use crate::types::{ImportanceLevel, MemoryType};
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m[32m+use chrono::{DateTime, Duration, Timelike, Utc};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::{HashMap, VecDeque};
[31m-use chrono::{DateTime, Utc, Duration, Timelike};
(B[m use uuid::Uuid;
 
 /// Configuration for adaptive strategy system
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:130:
     ) -> Result<StrategyRecommendation> {
         // Update performance if provided
         if let Some(performance) = recent_performance {
[31m-            self.record_performance(self.current_strategy.clone(), performance).await?;
(B[m[32m+            self.record_performance(self.current_strategy.clone(), performance)
(B[m[32m+                .await?;
(B[m         }
 
         // Extract context pattern
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:167:
 
         // Log the strategy change
         let reason = format!("Strategy adapted from {:?} to {:?}", old_strategy, strategy);
[31m-        self.adaptation_log.push_back((
(B[m[31m-            Utc::now(),
(B[m[31m-            old_strategy,
(B[m[31m-            strategy.clone(),
(B[m[31m-            reason,
(B[m[31m-        ));
(B[m[32m+        self.adaptation_log
(B[m[32m+            .push_back((Utc::now(), old_strategy, strategy.clone(), reason));
(B[m 
         // Limit adaptation log size
         if self.adaptation_log.len() > self.config.max_strategy_history {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:247:
         performance: f64,
     ) -> Result<()> {
         // Update strategy performance metrics
[31m-        let perf = self.strategy_performance.entry(strategy.clone()).or_insert_with(|| {
(B[m[31m-            StrategyPerformance {
(B[m[32m+        let perf = self
(B[m[32m+            .strategy_performance
(B[m[32m+            .entry(strategy.clone())
(B[m[32m+            .or_insert_with(|| StrategyPerformance {
(B[m                 strategy: strategy.clone(),
                 success_rate: 0.0,
                 average_response_time: Duration::milliseconds(0),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:257:
                 conflict_resolution_rate: 0.0,
                 sample_count: 0,
                 last_updated: Utc::now(),
[31m-            }
(B[m[31m-        });
(B[m[32m+            });
(B[m 
         // Update running averages
         let old_count = perf.sample_count as f64;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:265:
         let new_count = old_count + 1.0;
[31m-        
(B[m[32m+
(B[m         perf.success_rate = (perf.success_rate * old_count + performance) / new_count;
         perf.sample_count += 1;
         perf.last_updated = Utc::now();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:270:
 
         // Add to performance history
[31m-        self.performance_history.push_back((Utc::now(), strategy, performance));
(B[m[32m+        self.performance_history
(B[m[32m+            .push_back((Utc::now(), strategy, performance));
(B[m 
         // Limit history size
         if self.performance_history.len() > self.config.max_strategy_history {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:277:
         }
 
         // Check if adaptation is needed
[31m-        if self.config.enable_adaptation && 
(B[m[31m-           perf.sample_count >= self.config.min_samples_for_adaptation {
(B[m[32m+        if self.config.enable_adaptation
(B[m[32m+            && perf.sample_count >= self.config.min_samples_for_adaptation
(B[m[32m+        {
(B[m             self.evaluate_adaptation_need().await?;
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:328:
             .into_iter()
             .filter(|(s, _)| s != &best_strategy.0)
             .collect();
[31m-        alternatives.sort_by(|(_, a), (_, b)| b.partial_cmp(a).unwrap_or(std::cmp::Ordering::Equal));
(B[m[32m+        alternatives
(B[m[32m+            .sort_by(|(_, a), (_, b)| b.partial_cmp(a).unwrap_or(std::cmp::Ordering::Equal));
(B[m         alternatives.truncate(3);
 
         Ok(StrategyRecommendation {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:342:
 
     /// Select best performing strategy
     async fn select_best_performing_strategy(&self) -> Result<StrategyRecommendation> {
[31m-        let best_strategy = self.strategy_performance
(B[m[32m+        let best_strategy = self
(B[m[32m+            .strategy_performance
(B[m             .iter()
             .max_by(|(_, a), (_, b)| {
[31m-                a.success_rate.partial_cmp(&b.success_rate).unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+                a.success_rate
(B[m[32m+                    .partial_cmp(&b.success_rate)
(B[m[32m+                    .unwrap_or(std::cmp::Ordering::Equal)
(B[m             })
             .map(|(strategy, performance)| (strategy.clone(), performance.success_rate))
             .unwrap_or((MemoryStrategy::Balanced, 0.5));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:360:
     }
 
     /// Calculate context similarity for strategy scoring
[31m-    fn calculate_context_similarity(&self, _context: &ScoringContext, _strategy: &MemoryStrategy) -> f64 {
(B[m[32m+    fn calculate_context_similarity(
(B[m[32m+        &self,
(B[m[32m+        _context: &ScoringContext,
(B[m[32m+        _strategy: &MemoryStrategy,
(B[m[32m+    ) -> f64 {
(B[m         // Simplified implementation
         // In a full implementation, this would analyze context patterns
         1.0
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:372:
             let hours_since_update = Utc::now()
                 .signed_duration_since(performance.last_updated)
                 .num_hours() as f64;
[31m-            
(B[m[32m+
(B[m             // Exponential decay with 24-hour half-life
             0.5_f64.powf(hours_since_update / 24.0)
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:400:
     /// Evaluate if adaptation is needed
     async fn evaluate_adaptation_need(&mut self) -> Result<()> {
         let current_performance = self.get_expected_performance(&self.current_strategy);
[31m-        
(B[m[32m+
(B[m         if current_performance < self.config.performance_threshold {
             // Find better strategy
[31m-            if let Some((better_strategy, better_performance)) = self.strategy_performance
(B[m[32m+            if let Some((better_strategy, better_performance)) = self
(B[m[32m+                .strategy_performance
(B[m                 .iter()
                 .filter(|(s, _)| *s != &self.current_strategy)
                 .max_by(|(_, a), (_, b)| {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:410:
[31m-                    a.success_rate.partial_cmp(&b.success_rate).unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+                    a.success_rate
(B[m[32m+                        .partial_cmp(&b.success_rate)
(B[m[32m+                        .unwrap_or(std::cmp::Ordering::Equal)
(B[m                 })
                 .map(|(s, p)| (s.clone(), p.success_rate))
             {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:417:
                         "Performance below threshold ({:.2} < {:.2}), switching to better strategy",
                         current_performance, self.config.performance_threshold
                     );
[31m-                    
(B[m[32m+
(B[m                     self.adaptation_log.push_back((
                         Utc::now(),
                         self.current_strategy.clone(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:424:
                         better_strategy.clone(),
                         reason,
                     ));
[31m-                    
(B[m[32m+
(B[m                     self.current_strategy = better_strategy;
                 }
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:445:
         ];
 
         for strategy in strategies {
[31m-            self.strategy_performance.insert(strategy.clone(), StrategyPerformance {
(B[m[31m-                strategy: strategy.clone(),
(B[m[31m-                success_rate: 0.5, // Default neutral performance
(B[m[31m-                average_response_time: Duration::milliseconds(100),
(B[m[31m-                memory_efficiency: 0.5,
(B[m[31m-                user_satisfaction: 0.5,
(B[m[31m-                conflict_resolution_rate: 0.5,
(B[m[31m-                sample_count: 0,
(B[m[31m-                last_updated: Utc::now(),
(B[m[31m-            });
(B[m[32m+            self.strategy_performance.insert(
(B[m[32m+                strategy.clone(),
(B[m[32m+                StrategyPerformance {
(B[m[32m+                    strategy: strategy.clone(),
(B[m[32m+                    success_rate: 0.5, // Default neutral performance
(B[m[32m+                    average_response_time: Duration::milliseconds(100),
(B[m[32m+                    memory_efficiency: 0.5,
(B[m[32m+                    user_satisfaction: 0.5,
(B[m[32m+                    conflict_resolution_rate: 0.5,
(B[m[32m+                    sample_count: 0,
(B[m[32m+                    last_updated: Utc::now(),
(B[m[32m+                },
(B[m[32m+            );
(B[m         }
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:469:
     }
 
     /// Get adaptation history
[31m-    pub fn get_adaptation_log(&self) -> &VecDeque<(DateTime<Utc>, MemoryStrategy, MemoryStrategy, String)> {
(B[m[32m+    pub fn get_adaptation_log(
(B[m[32m+        &self,
(B[m[32m+    ) -> &VecDeque<(DateTime<Utc>, MemoryStrategy, MemoryStrategy, String)> {
(B[m         &self.adaptation_log
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:493:
     async fn test_adaptive_strategy_manager_creation() {
         let config = AdaptiveStrategyConfig::default();
         let manager = AdaptiveStrategyManager::new(config);
[31m-        
(B[m[32m+
(B[m         assert_eq!(manager.current_strategy, MemoryStrategy::Balanced);
         assert_eq!(manager.strategy_performance.len(), 6); // All default strategies
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:505:
         let context = ScoringContext::default();
 
         let recommendation = manager.recommend_strategy(&context, None).await.unwrap();
[31m-        
(B[m[32m+
(B[m         // Check that we got a valid strategy
         match recommendation.recommended_strategy {
[31m-            MemoryStrategy::Conservative | MemoryStrategy::Aggressive |
(B[m[31m-            MemoryStrategy::Balanced | MemoryStrategy::ContextAware |
(B[m[31m-            MemoryStrategy::UserCentric | MemoryStrategy::TaskOriented => {
(B[m[32m+            MemoryStrategy::Conservative
(B[m[32m+            | MemoryStrategy::Aggressive
(B[m[32m+            | MemoryStrategy::Balanced
(B[m[32m+            | MemoryStrategy::ContextAware
(B[m[32m+            | MemoryStrategy::UserCentric
(B[m[32m+            | MemoryStrategy::TaskOriented => {
(B[m                 // Valid strategy
             }
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:522:
         let config = AdaptiveStrategyConfig::default();
         let mut manager = AdaptiveStrategyManager::new(config);
 
[31m-        manager.record_performance(MemoryStrategy::Balanced, 0.8).await.unwrap();
(B[m[31m-        
(B[m[31m-        let performance = manager.strategy_performance.get(&MemoryStrategy::Balanced).unwrap();
(B[m[32m+        manager
(B[m[32m+            .record_performance(MemoryStrategy::Balanced, 0.8)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m[32m+        let performance = manager
(B[m[32m+            .strategy_performance
(B[m[32m+            .get(&MemoryStrategy::Balanced)
(B[m[32m+            .unwrap();
(B[m         assert_eq!(performance.sample_count, 1);
         assert_eq!(performance.success_rate, 0.8);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:535:
         let manager = AdaptiveStrategyManager::new(config);
 
         let params = manager.get_strategy_parameters(&MemoryStrategy::Conservative);
[31m-        assert_eq!(params.conflict_resolution, ConflictResolutionStrategy::KeepBoth);
(B[m[32m+        assert_eq!(
(B[m[32m+            params.conflict_resolution,
(B[m[32m+            ConflictResolutionStrategy::KeepBoth
(B[m[32m+        );
(B[m         assert_eq!(params.importance_threshold, 0.3);
 
         let params = manager.get_strategy_parameters(&MemoryStrategy::Aggressive);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/adaptive_strategy.rs:542:
[31m-        assert_eq!(params.conflict_resolution, ConflictResolutionStrategy::ImportanceBased);
(B[m[32m+        assert_eq!(
(B[m[32m+            params.conflict_resolution,
(B[m[32m+            ConflictResolutionStrategy::ImportanceBased
(B[m[32m+        );
(B[m         assert_eq!(params.importance_threshold, 0.7);
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:1:
 //! Memory Conflict Resolution
[31m-//! 
(B[m[32m+//!
(B[m //! Advanced conflict resolution algorithms ported from ContextEngine
 //! for handling memory conflicts with multiple resolution strategies.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:6:
[31m-use crate::hierarchical_service::{HierarchicalMemoryRecord, ConflictResolutionStrategy};
(B[m[32m+use crate::hierarchical_service::{ConflictResolutionStrategy, HierarchicalMemoryRecord};
(B[m use crate::types::ImportanceLevel;
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m[32m+use chrono::{DateTime, Duration, Utc};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
[31m-use chrono::{DateTime, Utc, Duration};
(B[m 
 /// Conflict resolution engine
 pub struct ConflictResolver {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:124:
             }
 
             // Check for different types of conflicts
[31m-            let similarity = self.calculate_semantic_similarity(new_memory, existing_memory).await?;
(B[m[31m-            
(B[m[32m+            let similarity = self
(B[m[32m+                .calculate_semantic_similarity(new_memory, existing_memory)
(B[m[32m+                .await?;
(B[m[32m+
(B[m             if similarity > self.config.similarity_threshold {
                 conflicting_memories.push(existing_memory.clone());
                 max_similarity = max_similarity.max(similarity);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:132:
[31m-                
(B[m[32m+
(B[m                 // Determine conflict type
                 if similarity > 0.95 {
                     conflict_type = ConflictType::Duplicate;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:167:
 
         let resolution = match resolution_strategy {
             ConflictResolutionStrategy::TimeBasedNewest => {
[31m-                self.resolve_time_based_newest(new_memory, conflicting_memories).await?
(B[m[32m+                self.resolve_time_based_newest(new_memory, conflicting_memories)
(B[m[32m+                    .await?
(B[m             }
             ConflictResolutionStrategy::ImportanceBased => {
[31m-                self.resolve_importance_based(new_memory, conflicting_memories).await?
(B[m[32m+                self.resolve_importance_based(new_memory, conflicting_memories)
(B[m[32m+                    .await?
(B[m             }
             ConflictResolutionStrategy::SourceReliabilityBased => {
[31m-                self.resolve_source_reliability_based(new_memory, conflicting_memories).await?
(B[m[32m+                self.resolve_source_reliability_based(new_memory, conflicting_memories)
(B[m[32m+                    .await?
(B[m             }
             ConflictResolutionStrategy::SemanticMerge => {
[31m-                self.resolve_semantic_merge(new_memory, conflicting_memories).await?
(B[m[32m+                self.resolve_semantic_merge(new_memory, conflicting_memories)
(B[m[32m+                    .await?
(B[m             }
             ConflictResolutionStrategy::KeepBoth => {
[31m-                self.resolve_keep_both(new_memory, conflicting_memories).await?
(B[m[32m+                self.resolve_keep_both(new_memory, conflicting_memories)
(B[m[32m+                    .await?
(B[m             }
         };
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:186:
         // Cache the resolution
[31m-        self.resolution_cache.insert(conflict_id.clone(), resolution.clone());
(B[m[32m+        self.resolution_cache
(B[m[32m+            .insert(conflict_id.clone(), resolution.clone());
(B[m 
         Ok(resolution)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:199:
         // In production, would use embedding-based semantic similarity
         let content1 = memory1.content.to_lowercase();
         let content2 = memory2.content.to_lowercase();
[31m-        
(B[m[32m+
(B[m         // Simple word overlap similarity
         let words1: std::collections::HashSet<&str> = content1.split_whitespace().collect();
         let words2: std::collections::HashSet<&str> = content2.split_whitespace().collect();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:206:
[31m-        
(B[m[32m+
(B[m         let intersection = words1.intersection(&words2).count();
         let union = words1.union(&words2).count();
[31m-        
(B[m[32m+
(B[m         if union == 0 {
             Ok(0.0)
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:224:
         // In production, would use NLP techniques to detect contradictions
         let content1 = memory1.content.to_lowercase();
         let content2 = memory2.content.to_lowercase();
[31m-        
(B[m[32m+
(B[m         // Look for contradictory patterns
         let contradictory_pairs = [
             ("is", "is not"),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:233:
             ("can", "cannot"),
             ("will", "will not"),
         ];
[31m-        
(B[m[32m+
(B[m         for (positive, negative) in contradictory_pairs.iter() {
[31m-            if (content1.contains(positive) && content2.contains(negative)) ||
(B[m[31m-               (content1.contains(negative) && content2.contains(positive)) {
(B[m[32m+            if (content1.contains(positive) && content2.contains(negative))
(B[m[32m+                || (content1.contains(negative) && content2.contains(positive))
(B[m[32m+            {
(B[m                 return true;
             }
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:243:
[31m-        
(B[m[32m+
(B[m         false
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:252:
     ) -> bool {
         // Simplified temporal conflict detection
         // In production, would parse dates and check for temporal inconsistencies
[31m-        let time_diff = (memory1.created_at - memory2.created_at).num_minutes().abs();
(B[m[32m+        let time_diff = (memory1.created_at - memory2.created_at)
(B[m[32m+            .num_minutes()
(B[m[32m+            .abs();
(B[m         time_diff < 60 // Conflicts if created within 1 hour
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:264:
     ) -> Result<ConflictResolution> {
         let mut all_memories = vec![new_memory.clone()];
         all_memories.extend(conflicting_memories.iter().cloned());
[31m-        
(B[m[32m+
(B[m         // Sort by creation time, newest first
         all_memories.sort_by(|a, b| b.created_at.cmp(&a.created_at));
[31m-        
(B[m[32m+
(B[m         let resolved_memory = all_memories.into_iter().next();
[31m-        
(B[m[32m+
(B[m         Ok(ConflictResolution {
             conflict_id: uuid::Uuid::new_v4().to_string(),
             conflicting_memories: conflicting_memories.iter().map(|m| m.id.clone()).collect(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:290:
     ) -> Result<ConflictResolution> {
         let mut all_memories = vec![new_memory.clone()];
         all_memories.extend(conflicting_memories.iter().cloned());
[31m-        
(B[m[32m+
(B[m         // Sort by importance, highest first
         all_memories.sort_by(|a, b| b.importance.cmp(&a.importance));
[31m-        
(B[m[32m+
(B[m         let resolved_memory = all_memories.into_iter().next();
[31m-        
(B[m[32m+
(B[m         Ok(ConflictResolution {
             conflict_id: uuid::Uuid::new_v4().to_string(),
             conflicting_memories: conflicting_memories.iter().map(|m| m.id.clone()).collect(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:316:
     ) -> Result<ConflictResolution> {
         let mut all_memories = vec![new_memory.clone()];
         all_memories.extend(conflicting_memories.iter().cloned());
[31m-        
(B[m[32m+
(B[m         // Sort by source reliability, highest first
[31m-        all_memories.sort_by(|a, b| b.source_reliability.partial_cmp(&a.source_reliability).unwrap_or(std::cmp::Ordering::Equal));
(B[m[31m-        
(B[m[32m+        all_memories.sort_by(|a, b| {
(B[m[32m+            b.source_reliability
(B[m[32m+                .partial_cmp(&a.source_reliability)
(B[m[32m+                .unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+        });
(B[m[32m+
(B[m         let resolved_memory = all_memories.into_iter().next();
[31m-        
(B[m[32m+
(B[m         Ok(ConflictResolution {
             conflict_id: uuid::Uuid::new_v4().to_string(),
             conflicting_memories: conflicting_memories.iter().map(|m| m.id.clone()).collect(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:344:
         let mut merged_content = new_memory.content.clone();
         let mut merged_metadata = new_memory.metadata.clone();
         let mut merged_tags = new_memory.tags.clone();
[31m-        
(B[m[32m+
(B[m         for memory in conflicting_memories {
             // Simple merge - in production would use more sophisticated NLP
             if !merged_content.contains(&memory.content) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:351:
                 merged_content.push_str(&format!(" | {}", memory.content));
             }
[31m-            
(B[m[32m+
(B[m             // Merge metadata
             for (key, value) in &memory.metadata {
                 merged_metadata.entry(key.clone()).or_insert(value.clone());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:357:
             }
[31m-            
(B[m[32m+
(B[m             // Merge tags
             for tag in &memory.tags {
                 if !merged_tags.contains(tag) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:363:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         let mut merged_memory = new_memory.clone();
         merged_memory.content = merged_content;
         merged_memory.metadata = merged_metadata;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:370:
         merged_memory.tags = merged_tags;
         merged_memory.updated_at = Utc::now();
[31m-        
(B[m[32m+
(B[m         Ok(ConflictResolution {
             conflict_id: uuid::Uuid::new_v4().to_string(),
             conflicting_memories: conflicting_memories.iter().map(|m| m.id.clone()).collect(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:390:
     ) -> Result<ConflictResolution> {
         let mut all_memories = vec![new_memory.clone()];
         all_memories.extend(conflicting_memories.iter().cloned());
[31m-        
(B[m[32m+
(B[m         // Mark all memories as conflicting
         for memory in &mut all_memories {
[31m-            memory.metadata.insert("conflict_marker".to_string(), "true".to_string());
(B[m[31m-            memory.metadata.insert("conflict_timestamp".to_string(), Utc::now().to_rfc3339());
(B[m[32m+            memory
(B[m[32m+                .metadata
(B[m[32m+                .insert("conflict_marker".to_string(), "true".to_string());
(B[m[32m+            memory
(B[m[32m+                .metadata
(B[m[32m+                .insert("conflict_timestamp".to_string(), Utc::now().to_rfc3339());
(B[m         }
[31m-        
(B[m[32m+
(B[m         Ok(ConflictResolution {
             conflict_id: uuid::Uuid::new_v4().to_string(),
             conflicting_memories: conflicting_memories.iter().map(|m| m.id.clone()).collect(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:413:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    use crate::hierarchy::{MemoryScope, MemoryLevel};
(B[m[32m+    use crate::hierarchy::{MemoryLevel, MemoryScope};
(B[m 
     fn create_test_memory(content: &str, importance: ImportanceLevel) -> HierarchicalMemoryRecord {
         HierarchicalMemoryRecord {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:439:
     #[tokio::test]
     async fn test_conflict_detection() {
         let resolver = ConflictResolver::new(ConflictResolverConfig::default());
[31m-        
(B[m[32m+
(B[m         let new_memory = create_test_memory("The sky is blue", ImportanceLevel::Medium);
         let existing_memory = create_test_memory("The sky is blue", ImportanceLevel::High); // Make them more similar
[31m-        
(B[m[31m-        let detection = resolver.detect_conflicts(&new_memory, &[existing_memory]).await.unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let detection = resolver
(B[m[32m+            .detect_conflicts(&new_memory, &[existing_memory])
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         assert!(detection.has_conflict);
         assert_eq!(detection.conflicting_memories.len(), 1);
         assert!(detection.similarity_score > 0.5);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/conflict_resolver.rs:453:
     #[tokio::test]
     async fn test_importance_based_resolution() {
         let mut resolver = ConflictResolver::new(ConflictResolverConfig::default());
[31m-        
(B[m[32m+
(B[m         let new_memory = create_test_memory("Important fact", ImportanceLevel::Medium);
         let conflicting_memory = create_test_memory("Very important fact", ImportanceLevel::High);
[31m-        
(B[m[31m-        let resolution = resolver.resolve_conflicts(
(B[m[31m-            &new_memory,
(B[m[31m-            &[conflicting_memory.clone()],
(B[m[31m-            Some(ConflictResolutionStrategy::ImportanceBased)
(B[m[31m-        ).await.unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let resolution = resolver
(B[m[32m+            .resolve_conflicts(
(B[m[32m+                &new_memory,
(B[m[32m+                &[conflicting_memory.clone()],
(B[m[32m+                Some(ConflictResolutionStrategy::ImportanceBased),
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         assert!(resolution.resolved_memory.is_some());
         let resolved = resolution.resolved_memory.unwrap();
         assert_eq!(resolved.importance, ImportanceLevel::High);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:1:
 //! Context-Aware Memory Search System
[31m-//! 
(B[m[32m+//!
(B[m //! Advanced search capabilities that understand and adapt to current context,
 //! providing intelligent memory retrieval and recommendations.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:6:
[32m+use crate::adaptive_strategy::MemoryStrategy;
(B[m use crate::hierarchical_service::{HierarchicalMemoryRecord, HierarchicalSearchFilters};
[32m+use crate::hierarchy::{MemoryLevel, MemoryScope};
(B[m use crate::importance_scorer::{ImportanceFactors, ScoringContext};
[31m-use crate::adaptive_strategy::MemoryStrategy;
(B[m[31m-use crate::hierarchy::{MemoryScope, MemoryLevel};
(B[m use crate::types::{ImportanceLevel, MemoryType};
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m[32m+use chrono::{DateTime, Duration, Utc};
(B[m use serde::{Deserialize, Serialize};
[31m-use std::collections::{HashMap, BTreeMap, HashSet};
(B[m[31m-use chrono::{DateTime, Utc, Duration};
(B[m[32m+use std::collections::{BTreeMap, HashMap, HashSet};
(B[m use uuid::Uuid;
 
 /// Configuration for context-aware search
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:173:
         memories: &[HierarchicalMemoryRecord],
     ) -> Result<Vec<ContextualSearchResult>> {
         let start_time = std::time::Instant::now();
[31m-        
(B[m[32m+
(B[m         // Check cache first
         if self.config.enable_result_caching {
             let cache_key = self.generate_cache_key(&query);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:203:
         };
 
         // Apply context-aware filtering
[31m-        results = self.apply_context_filtering(results, &query.context).await?;
(B[m[32m+        results = self
(B[m[32m+            .apply_context_filtering(results, &query.context)
(B[m[32m+            .await?;
(B[m 
         // Apply hierarchical filters if provided
         if let Some(ref filters) = query.filters {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:226:
         // Cache results
         if self.config.enable_result_caching {
             let cache_key = self.generate_cache_key(&query);
[31m-            self.search_cache.insert(cache_key, (results.clone(), Utc::now()));
(B[m[32m+            self.search_cache
(B[m[32m+                .insert(cache_key, (results.clone(), Utc::now()));
(B[m         }
 
         // Update analytics
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:251:
 
         for memory in memories {
             for query in queries {
[31m-                if memory.content.to_lowercase().contains(&query.to_lowercase()) {
(B[m[32m+                if memory
(B[m[32m+                    .content
(B[m[32m+                    .to_lowercase()
(B[m[32m+                    .contains(&query.to_lowercase())
(B[m[32m+                {
(B[m                     let snippet = self.extract_snippet(&memory.content, query);
                     results.push(ContextualSearchResult {
                         memory: memory.clone(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:258:
                         relevance_score: 1.0, // Exact match
[31m-                        context_score: 0.0, // Will be calculated later
(B[m[32m+                        context_score: 0.0,   // Will be calculated later
(B[m                         importance_factors: None,
                         match_reasons: vec!["Exact text match".to_string()],
                         snippet,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:290:
                 }
             }
 
[31m-            if best_score > 0.3 { // Minimum fuzzy threshold
(B[m[32m+            if best_score > 0.3 {
(B[m[32m+                // Minimum fuzzy threshold
(B[m                 let snippet = self.extract_snippet(&memory.content, &best_query);
                 results.push(ContextualSearchResult {
                     memory: memory.clone(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:320:
             let mut best_query = String::new();
 
             for query in queries {
[31m-                let score = self.calculate_semantic_similarity(&memory.content, query).await?;
(B[m[32m+                let score = self
(B[m[32m+                    .calculate_semantic_similarity(&memory.content, query)
(B[m[32m+                    .await?;
(B[m                 if score > best_score {
                     best_score = score;
                     best_query = query.clone();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:366:
         // Add fuzzy results, combining scores if memory already exists
         for result in fuzzy_results {
             if let Some(existing) = combined_results.get_mut(&result.memory.id) {
[31m-                existing.relevance_score = (existing.relevance_score + result.relevance_score * 0.7) / 2.0;
(B[m[32m+                existing.relevance_score =
(B[m[32m+                    (existing.relevance_score + result.relevance_score * 0.7) / 2.0;
(B[m                 existing.match_reasons.extend(result.match_reasons);
             } else {
                 combined_results.insert(result.memory.id.clone(), result);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:376:
         // Add semantic results
         for result in semantic_results {
             if let Some(existing) = combined_results.get_mut(&result.memory.id) {
[31m-                existing.relevance_score = (existing.relevance_score + result.relevance_score * 0.8) / 2.0;
(B[m[32m+                existing.relevance_score =
(B[m[32m+                    (existing.relevance_score + result.relevance_score * 0.8) / 2.0;
(B[m                 existing.match_reasons.extend(result.match_reasons);
             } else {
                 combined_results.insert(result.memory.id.clone(), result);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:394:
     ) -> Result<Vec<ContextualSearchResult>> {
         // Choose strategy based on query characteristics and context
         let strategy = self.determine_optimal_strategy(query);
[31m-        
(B[m[32m+
(B[m         match strategy {
[31m-            SearchStrategy::Exact => self.exact_search(&[query.query_text.clone()], memories).await,
(B[m[31m-            SearchStrategy::Fuzzy => self.fuzzy_search(&[query.query_text.clone()], memories).await,
(B[m[31m-            SearchStrategy::Semantic => self.semantic_search(&[query.query_text.clone()], memories).await,
(B[m[31m-            SearchStrategy::Hybrid => self.hybrid_search(&[query.query_text.clone()], memories).await,
(B[m[32m+            SearchStrategy::Exact => {
(B[m[32m+                self.exact_search(&[query.query_text.clone()], memories)
(B[m[32m+                    .await
(B[m[32m+            }
(B[m[32m+            SearchStrategy::Fuzzy => {
(B[m[32m+                self.fuzzy_search(&[query.query_text.clone()], memories)
(B[m[32m+                    .await
(B[m[32m+            }
(B[m[32m+            SearchStrategy::Semantic => {
(B[m[32m+                self.semantic_search(&[query.query_text.clone()], memories)
(B[m[32m+                    .await
(B[m[32m+            }
(B[m[32m+            SearchStrategy::Hybrid => {
(B[m[32m+                self.hybrid_search(&[query.query_text.clone()], memories)
(B[m[32m+                    .await
(B[m[32m+            }
(B[m             SearchStrategy::Adaptive => {
                 // Fallback to hybrid if we end up here recursively
[31m-                self.hybrid_search(&[query.query_text.clone()], memories).await
(B[m[32m+                self.hybrid_search(&[query.query_text.clone()], memories)
(B[m[32m+                    .await
(B[m             }
         }
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:436:
 
             // Time-based context
             if self.config.enable_temporal_weighting {
[31m-                let time_since_access = context.current_time
(B[m[32m+                let time_since_access = context
(B[m[32m+                    .current_time
(B[m                     .signed_duration_since(result.memory.accessed_at)
                     .num_hours() as f64;
[31m-                let temporal_score = (-self.config.temporal_decay_factor * time_since_access / 24.0).exp();
(B[m[32m+                let temporal_score =
(B[m[32m+                    (-self.config.temporal_decay_factor * time_since_access / 24.0).exp();
(B[m                 context_score += temporal_score * 0.3;
             }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:459:
 
             // Task context
             if let Some(ref task) = context.current_task {
[31m-                if result.memory.content.to_lowercase().contains(&task.to_lowercase()) {
(B[m[32m+                if result
(B[m[32m+                    .memory
(B[m[32m+                    .content
(B[m[32m+                    .to_lowercase()
(B[m[32m+                    .contains(&task.to_lowercase())
(B[m[32m+                {
(B[m                     context_score += 0.1;
                 }
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:571:
         }
 
         // Sort by composite score
[31m-        results.sort_by(|a, b| b.relevance_score.partial_cmp(&a.relevance_score).unwrap_or(std::cmp::Ordering::Equal));
(B[m[32m+        results.sort_by(|a, b| {
(B[m[32m+            b.relevance_score
(B[m[32m+                .partial_cmp(&a.relevance_score)
(B[m[32m+                .unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+        });
(B[m 
         Ok(results)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:581:
         let hours_since_access = Utc::now()
             .signed_duration_since(memory.accessed_at)
             .num_hours() as f64;
[31m-        
(B[m[32m+
(B[m         (-0.01 * hours_since_access).exp()
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:590:
         // Simple word overlap similarity
         let words1: HashSet<&str> = text1.split_whitespace().collect();
         let words2: HashSet<&str> = text2.split_whitespace().collect();
[31m-        
(B[m[32m+
(B[m         let intersection = words1.intersection(&words2).count();
         let union = words1.union(&words2).count();
[31m-        
(B[m[32m+
(B[m         if union == 0 {
             0.0
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:620:
 
         // Simple query expansion (in production, would use more sophisticated methods)
         let words: Vec<&str> = query.split_whitespace().collect();
[31m-        
(B[m[32m+
(B[m         // Add synonyms and related terms (simplified)
         let synonyms = HashMap::from([
             ("important", vec!["critical", "significant", "vital"]),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:638:
         }
 
         // Cache the expansions
[31m-        self.expanded_queries.insert(query.to_string(), expanded[1..].to_vec());
(B[m[32m+        self.expanded_queries
(B[m[32m+            .insert(query.to_string(), expanded[1..].to_vec());
(B[m 
         Ok(expanded)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:647:
     fn extract_snippet(&self, content: &str, query: &str) -> String {
         let query_words: Vec<&str> = query.split_whitespace().collect();
         let content_words: Vec<&str> = content.split_whitespace().collect();
[31m-        
(B[m[32m+
(B[m         // Find the best matching position
         let mut best_start = 0;
         let mut best_matches = 0;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:654:
[31m-        
(B[m[32m+
(B[m         for i in 0..content_words.len() {
             let mut matches = 0;
             for j in 0..query_words.len().min(content_words.len() - i) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:658:
[31m-                if content_words[i + j].to_lowercase().contains(&query_words[j].to_lowercase()) {
(B[m[32m+                if content_words[i + j]
(B[m[32m+                    .to_lowercase()
(B[m[32m+                    .contains(&query_words[j].to_lowercase())
(B[m[32m+                {
(B[m                     matches += 1;
                 }
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:664:
                 best_start = i;
             }
         }
[31m-        
(B[m[32m+
(B[m         // Extract snippet around best match
         let snippet_start = best_start.saturating_sub(5);
         let snippet_end = (best_start + 15).min(content_words.len());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:671:
[31m-        
(B[m[32m+
(B[m         let snippet_words = &content_words[snippet_start..snippet_end];
         let mut snippet = snippet_words.join(" ");
[31m-        
(B[m[32m+
(B[m         if snippet_start > 0 {
             snippet = format!("...{}", snippet);
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:678:
         if snippet_end < content_words.len() {
             snippet = format!("{}...", snippet);
         }
[31m-        
(B[m[32m+
(B[m         snippet
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:696:
     /// Update search analytics
     fn update_search_analytics(&mut self, query: &str, result_count: usize, response_time_ms: u64) {
         self.search_analytics.query_count += 1;
[31m-        
(B[m[32m+
(B[m         // Update average results per query
         let old_avg = self.search_analytics.average_results_per_query;
         let count = self.search_analytics.query_count as f64;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:703:
[31m-        self.search_analytics.average_results_per_query = 
(B[m[32m+        self.search_analytics.average_results_per_query =
(B[m             (old_avg * (count - 1.0) + result_count as f64) / count;
[31m-        
(B[m[32m+
(B[m         // Update average response time
         let old_time = self.search_analytics.average_response_time_ms;
[31m-        self.search_analytics.average_response_time_ms = 
(B[m[32m+        self.search_analytics.average_response_time_ms =
(B[m             ((old_time as f64 * (count - 1.0) + response_time_ms as f64) / count) as u64;
[31m-        
(B[m[32m+
(B[m         // Track query patterns
[31m-        *self.search_analytics.search_patterns.entry(query.to_string()).or_insert(0) += 1;
(B[m[31m-        
(B[m[32m+        *self
(B[m[32m+            .search_analytics
(B[m[32m+            .search_patterns
(B[m[32m+            .entry(query.to_string())
(B[m[32m+            .or_insert(0) += 1;
(B[m[32m+
(B[m         // Update query history
[31m-        self.query_history.push((query.to_string(), Utc::now(), result_count));
(B[m[31m-        
(B[m[32m+        self.query_history
(B[m[32m+            .push((query.to_string(), Utc::now(), result_count));
(B[m[32m+
(B[m         // Limit history size
         if self.query_history.len() > 1000 {
             self.query_history.remove(0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:727:
         results: &[ContextualSearchResult],
     ) -> Result<()> {
         if let Some(ref user_id) = query.context.user_id {
[31m-            let user_prefs = self.user_preferences.entry(user_id.clone()).or_insert_with(HashMap::new);
(B[m[31m-            
(B[m[32m+            let user_prefs = self
(B[m[32m+                .user_preferences
(B[m[32m+                .entry(user_id.clone())
(B[m[32m+                .or_insert_with(HashMap::new);
(B[m[32m+
(B[m             // Learn from result characteristics
[31m-            for result in results.iter().take(5) { // Top 5 results
(B[m[32m+            for result in results.iter().take(5) {
(B[m[32m+                // Top 5 results
(B[m                 // Update scope preferences
                 let scope_key = format!("scope_{:?}", result.memory.scope);
                 *user_prefs.entry(scope_key).or_insert(0.0) += 0.1;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:737:
[31m-                
(B[m[32m+
(B[m                 // Update level preferences
                 let level_key = format!("level_{:?}", result.memory.level);
                 *user_prefs.entry(level_key).or_insert(0.0) += 0.1;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:741:
[31m-                
(B[m[32m+
(B[m                 // Update importance preferences
                 let importance_key = format!("importance_{:?}", result.memory.importance);
                 *user_prefs.entry(importance_key).or_insert(0.0) += 0.1;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:745:
             }
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:778:
             tags: Vec::new(),
             parent_memory_id: None,
             child_memory_ids: Vec::new(),
[31m-            conflict_resolution_strategy: crate::hierarchical_service::ConflictResolutionStrategy::ImportanceBased,
(B[m[32m+            conflict_resolution_strategy:
(B[m[32m+                crate::hierarchical_service::ConflictResolutionStrategy::ImportanceBased,
(B[m             quality_score: 1.0,
             source_reliability: 1.0,
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:788:
     async fn test_context_aware_search_engine_creation() {
         let config = ContextAwareSearchConfig::default();
         let engine = ContextAwareSearchEngine::new(config);
[31m-        
(B[m[32m+
(B[m         assert_eq!(engine.search_cache.len(), 0);
         assert_eq!(engine.query_history.len(), 0);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:797:
     async fn test_exact_search() {
         let config = ContextAwareSearchConfig::default();
         let engine = ContextAwareSearchEngine::new(config);
[31m-        
(B[m[32m+
(B[m         let memories = vec![
             create_test_memory("This is a test memory"),
             create_test_memory("Another memory for testing"),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:804:
             create_test_memory("Unrelated content"),
         ];
[31m-        
(B[m[31m-        let results = engine.exact_search(&["test".to_string()], &memories).await.unwrap();
(B[m[32m+
(B[m[32m+        let results = engine
(B[m[32m+            .exact_search(&["test".to_string()], &memories)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m         assert_eq!(results.len(), 2); // Two memories contain "test"
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:812:
     async fn test_fuzzy_search() {
         let config = ContextAwareSearchConfig::default();
         let engine = ContextAwareSearchEngine::new(config);
[31m-        
(B[m[32m+
(B[m         let memories = vec![
             create_test_memory("This is a test memory"),
             create_test_memory("Testing fuzzy search"),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:819:
             create_test_memory("Completely different content"),
         ];
[31m-        
(B[m[31m-        let results = engine.fuzzy_search(&["test memory".to_string()], &memories).await.unwrap();
(B[m[32m+
(B[m[32m+        let results = engine
(B[m[32m+            .fuzzy_search(&["test memory".to_string()], &memories)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m         assert!(!results.is_empty());
         assert!(results[0].relevance_score > 0.3);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:828:
     async fn test_contextual_search() {
         let config = ContextAwareSearchConfig::default();
         let mut engine = ContextAwareSearchEngine::new(config);
[31m-        
(B[m[32m+
(B[m         let memories = vec![
             create_test_memory("Important task information"),
             create_test_memory("Regular memory content"),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:835:
         ];
[31m-        
(B[m[32m+
(B[m         let query = ContextualSearchQuery {
             query_text: "task".to_string(),
             context: ScoringContext::default(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/context_aware_search.rs:841:
             search_strategy: SearchStrategy::Exact,
             result_preferences: ResultPreferences::default(),
         };
[31m-        
(B[m[32m+
(B[m         let results = engine.search(query, &memories).await.unwrap();
         assert!(!results.is_empty());
         assert_eq!(results[0].rank, 1);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:1:
 //! Enhanced Hierarchical Memory Service
[31m-//! 
(B[m[32m+//!
(B[m //! Complete implementation of ContextEngine's hierarchical memory architecture
 //! with advanced features like memory inheritance, conflict resolution, and
 //! intelligent routing.
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:6:
 
[31m-use crate::hierarchy::{MemoryScope, MemoryLevel};
(B[m[31m-use crate::types::{Memory, MemoryType, ImportanceLevel};
(B[m[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use crate::hierarchy::{MemoryLevel, MemoryScope};
(B[m[32m+use crate::types::{ImportanceLevel, Memory, MemoryType};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m[32m+use chrono::{DateTime, Utc};
(B[m use serde::{Deserialize, Serialize};
[31m-use std::collections::{HashMap, BTreeMap};
(B[m[32m+use std::collections::{BTreeMap, HashMap};
(B[m use std::sync::Arc;
 use tokio::sync::RwLock;
 use uuid::Uuid;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:15:
[31m-use chrono::{DateTime, Utc};
(B[m 
[31m-
(B[m[31m-
(B[m /// Hierarchical memory record with enhanced metadata
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct HierarchicalMemoryRecord {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:90:
 /// Enhanced hierarchical memory service
 pub struct HierarchicalMemoryService {
     /// Memory storage organized by scope and level
[31m-    memories: Arc<RwLock<BTreeMap<MemoryScope, BTreeMap<MemoryLevel, Vec<HierarchicalMemoryRecord>>>>>,
(B[m[32m+    memories:
(B[m[32m+        Arc<RwLock<BTreeMap<MemoryScope, BTreeMap<MemoryLevel, Vec<HierarchicalMemoryRecord>>>>>,
(B[m     /// Memory index for fast lookups
     memory_index: Arc<RwLock<HashMap<String, (MemoryScope, MemoryLevel, usize)>>>,
     /// Inheritance rules
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:178:
             parent_memory_id: None,
             child_memory_ids: Vec::new(),
             conflict_resolution_strategy: self.config.default_conflict_strategy.clone(),
[31m-            quality_score: 1.0, // Default quality score
(B[m[32m+            quality_score: 1.0,      // Default quality score
(B[m             source_reliability: 1.0, // Default source reliability
         };
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:192:
             let mut memories = self.memories.write().await;
             let scope_memories = memories.entry(scope.clone()).or_insert_with(BTreeMap::new);
             let level_memories = scope_memories.entry(level.clone()).or_insert_with(Vec::new);
[31m-            
(B[m[32m+
(B[m             // Check capacity limits
             if level_memories.len() >= self.config.max_memories_per_scope_level {
                 // Remove oldest memory if at capacity
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:203:
                     index.remove(&removed.id);
                 }
             }
[31m-            
(B[m[32m+
(B[m             let memory_index = level_memories.len();
             level_memories.push(memory.clone());
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:227:
         request_scope: &MemoryScope,
     ) -> Result<Option<HierarchicalMemoryRecord>> {
         let index = self.memory_index.read().await;
[31m-        
(B[m[32m+
(B[m         if let Some((scope, level, memory_index)) = index.get(memory_id) {
             // Check access permissions
             if !request_scope.can_access(scope) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:234:
[31m-                return Err(AgentMemError::memory_error(
(B[m[31m-                    &format!("Scope {:?} cannot access memory in scope {:?}", request_scope, scope)
(B[m[31m-                ));
(B[m[32m+                return Err(AgentMemError::memory_error(&format!(
(B[m[32m+                    "Scope {:?} cannot access memory in scope {:?}",
(B[m[32m+                    request_scope, scope
(B[m[32m+                )));
(B[m             }
 
             let memories = self.memories.read().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:277:
                     }
 
                     // Simple text search (in production, would use semantic search)
[31m-                    if memory.content.to_lowercase().contains(&query.to_lowercase()) {
(B[m[32m+                    if memory
(B[m[32m+                        .content
(B[m[32m+                        .to_lowercase()
(B[m[32m+                        .contains(&query.to_lowercase())
(B[m[32m+                    {
(B[m                         results.push(memory.clone());
                     }
                 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:286:
 
         // Sort by relevance and importance
         results.sort_by(|a, b| {
[31m-            b.importance.cmp(&a.importance)
(B[m[31m-                .then_with(|| b.quality_score.partial_cmp(&a.quality_score).unwrap_or(std::cmp::Ordering::Equal))
(B[m[32m+            b.importance
(B[m[32m+                .cmp(&a.importance)
(B[m[32m+                .then_with(|| {
(B[m[32m+                    b.quality_score
(B[m[32m+                        .partial_cmp(&a.quality_score)
(B[m[32m+                        .unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+                })
(B[m                 .then_with(|| b.accessed_at.cmp(&a.accessed_at))
         });
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:297:
     /// Initialize default inheritance rules
     async fn initialize_default_inheritance_rules(&self) -> Result<()> {
         let mut rules = self.inheritance_rules.write().await;
[31m-        
(B[m[32m+
(B[m         // Global memories are inherited by all scopes
         rules.push(MemoryInheritanceRule {
             from_scope: MemoryScope::Global,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:312:
         // Agent memories are inherited by user scopes
         rules.push(MemoryInheritanceRule {
             from_scope: MemoryScope::Agent("*".to_string()),
[31m-            to_scope: MemoryScope::User { agent_id: "*".to_string(), user_id: "*".to_string() },
(B[m[32m+            to_scope: MemoryScope::User {
(B[m[32m+                agent_id: "*".to_string(),
(B[m[32m+                user_id: "*".to_string(),
(B[m[32m+            },
(B[m             inheritance_type: InheritanceType::Summary,
             conditions: vec![
                 InheritanceCondition::MinImportance(ImportanceLevel::High),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:339:
 
     /// Find oldest memory index in a level
     fn find_oldest_memory_index(&self, memories: &[HierarchicalMemoryRecord]) -> Option<usize> {
[31m-        memories.iter()
(B[m[32m+        memories
(B[m[32m+            .iter()
(B[m             .enumerate()
             .min_by_key(|(_, memory)| memory.created_at)
             .map(|(index, _)| index)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:352:
     }
 
     /// Check if memory matches search filters
[31m-    fn matches_filters(&self, memory: &HierarchicalMemoryRecord, filters: &HierarchicalSearchFilters) -> bool {
(B[m[32m+    fn matches_filters(
(B[m[32m+        &self,
(B[m[32m+        memory: &HierarchicalMemoryRecord,
(B[m[32m+        filters: &HierarchicalSearchFilters,
(B[m[32m+    ) -> bool {
(B[m         // Implementation would check various filter conditions
         true
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:385:
     async fn test_add_hierarchical_memory() {
         let config = HierarchicalServiceConfig::default();
         let service = HierarchicalMemoryService::new(config).await.unwrap();
[31m-        
(B[m[31m-        let memory = service.add_hierarchical_memory(
(B[m[31m-            "Test memory content".to_string(),
(B[m[31m-            MemoryScope::Global,
(B[m[31m-            MemoryLevel::Strategic,
(B[m[31m-            ImportanceLevel::High,
(B[m[31m-            HashMap::new(),
(B[m[31m-        ).await;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let memory = service
(B[m[32m+            .add_hierarchical_memory(
(B[m[32m+                "Test memory content".to_string(),
(B[m[32m+                MemoryScope::Global,
(B[m[32m+                MemoryLevel::Strategic,
(B[m[32m+                ImportanceLevel::High,
(B[m[32m+                HashMap::new(),
(B[m[32m+            )
(B[m[32m+            .await;
(B[m[32m+
(B[m         assert!(memory.is_ok());
         let memory = memory.unwrap();
         assert_eq!(memory.content, "Test memory content");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchical_service.rs:405:
     async fn test_memory_access_control() {
         let config = HierarchicalServiceConfig::default();
         let service = HierarchicalMemoryService::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         // Add a user-scoped memory
[31m-        let memory = service.add_hierarchical_memory(
(B[m[31m-            "User memory".to_string(),
(B[m[31m-            MemoryScope::User { agent_id: "agent1".to_string(), user_id: "user1".to_string() },
(B[m[31m-            MemoryLevel::Operational,
(B[m[31m-            ImportanceLevel::Medium,
(B[m[31m-            HashMap::new(),
(B[m[31m-        ).await.unwrap();
(B[m[31m-        
(B[m[32m+        let memory = service
(B[m[32m+            .add_hierarchical_memory(
(B[m[32m+                "User memory".to_string(),
(B[m[32m+                MemoryScope::User {
(B[m[32m+                    agent_id: "agent1".to_string(),
(B[m[32m+                    user_id: "user1".to_string(),
(B[m[32m+                },
(B[m[32m+                MemoryLevel::Operational,
(B[m[32m+                ImportanceLevel::Medium,
(B[m[32m+                HashMap::new(),
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Test access from same scope - should succeed
[31m-        let result = service.get_hierarchical_memory(
(B[m[31m-            &memory.id,
(B[m[31m-            &MemoryScope::User { agent_id: "agent1".to_string(), user_id: "user1".to_string() }
(B[m[31m-        ).await;
(B[m[32m+        let result = service
(B[m[32m+            .get_hierarchical_memory(
(B[m[32m+                &memory.id,
(B[m[32m+                &MemoryScope::User {
(B[m[32m+                    agent_id: "agent1".to_string(),
(B[m[32m+                    user_id: "user1".to_string(),
(B[m[32m+                },
(B[m[32m+            )
(B[m[32m+            .await;
(B[m         assert!(result.is_ok());
         assert!(result.unwrap().is_some());
[31m-        
(B[m[32m+
(B[m         // Test access from different user - should fail
[31m-        let result = service.get_hierarchical_memory(
(B[m[31m-            &memory.id,
(B[m[31m-            &MemoryScope::User { agent_id: "agent1".to_string(), user_id: "user2".to_string() }
(B[m[31m-        ).await;
(B[m[32m+        let result = service
(B[m[32m+            .get_hierarchical_memory(
(B[m[32m+                &memory.id,
(B[m[32m+                &MemoryScope::User {
(B[m[32m+                    agent_id: "agent1".to_string(),
(B[m[32m+                    user_id: "user2".to_string(),
(B[m[32m+                },
(B[m[32m+            )
(B[m[32m+            .await;
(B[m         assert!(result.is_err());
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:1:
 //! Hierarchical memory management
[31m-//! 
(B[m[32m+//!
(B[m //! Implements ContextEngine's layered memory architecture with scoped access control.
 
 use crate::types::{Memory, MemoryType};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use uuid::Uuid;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:31:
     /// User-specific memories within an agent context
     User { agent_id: String, user_id: String },
     /// Session-specific memories
[31m-    Session { agent_id: String, user_id: String, session_id: String },
(B[m[32m+    Session {
(B[m[32m+        agent_id: String,
(B[m[32m+        user_id: String,
(B[m[32m+        session_id: String,
(B[m[32m+    },
(B[m }
 
 impl MemoryScope {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:40:
         match (self, other) {
             // Global scope can access everything
             (MemoryScope::Global, _) => true,
[31m-            
(B[m[32m+
(B[m             // Agent scope can access global and own agent memories
             (MemoryScope::Agent(agent_id), MemoryScope::Global) => true,
             (MemoryScope::Agent(agent_id), MemoryScope::Agent(other_agent_id)) => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:47:
                 agent_id == other_agent_id
             }
[31m-            
(B[m[32m+
(B[m             // User scope can access global, agent, and own user memories
             (MemoryScope::User { agent_id, user_id }, MemoryScope::Global) => true,
             (MemoryScope::User { agent_id, user_id }, MemoryScope::Agent(other_agent_id)) => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:53:
                 agent_id == other_agent_id
             }
[31m-            (MemoryScope::User { agent_id, user_id }, MemoryScope::User { agent_id: other_agent_id, user_id: other_user_id }) => {
(B[m[31m-                agent_id == other_agent_id && user_id == other_user_id
(B[m[31m-            }
(B[m[31m-            
(B[m[32m+            (
(B[m[32m+                MemoryScope::User { agent_id, user_id },
(B[m[32m+                MemoryScope::User {
(B[m[32m+                    agent_id: other_agent_id,
(B[m[32m+                    user_id: other_user_id,
(B[m[32m+                },
(B[m[32m+            ) => agent_id == other_agent_id && user_id == other_user_id,
(B[m[32m+
(B[m             // Session scope can access all parent scopes and own session
[31m-            (MemoryScope::Session { agent_id, user_id, session_id }, MemoryScope::Global) => true,
(B[m[31m-            (MemoryScope::Session { agent_id, user_id, session_id }, MemoryScope::Agent(other_agent_id)) => {
(B[m[32m+            (
(B[m[32m+                MemoryScope::Session {
(B[m[32m+                    agent_id,
(B[m[32m+                    user_id,
(B[m[32m+                    session_id,
(B[m[32m+                },
(B[m[32m+                MemoryScope::Global,
(B[m[32m+            ) => true,
(B[m[32m+            (
(B[m[32m+                MemoryScope::Session {
(B[m[32m+                    agent_id,
(B[m[32m+                    user_id,
(B[m[32m+                    session_id,
(B[m[32m+                },
(B[m[32m+                MemoryScope::Agent(other_agent_id),
(B[m[32m+            ) => agent_id == other_agent_id,
(B[m[32m+            (
(B[m[32m+                MemoryScope::Session {
(B[m[32m+                    agent_id,
(B[m[32m+                    user_id,
(B[m[32m+                    session_id,
(B[m[32m+                },
(B[m[32m+                MemoryScope::User {
(B[m[32m+                    agent_id: other_agent_id,
(B[m[32m+                    user_id: other_user_id,
(B[m[32m+                },
(B[m[32m+            ) => agent_id == other_agent_id && user_id == other_user_id,
(B[m[32m+            (
(B[m[32m+                MemoryScope::Session {
(B[m[32m+                    agent_id,
(B[m[32m+                    user_id,
(B[m[32m+                    session_id,
(B[m[32m+                },
(B[m[32m+                MemoryScope::Session {
(B[m[32m+                    agent_id: other_agent_id,
(B[m[32m+                    user_id: other_user_id,
(B[m[32m+                    session_id: other_session_id,
(B[m[32m+                },
(B[m[32m+            ) => {
(B[m                 agent_id == other_agent_id
[32m+                    && user_id == other_user_id
(B[m[32m+                    && session_id == other_session_id
(B[m             }
[31m-            (MemoryScope::Session { agent_id, user_id, session_id }, MemoryScope::User { agent_id: other_agent_id, user_id: other_user_id }) => {
(B[m[31m-                agent_id == other_agent_id && user_id == other_user_id
(B[m[31m-            }
(B[m[31m-            (MemoryScope::Session { agent_id, user_id, session_id }, MemoryScope::Session { agent_id: other_agent_id, user_id: other_user_id, session_id: other_session_id }) => {
(B[m[31m-                agent_id == other_agent_id && user_id == other_user_id && session_id == other_session_id
(B[m[31m-            }
(B[m[31m-            
(B[m[32m+
(B[m             // All other combinations are not allowed
             _ => false,
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:74:
     }
[31m-    
(B[m[32m+
(B[m     /// Get the hierarchy level (lower number = higher privilege)
     pub fn hierarchy_level(&self) -> u8 {
         match self {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:82:
             MemoryScope::Session { .. } => 3,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get parent scope
     pub fn parent(&self) -> Option<MemoryScope> {
         match self {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:89:
             MemoryScope::Global => None,
             MemoryScope::Agent(_) => Some(MemoryScope::Global),
             MemoryScope::User { agent_id, .. } => Some(MemoryScope::Agent(agent_id.clone())),
[31m-            MemoryScope::Session { agent_id, user_id, .. } => Some(MemoryScope::User {
(B[m[32m+            MemoryScope::Session {
(B[m[32m+                agent_id, user_id, ..
(B[m[32m+            } => Some(MemoryScope::User {
(B[m                 agent_id: agent_id.clone(),
                 user_id: user_id.clone(),
             }),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:102:
 pub struct HierarchicalMemory {
     /// Base memory data
     pub memory: Memory,
[31m-    
(B[m[32m+
(B[m     /// Memory scope
     pub scope: MemoryScope,
[31m-    
(B[m[32m+
(B[m     /// Inheritance rules
     pub inheritance: MemoryInheritance,
[31m-    
(B[m[32m+
(B[m     /// Access permissions
     pub permissions: MemoryPermissions,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:118:
 pub struct MemoryInheritance {
     /// Whether this memory can be inherited by child scopes
     pub inheritable: bool,
[31m-    
(B[m[32m+
(B[m     /// Whether this memory was inherited from a parent scope
     pub inherited: bool,
[31m-    
(B[m[32m+
(B[m     /// Original scope if inherited
     pub original_scope: Option<MemoryScope>,
[31m-    
(B[m[32m+
(B[m     /// Inheritance decay factor (reduces importance over scope levels)
     pub decay_factor: f32,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:145:
 pub struct MemoryPermissions {
     /// Can read this memory
     pub readable: bool,
[31m-    
(B[m[32m+
(B[m     /// Can modify this memory
     pub writable: bool,
[31m-    
(B[m[32m+
(B[m     /// Can delete this memory
     pub deletable: bool,
[31m-    
(B[m[32m+
(B[m     /// Can share this memory with other scopes
     pub shareable: bool,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:171:
 pub struct HierarchicalMemoryManager {
     /// Memories organized by scope
     memories: HashMap<MemoryScope, Vec<HierarchicalMemory>>,
[31m-    
(B[m[32m+
(B[m     /// Scope inheritance cache
     inheritance_cache: HashMap<MemoryScope, Vec<MemoryScope>>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:184:
             inheritance_cache: HashMap::new(),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Add a memory to a specific scope
     pub fn add_memory(
         &mut self,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:199:
             inheritance: inheritance.unwrap_or_default(),
             permissions: permissions.unwrap_or_default(),
         };
[31m-        
(B[m[32m+
(B[m         self.memories
             .entry(scope)
             .or_insert_with(Vec::new)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:206:
             .push(hierarchical_memory);
[31m-        
(B[m[32m+
(B[m         Ok(Uuid::new_v4().to_string())
     }
[31m-    
(B[m[32m+
(B[m     /// Get memories accessible from a specific scope
     pub fn get_accessible_memories(&self, scope: &MemoryScope) -> Vec<&HierarchicalMemory> {
         let mut accessible = Vec::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:214:
[31m-        
(B[m[32m+
(B[m         // Get all scopes this scope can access
         let accessible_scopes = self.get_accessible_scopes(scope);
[31m-        
(B[m[32m+
(B[m         for accessible_scope in accessible_scopes {
             if let Some(memories) = self.memories.get(&accessible_scope) {
                 for memory in memories {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:224:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         accessible
     }
[31m-    
(B[m[32m+
(B[m     /// Get inherited memories for a scope
     pub fn get_inherited_memories(&self, scope: &MemoryScope) -> Vec<HierarchicalMemory> {
         let mut inherited = Vec::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:234:
         let mut current_scope = scope.parent();
         let mut level = 1;
[31m-        
(B[m[32m+
(B[m         while let Some(parent_scope) = current_scope {
             if let Some(memories) = self.memories.get(&parent_scope) {
                 for memory in memories {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:240:
                     if memory.inheritance.inheritable && memory.permissions.shareable {
                         let mut inherited_memory = memory.clone();
[31m-                        
(B[m[32m+
(B[m                         // Apply inheritance decay
[31m-                        inherited_memory.memory.importance =
(B[m[31m-                            inherited_memory.memory.importance * memory.inheritance.decay_factor.powi(level);
(B[m[31m-                        
(B[m[32m+                        inherited_memory.memory.importance = inherited_memory.memory.importance
(B[m[32m+                            * memory.inheritance.decay_factor.powi(level);
(B[m[32m+
(B[m                         // Mark as inherited
                         inherited_memory.inheritance.inherited = true;
                         inherited_memory.inheritance.original_scope = Some(parent_scope.clone());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:250:
                         inherited_memory.scope = scope.clone();
[31m-                        
(B[m[32m+
(B[m                         inherited.push(inherited_memory);
                     }
                 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:255:
             }
[31m-            
(B[m[32m+
(B[m             current_scope = parent_scope.parent();
             level += 1;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:260:
[31m-        
(B[m[32m+
(B[m         inherited
     }
[31m-    
(B[m[32m+
(B[m     /// Get all scopes accessible from a given scope
     fn get_accessible_scopes(&self, scope: &MemoryScope) -> Vec<MemoryScope> {
         if let Some(cached) = self.inheritance_cache.get(scope) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:267:
             return cached.clone();
         }
[31m-        
(B[m[32m+
(B[m         let mut accessible = vec![scope.clone()];
         let mut current = scope.parent();
[31m-        
(B[m[32m+
(B[m         while let Some(parent) = current {
             accessible.push(parent.clone());
             current = parent.parent();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:276:
         }
[31m-        
(B[m[32m+
(B[m         accessible
     }
[31m-    
(B[m[32m+
(B[m     /// Update memory permissions
     pub fn update_permissions(
         &mut self,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:297:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         Err(AgentMemError::not_found("Memory not found"))
     }
[31m-    
(B[m[32m+
(B[m     /// Delete memory from scope
     pub fn delete_memory(&mut self, memory_id: &str, scope: &MemoryScope) -> Result<()> {
         if let Some(memories) = self.memories.get_mut(scope) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:319:
             Err(AgentMemError::not_found("Scope not found"))
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get memory statistics by scope
     pub fn get_scope_statistics(&self) -> HashMap<MemoryScope, ScopeStatistics> {
         let mut stats = HashMap::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:326:
[31m-        
(B[m[32m+
(B[m         for (scope, memories) in &self.memories {
             let mut scope_stats = ScopeStatistics::default();
[31m-            
(B[m[32m+
(B[m             for memory in memories {
                 scope_stats.total_memories += 1;
[31m-                
(B[m[32m+
(B[m                 match memory.memory.memory_type {
                     MemoryType::Episodic => scope_stats.episodic_memories += 1,
                     MemoryType::Semantic => scope_stats.semantic_memories += 1,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:336:
                     MemoryType::Procedural => scope_stats.procedural_memories += 1,
                     MemoryType::Working => scope_stats.untyped_memories += 1,
                 }
[31m-                
(B[m[32m+
(B[m                 if memory.inheritance.inherited {
                     scope_stats.inherited_memories += 1;
                 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:343:
[31m-                
(B[m[32m+
(B[m                 let importance = memory.memory.importance;
                 scope_stats.total_importance += importance;
                 if importance > scope_stats.max_importance {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:350:
                     scope_stats.min_importance = importance;
                 }
             }
[31m-            
(B[m[32m+
(B[m             if scope_stats.total_memories > 0 {
[31m-                scope_stats.avg_importance = scope_stats.total_importance / scope_stats.total_memories as f32;
(B[m[32m+                scope_stats.avg_importance =
(B[m[32m+                    scope_stats.total_importance / scope_stats.total_memories as f32;
(B[m             }
[31m-            
(B[m[32m+
(B[m             stats.insert(scope.clone(), scope_stats);
         }
[31m-        
(B[m[32m+
(B[m         stats
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:413:
             user_id: "user1".to_string(),
             session_id: "session1".to_string(),
         };
[31m-        
(B[m[32m+
(B[m         // Global can access everything
         assert!(global.can_access(&global));
         assert!(global.can_access(&agent));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:420:
         assert!(global.can_access(&user));
         assert!(global.can_access(&session));
[31m-        
(B[m[32m+
(B[m         // Agent can access global and own agent
         assert!(agent.can_access(&global));
         assert!(agent.can_access(&agent));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:426:
         assert!(!agent.can_access(&user));
         assert!(!agent.can_access(&session));
[31m-        
(B[m[32m+
(B[m         // User can access global, agent, and own user
         assert!(user.can_access(&global));
         assert!(user.can_access(&agent));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:432:
         assert!(user.can_access(&user));
         assert!(!user.can_access(&session));
[31m-        
(B[m[32m+
(B[m         // Session can access all parent scopes
         assert!(session.can_access(&global));
         assert!(session.can_access(&agent));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:438:
         assert!(session.can_access(&user));
         assert!(session.can_access(&session));
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_hierarchical_memory_manager() {
         let mut manager = HierarchicalMemoryManager::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:445:
[31m-        
(B[m[32m+
(B[m         let memory1 = create_test_memory("mem1", "Global memory");
         let memory2 = create_test_memory("mem2", "Agent memory");
         let memory3 = create_test_memory("mem3", "User memory");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:449:
[31m-        
(B[m[32m+
(B[m         let global_scope = MemoryScope::Global;
         let agent_scope = MemoryScope::Agent("agent1".to_string());
         let user_scope = MemoryScope::User {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:453:
             agent_id: "agent1".to_string(),
             user_id: "user1".to_string(),
         };
[31m-        
(B[m[32m+
(B[m         // Add memories to different scopes
[31m-        manager.add_memory(memory1, global_scope.clone(), None, None).unwrap();
(B[m[31m-        manager.add_memory(memory2, agent_scope.clone(), None, None).unwrap();
(B[m[31m-        manager.add_memory(memory3, user_scope.clone(), None, None).unwrap();
(B[m[31m-        
(B[m[32m+        manager
(B[m[32m+            .add_memory(memory1, global_scope.clone(), None, None)
(B[m[32m+            .unwrap();
(B[m[32m+        manager
(B[m[32m+            .add_memory(memory2, agent_scope.clone(), None, None)
(B[m[32m+            .unwrap();
(B[m[32m+        manager
(B[m[32m+            .add_memory(memory3, user_scope.clone(), None, None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Test accessible memories from user scope
         let accessible = manager.get_accessible_memories(&user_scope);
         assert_eq!(accessible.len(), 3); // Should access all three
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:465:
[31m-        
(B[m[32m+
(B[m         // Test accessible memories from agent scope
         let accessible = manager.get_accessible_memories(&agent_scope);
         assert_eq!(accessible.len(), 2); // Should access global and agent only
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:469:
[31m-        
(B[m[32m+
(B[m         // Test statistics
         let stats = manager.get_scope_statistics();
         assert_eq!(stats.len(), 3);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:474:
         assert_eq!(stats[&agent_scope].total_memories, 1);
         assert_eq!(stats[&user_scope].total_memories, 1);
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_memory_inheritance() {
         let mut manager = HierarchicalMemoryManager::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:481:
[31m-        
(B[m[32m+
(B[m         let global_memory = create_test_memory("global", "Global knowledge");
         let global_scope = MemoryScope::Global;
[31m-        
(B[m[32m+
(B[m         let user_scope = MemoryScope::User {
             agent_id: "agent1".to_string(),
             user_id: "user1".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:488:
         };
[31m-        
(B[m[32m+
(B[m         // Add inheritable memory to global scope
         let inheritance = MemoryInheritance {
             inheritable: true,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:494:
             original_scope: None,
             decay_factor: 0.8,
         };
[31m-        
(B[m[31m-        manager.add_memory(global_memory, global_scope, Some(inheritance), None).unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        manager
(B[m[32m+            .add_memory(global_memory, global_scope, Some(inheritance), None)
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Get inherited memories for user scope
         let inherited = manager.get_inherited_memories(&user_scope);
         assert_eq!(inherited.len(), 1);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy.rs:503:
         assert!(inherited[0].inheritance.inherited);
[31m-        assert_eq!(inherited[0].inheritance.original_scope, Some(MemoryScope::Global));
(B[m[31m-        
(B[m[32m+        assert_eq!(
(B[m[32m+            inherited[0].inheritance.original_scope,
(B[m[32m+            Some(MemoryScope::Global)
(B[m[32m+        );
(B[m[32m+
(B[m         // Check importance decay (0.8 * 0.8^2 = 0.512)
         let expected_importance = 0.8 * 0.8_f32.powi(2);
         assert!((inherited[0].memory.importance - expected_importance).abs() < 0.001);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:1:
 //! Advanced Hierarchical Memory Structure Management
[31m-//! 
(B[m[32m+//!
(B[m //! Provides sophisticated memory hierarchy management with dynamic
 //! structure adjustment and optimization capabilities.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:6:
[31m-use crate::hierarchy::{MemoryScope, MemoryLevel};
(B[m use crate::hierarchical_service::{HierarchicalMemoryRecord, HierarchicalMemoryService};
[32m+use crate::hierarchy::{MemoryLevel, MemoryScope};
(B[m use crate::types::ImportanceLevel;
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m[32m+use chrono::{DateTime, Duration, Utc};
(B[m use serde::{Deserialize, Serialize};
[31m-use std::collections::{HashMap, BTreeMap, VecDeque};
(B[m[32m+use std::collections::{BTreeMap, HashMap, VecDeque};
(B[m use std::sync::Arc;
 use tokio::sync::RwLock;
[31m-use chrono::{DateTime, Utc, Duration};
(B[m use uuid::Uuid;
 
 /// Advanced hierarchy management configuration
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:97:
     pub fn calculate_depth(&self, hierarchy: &HashMap<String, HierarchyNode>) -> usize {
         let mut depth = 0;
         let mut current_id = self.parent_id.as_ref();
[31m-        
(B[m[32m+
(B[m         while let Some(parent_id) = current_id {
             if let Some(parent) = hierarchy.get(parent_id) {
                 depth += 1;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:106:
                 break;
             }
         }
[31m-        
(B[m[32m+
(B[m         depth
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:175:
     ) -> Result<String> {
         // Find optimal placement in hierarchy
         let optimal_node_id = self.find_optimal_placement(memory).await?;
[31m-        
(B[m[32m+
(B[m         // Add memory to the node
         {
             let mut nodes = self.nodes.write().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:198:
     }
 
     /// Find optimal placement for a memory in the hierarchy
[31m-    async fn find_optimal_placement(
(B[m[31m-        &self,
(B[m[31m-        memory: &HierarchicalMemoryRecord,
(B[m[31m-    ) -> Result<String> {
(B[m[32m+    async fn find_optimal_placement(&self, memory: &HierarchicalMemoryRecord) -> Result<String> {
(B[m         let nodes = self.nodes.read().await;
[31m-        
(B[m[32m+
(B[m         // Find nodes matching scope and level
         let matching_nodes: Vec<_> = nodes
             .values()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:210:
             .filter(|node| {
[31m-                node.scope == memory.scope && 
(B[m[31m-                node.level == memory.level &&
(B[m[31m-                node.memory_ids.len() < self.config.max_memories_per_node
(B[m[32m+                node.scope == memory.scope
(B[m[32m+                    && node.level == memory.level
(B[m[32m+                    && node.memory_ids.len() < self.config.max_memories_per_node
(B[m             })
             .collect();
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:218:
             Ok(best_node.id.clone())
         } else {
             // Create new node if no suitable node exists
[31m-            self.create_hierarchy_node(memory.scope.clone(), memory.level.clone()).await
(B[m[32m+            self.create_hierarchy_node(memory.scope.clone(), memory.level.clone())
(B[m[32m+                .await
(B[m         }
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:229:
         level: MemoryLevel,
     ) -> Result<String> {
         let mut node = HierarchyNode::new(scope.clone(), level.clone());
[31m-        
(B[m[32m+
(B[m         // Find appropriate parent
         if let Some(parent_id) = self.find_parent_node(&scope, &level).await? {
             node.parent_id = Some(parent_id.clone());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:236:
[31m-            
(B[m[32m+
(B[m             // Update parent's children list
             let mut nodes = self.nodes.write().await;
             if let Some(parent) = nodes.get_mut(&parent_id) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:249:
         // Update indices
         {
             let mut scope_index = self.scope_index.write().await;
[31m-            scope_index.entry(scope).or_insert_with(Vec::new).push(node.id.clone());
(B[m[32m+            scope_index
(B[m[32m+                .entry(scope)
(B[m[32m+                .or_insert_with(Vec::new)
(B[m[32m+                .push(node.id.clone());
(B[m         }
         {
             let mut level_index = self.level_index.write().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:256:
[31m-            level_index.entry(level).or_insert_with(Vec::new).push(node.id.clone());
(B[m[32m+            level_index
(B[m[32m+                .entry(level)
(B[m[32m+                .or_insert_with(Vec::new)
(B[m[32m+                .push(node.id.clone());
(B[m         }
 
         Ok(node.id)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:266:
         level: &MemoryLevel,
     ) -> Result<Option<String>> {
         let nodes = self.nodes.read().await;
[31m-        
(B[m[32m+
(B[m         // Look for parent in higher level or broader scope
         let parent_candidates: Vec<_> = nodes
             .values()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:273:
             .filter(|node| {
[31m-                self.is_valid_parent(&node.scope, scope) &&
(B[m[31m-                self.is_higher_level(&node.level, level)
(B[m[32m+                self.is_valid_parent(&node.scope, scope) && self.is_higher_level(&node.level, level)
(B[m             })
             .collect();
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:320:
         ];
 
         for level in levels {
[31m-            self.create_hierarchy_node(MemoryScope::Global, level).await?;
(B[m[32m+            self.create_hierarchy_node(MemoryScope::Global, level)
(B[m[32m+                .await?;
(B[m         }
 
         Ok(())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:327:
     }
 
     /// Update indices after adding a memory
[31m-    async fn update_indices_after_addition(
(B[m[31m-        &self,
(B[m[31m-        memory: &HierarchicalMemoryRecord,
(B[m[31m-    ) -> Result<()> {
(B[m[32m+    async fn update_indices_after_addition(&self, memory: &HierarchicalMemoryRecord) -> Result<()> {
(B[m         // Update scope-based statistics
         {
             let mut stats = self.statistics.write().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:380:
     async fn check_and_optimize(&self) -> Result<()> {
         let last_optimization = *self.last_optimization.read().await;
         let now = Utc::now();
[31m-        
(B[m[31m-        if now.signed_duration_since(last_optimization).num_hours() >= 
(B[m[31m-           self.config.rebalance_interval_hours as i64 {
(B[m[32m+
(B[m[32m+        if now.signed_duration_since(last_optimization).num_hours()
(B[m[32m+            >= self.config.rebalance_interval_hours as i64
(B[m[32m+        {
(B[m             self.optimize_hierarchy().await?;
             *self.last_optimization.write().await = now;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:394:
     async fn optimize_hierarchy(&self) -> Result<()> {
         // Identify overloaded nodes
         let overloaded_nodes = self.find_overloaded_nodes().await?;
[31m-        
(B[m[32m+
(B[m         // Rebalance overloaded nodes
         for node_id in overloaded_nodes {
             self.rebalance_node(&node_id).await?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:493:
     async fn test_hierarchy_manager_creation() {
         let config = HierarchyManagerConfig::default();
         let service_config = HierarchicalServiceConfig::default();
[31m-        let service = Arc::new(HierarchicalMemoryService::new(service_config).await.unwrap());
(B[m[31m-        
(B[m[32m+        let service = Arc::new(
(B[m[32m+            HierarchicalMemoryService::new(service_config)
(B[m[32m+                .await
(B[m[32m+                .unwrap(),
(B[m[32m+        );
(B[m[32m+
(B[m         let manager = HierarchyManager::new(config, service).await;
         assert!(manager.is_ok());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:511:
     #[tokio::test]
     async fn test_node_depth_calculation() {
         let mut hierarchy = HashMap::new();
[31m-        
(B[m[32m+
(B[m         let mut root = HierarchyNode::new(MemoryScope::Global, MemoryLevel::Strategic);
         let mut child = HierarchyNode::new(MemoryScope::Global, MemoryLevel::Tactical);
         let mut grandchild = HierarchyNode::new(MemoryScope::Global, MemoryLevel::Operational);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:518:
[31m-        
(B[m[32m+
(B[m         child.parent_id = Some(root.id.clone());
         grandchild.parent_id = Some(child.id.clone());
[31m-        
(B[m[32m+
(B[m         hierarchy.insert(root.id.clone(), root.clone());
         hierarchy.insert(child.id.clone(), child.clone());
         hierarchy.insert(grandchild.id.clone(), grandchild.clone());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/hierarchy_manager.rs:525:
[31m-        
(B[m[32m+
(B[m         assert_eq!(root.calculate_depth(&hierarchy), 0);
         assert_eq!(child.calculate_depth(&hierarchy), 1);
         assert_eq!(grandchild.calculate_depth(&hierarchy), 2);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/history.rs:1:
 //! Memory history tracking and versioning
 
 use crate::types::Memory;
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/history.rs:80:
         Self {
             max_versions_per_memory: 50,
             max_history_age_seconds: 365 * 24 * 3600, // 1 year
[31m-            track_access_events: false, // Usually too noisy
(B[m[32m+            track_access_events: false,               // Usually too noisy
(B[m             compress_old_entries: true,
         }
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/history.rs:133:
             timestamp: chrono::Utc::now().timestamp(),
             change_type: ChangeType::ContentUpdated,
             change_description: change_description.or_else(|| {
[31m-                Some(format!("Content updated from '{}' to '{}'", 
(B[m[32m+                Some(format!(
(B[m[32m+                    "Content updated from '{}' to '{}'",
(B[m                     self.truncate_text(old_content, 50),
                     self.truncate_text(&memory.content, 50)
                 ))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/history.rs:145:
     }
 
     /// Record importance change
[31m-    pub fn record_importance_change(
(B[m[31m-        &mut self,
(B[m[31m-        memory: &Memory,
(B[m[31m-        old_importance: f32,
(B[m[31m-    ) -> Result<()> {
(B[m[32m+    pub fn record_importance_change(&mut self, memory: &Memory, old_importance: f32) -> Result<()> {
(B[m         let entry = MemoryHistoryEntry {
             memory_id: memory.id.clone(),
             version: memory.version,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/history.rs:182:
             metadata: memory.metadata.clone(),
             timestamp: chrono::Utc::now().timestamp(),
             change_type: ChangeType::MetadataUpdated,
[31m-            change_description: Some(format!(
(B[m[31m-                "Metadata updated: {}",
(B[m[31m-                changed_keys.join(", ")
(B[m[31m-            )),
(B[m[32m+            change_description: Some(format!("Metadata updated: {}", changed_keys.join(", "))),
(B[m         };
 
         self.add_history_entry(entry);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/history.rs:269:
     }
 
     /// Get changes between two versions
[31m-    pub fn get_version_diff(&self, memory_id: &str, from_version: u32, to_version: u32) -> Result<VersionDiff> {
(B[m[31m-        let history = self.history.get(memory_id)
(B[m[32m+    pub fn get_version_diff(
(B[m[32m+        &self,
(B[m[32m+        memory_id: &str,
(B[m[32m+        from_version: u32,
(B[m[32m+        to_version: u32,
(B[m[32m+    ) -> Result<VersionDiff> {
(B[m[32m+        let history = self
(B[m[32m+            .history
(B[m[32m+            .get(memory_id)
(B[m             .ok_or_else(|| AgentMemError::memory_error("Memory history not found"))?;
 
[31m-        let from_entry = history.iter()
(B[m[32m+        let from_entry = history
(B[m[32m+            .iter()
(B[m             .find(|entry| entry.version == from_version)
             .ok_or_else(|| AgentMemError::memory_error("From version not found"))?;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/history.rs:280:
[31m-        let to_entry = history.iter()
(B[m[32m+        let to_entry = history
(B[m[32m+            .iter()
(B[m             .find(|entry| entry.version == to_version)
             .ok_or_else(|| AgentMemError::memory_error("To version not found"))?;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/history.rs:322:
     /// Get history statistics
     pub fn get_history_stats(&self) -> HistoryStats {
         let mut stats = HistoryStats::default();
[31m-        
(B[m[32m+
(B[m         stats.total_memories_tracked = self.history.len();
[31m-        
(B[m[32m+
(B[m         for entries in self.history.values() {
             stats.total_history_entries += entries.len();
[31m-            
(B[m[32m+
(B[m             for entry in entries {
[31m-                *stats.changes_by_type.entry(entry.change_type.clone()).or_insert(0) += 1;
(B[m[32m+                *stats
(B[m[32m+                    .changes_by_type
(B[m[32m+                    .entry(entry.change_type.clone())
(B[m[32m+                    .or_insert(0) += 1;
(B[m             }
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/history.rs:336:
         if !self.history.is_empty() {
[31m-            stats.average_versions_per_memory = stats.total_history_entries as f32 / stats.total_memories_tracked as f32;
(B[m[32m+            stats.average_versions_per_memory =
(B[m[32m+                stats.total_history_entries as f32 / stats.total_memories_tracked as f32;
(B[m         }
 
         stats
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:1:
 //! Advanced Importance Scoring System
[31m-//! 
(B[m[32m+//!
(B[m //! Multi-dimensional importance scoring with dynamic weight adjustment
 //! and context-aware evaluation for memory prioritization.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:6:
 use crate::hierarchical_service::HierarchicalMemoryRecord;
 use crate::types::{ImportanceLevel, MemoryType};
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m[32m+use chrono::{DateTime, Duration, Timelike, Utc};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
[31m-use chrono::{DateTime, Utc, Duration, Timelike};
(B[m use uuid::Uuid;
 
 /// Configuration for importance scoring
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:148:
         let stats = self.get_or_create_stats(&memory.id).clone();
 
         // Calculate individual factor scores
[31m-        let recency_score = self.calculate_recency_score(memory, context, &stats).await?;
(B[m[31m-        let frequency_score = self.calculate_frequency_score(memory, context, &stats).await?;
(B[m[31m-        let relevance_score = self.calculate_relevance_score(memory, context, &stats).await?;
(B[m[31m-        let emotional_score = self.calculate_emotional_score(memory, context, &stats).await?;
(B[m[31m-        let context_score = self.calculate_context_score(memory, context, &stats).await?;
(B[m[31m-        let interaction_score = self.calculate_interaction_score(memory, context, &stats).await?;
(B[m[32m+        let recency_score = self
(B[m[32m+            .calculate_recency_score(memory, context, &stats)
(B[m[32m+            .await?;
(B[m[32m+        let frequency_score = self
(B[m[32m+            .calculate_frequency_score(memory, context, &stats)
(B[m[32m+            .await?;
(B[m[32m+        let relevance_score = self
(B[m[32m+            .calculate_relevance_score(memory, context, &stats)
(B[m[32m+            .await?;
(B[m[32m+        let emotional_score = self
(B[m[32m+            .calculate_emotional_score(memory, context, &stats)
(B[m[32m+            .await?;
(B[m[32m+        let context_score = self
(B[m[32m+            .calculate_context_score(memory, context, &stats)
(B[m[32m+            .await?;
(B[m[32m+        let interaction_score = self
(B[m[32m+            .calculate_interaction_score(memory, context, &stats)
(B[m[32m+            .await?;
(B[m 
         // Calculate composite score with current weights
         let composite_score = self.calculate_composite_score(
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:167:
 
         // Apply dynamic weight adjustment if enabled
         if self.config.enable_dynamic_weights {
[31m-            self.adjust_weights_based_on_performance(memory, composite_score).await?;
(B[m[32m+            self.adjust_weights_based_on_performance(memory, composite_score)
(B[m[32m+                .await?;
(B[m         }
 
         Ok(ImportanceFactors {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:189:
         context: &ScoringContext,
         stats: &MemoryUsageStats,
     ) -> Result<f64> {
[31m-        let time_since_access = context.current_time.signed_duration_since(stats.last_accessed);
(B[m[32m+        let time_since_access = context
(B[m[32m+            .current_time
(B[m[32m+            .signed_duration_since(stats.last_accessed);
(B[m         let hours_since_access = time_since_access.num_hours() as f64;
 
         // Exponential decay function
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:211:
         context: &ScoringContext,
         stats: &MemoryUsageStats,
     ) -> Result<f64> {
[31m-        let days_since_creation = context.current_time
(B[m[32m+        let days_since_creation = context
(B[m[32m+            .current_time
(B[m             .signed_duration_since(stats.creation_time)
             .num_days()
             .max(1) as f64;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:270:
 
         // Analyze emotional keywords in content
         let emotional_keywords = vec![
[31m-            ("important", 0.8), ("critical", 0.9), ("urgent", 0.7),
(B[m[31m-            ("love", 0.6), ("hate", 0.6), ("excited", 0.5),
(B[m[31m-            ("worried", 0.4), ("happy", 0.5), ("sad", 0.4),
(B[m[32m+            ("important", 0.8),
(B[m[32m+            ("critical", 0.9),
(B[m[32m+            ("urgent", 0.7),
(B[m[32m+            ("love", 0.6),
(B[m[32m+            ("hate", 0.6),
(B[m[32m+            ("excited", 0.5),
(B[m[32m+            ("worried", 0.4),
(B[m[32m+            ("happy", 0.5),
(B[m[32m+            ("sad", 0.4),
(B[m         ];
 
         let content_lower = memory.content.to_lowercase();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:322:
         // Time-based context (e.g., work hours, weekends)
         let hour = context.current_time.hour();
         let is_work_hours = hour >= 9 && hour <= 17;
[31m-        
(B[m[32m+
(B[m         if let Some(memory_context) = memory.metadata.get("context_type") {
             match memory_context.as_str() {
                 "work" if is_work_hours => context_score += 0.2,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:372:
         context: f64,
         interaction: f64,
     ) -> f64 {
[31m-        let weighted_score = 
(B[m[31m-            recency * self.config.recency_weight +
(B[m[31m-            frequency * self.config.frequency_weight +
(B[m[31m-            relevance * self.config.relevance_weight +
(B[m[31m-            emotional * self.config.emotional_weight +
(B[m[31m-            context * self.config.context_weight +
(B[m[31m-            interaction * self.config.interaction_weight;
(B[m[32m+        let weighted_score = recency * self.config.recency_weight
(B[m[32m+            + frequency * self.config.frequency_weight
(B[m[32m+            + relevance * self.config.relevance_weight
(B[m[32m+            + emotional * self.config.emotional_weight
(B[m[32m+            + context * self.config.context_weight
(B[m[32m+            + interaction * self.config.interaction_weight;
(B[m 
         // Apply bounds
         weighted_score
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:394:
     ) -> Result<()> {
         // This is a simplified version of dynamic weight adjustment
         // In a full implementation, this would use machine learning techniques
[31m-        
(B[m[32m+
(B[m         // Track performance metrics based on importance level instead of memory type
         let importance_key = format!("{:?}", memory.importance);
         self.performance_metrics.insert(importance_key, score);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:431:
 
     /// Normalize weights to sum to 1.0
     fn normalize_weights(&mut self) {
[31m-        let total_weight = self.config.recency_weight +
(B[m[31m-            self.config.frequency_weight +
(B[m[31m-            self.config.relevance_weight +
(B[m[31m-            self.config.emotional_weight +
(B[m[31m-            self.config.context_weight +
(B[m[31m-            self.config.interaction_weight;
(B[m[32m+        let total_weight = self.config.recency_weight
(B[m[32m+            + self.config.frequency_weight
(B[m[32m+            + self.config.relevance_weight
(B[m[32m+            + self.config.emotional_weight
(B[m[32m+            + self.config.context_weight
(B[m[32m+            + self.config.interaction_weight;
(B[m 
         if total_weight > 0.0 {
             self.config.recency_weight /= total_weight;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:452:
     fn calculate_text_similarity(&self, text1: &str, text2: &str) -> f64 {
         let words1: std::collections::HashSet<&str> = text1.split_whitespace().collect();
         let words2: std::collections::HashSet<&str> = text2.split_whitespace().collect();
[31m-        
(B[m[32m+
(B[m         let intersection = words1.intersection(&words2).count();
         let union = words1.union(&words2).count();
[31m-        
(B[m[32m+
(B[m         if union == 0 {
             0.0
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:465:
 
     /// Get or create usage statistics for a memory
     fn get_or_create_stats(&mut self, memory_id: &str) -> &mut MemoryUsageStats {
[31m-        self.usage_stats.entry(memory_id.to_string()).or_insert_with(MemoryUsageStats::default)
(B[m[32m+        self.usage_stats
(B[m[32m+            .entry(memory_id.to_string())
(B[m[32m+            .or_insert_with(MemoryUsageStats::default)
(B[m     }
 
     /// Update usage statistics for a memory
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:472:
     pub fn update_usage_stats(&mut self, memory_id: &str, access_type: AccessType) {
         let stats = self.get_or_create_stats(memory_id);
[31m-        
(B[m[32m+
(B[m         match access_type {
             AccessType::Read => {
                 stats.access_count += 1;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:518:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    use crate::hierarchy::{MemoryScope, MemoryLevel};
(B[m[32m+    use crate::hierarchy::{MemoryLevel, MemoryScope};
(B[m 
     fn create_test_memory() -> HierarchicalMemoryRecord {
         HierarchicalMemoryRecord {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:535:
             tags: Vec::new(),
             parent_memory_id: None,
             child_memory_ids: Vec::new(),
[31m-            conflict_resolution_strategy: crate::hierarchical_service::ConflictResolutionStrategy::ImportanceBased,
(B[m[32m+            conflict_resolution_strategy:
(B[m[32m+                crate::hierarchical_service::ConflictResolutionStrategy::ImportanceBased,
(B[m             quality_score: 1.0,
             source_reliability: 1.0,
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/importance_scorer.rs:555:
         let memory = create_test_memory();
         let context = ScoringContext::default();
 
[31m-        let factors = scorer.calculate_importance(&memory, &context).await.unwrap();
(B[m[31m-        
(B[m[32m+        let factors = scorer
(B[m[32m+            .calculate_importance(&memory, &context)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         assert!(factors.composite_score >= 0.0);
         assert!(factors.composite_score <= 10.0);
         assert!(factors.recency_score >= 0.0 && factors.recency_score <= 1.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lib.rs:1:
 //! # Agent Memory Core
[31m-//! 
(B[m[32m+//!
(B[m //! Core memory management for the AgentMem memory platform.
[31m-//! 
(B[m[32m+//!
(B[m //! This crate provides the core memory management functionality including:
 //! - Memory lifecycle management
 //! - Memory types and operations
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lib.rs:8:
 //! - CRUD operations for memories
 //! - History tracking and versioning
 
[31m-pub mod manager;
(B[m[31m-pub mod lifecycle;
(B[m[31m-pub mod types;
(B[m[31m-pub mod operations;
(B[m[31m-pub mod history;
(B[m[31m-pub mod hierarchy;
(B[m[31m-pub mod hierarchical_service;
(B[m[32m+pub mod adaptive_strategy;
(B[m pub mod conflict_resolver;
[31m-pub mod llm_optimizer;
(B[m[32m+pub mod context_aware_search;
(B[m[32m+pub mod hierarchical_service;
(B[m[32m+pub mod hierarchy;
(B[m pub mod hierarchy_manager;
[32m+pub mod history;
(B[m pub mod importance_scorer;
[31m-pub mod adaptive_strategy;
(B[m[31m-pub mod context_aware_search;
(B[m[31m-pub mod monitoring;
(B[m[32m+pub mod lifecycle;
(B[m[32m+pub mod llm_optimizer;
(B[m pub mod logging;
[32m+pub mod manager;
(B[m[32m+pub mod monitoring;
(B[m[32m+pub mod operations;
(B[m pub mod security;
[32m+pub mod types;
(B[m 
[31m-pub use manager::MemoryManager;
(B[m[31m-pub use lifecycle::MemoryLifecycle;
(B[m[31m-pub use types::*;
(B[m[31m-pub use operations::*;
(B[m[31m-pub use history::MemoryHistory;
(B[m[31m-pub use hierarchy::*;
(B[m[31m-pub use hierarchical_service::{
(B[m[31m-    HierarchicalMemoryService, HierarchicalMemoryRecord, HierarchicalServiceConfig,
(B[m[31m-    ConflictResolutionStrategy, MemoryInheritanceRule, InheritanceType,
(B[m[31m-    HierarchicalSearchFilters
(B[m[32m+pub use adaptive_strategy::{
(B[m[32m+    AdaptiveStrategyConfig, AdaptiveStrategyManager, MemoryStrategy, StrategyParameters,
(B[m[32m+    StrategyPerformance, StrategyRecommendation,
(B[m };
 pub use conflict_resolver::{
[31m-    ConflictResolver, ConflictResolverConfig, ConflictResolution, ConflictDetection, ConflictType
(B[m[32m+    ConflictDetection, ConflictResolution, ConflictResolver, ConflictResolverConfig, ConflictType,
(B[m };
[31m-pub use llm_optimizer::{
(B[m[31m-    LlmOptimizer, LlmOptimizationConfig, OptimizationStrategy, PromptTemplateType,
(B[m[31m-    PromptTemplate, OptimizedLlmResponse, LlmPerformanceMetrics, LlmProvider
(B[m[32m+pub use context_aware_search::{
(B[m[32m+    ContextAwareSearchConfig, ContextAwareSearchEngine, ContextualSearchQuery,
(B[m[32m+    ContextualSearchResult, ResultPreferences, SearchAnalytics, SearchStrategy,
(B[m };
[32m+pub use hierarchical_service::{
(B[m[32m+    ConflictResolutionStrategy, HierarchicalMemoryRecord, HierarchicalMemoryService,
(B[m[32m+    HierarchicalSearchFilters, HierarchicalServiceConfig, InheritanceType, MemoryInheritanceRule,
(B[m[32m+};
(B[m[32m+pub use hierarchy::*;
(B[m pub use hierarchy_manager::{
[31m-    HierarchyManager, HierarchyManagerConfig, HierarchyNode, HierarchyStatistics
(B[m[32m+    HierarchyManager, HierarchyManagerConfig, HierarchyNode, HierarchyStatistics,
(B[m };
[32m+pub use history::MemoryHistory;
(B[m pub use importance_scorer::{
[31m-    AdvancedImportanceScorer, ImportanceScorerConfig, ImportanceFactors,
(B[m[31m-    MemoryUsageStats, ScoringContext, AccessType
(B[m[32m+    AccessType, AdvancedImportanceScorer, ImportanceFactors, ImportanceScorerConfig,
(B[m[32m+    MemoryUsageStats, ScoringContext,
(B[m };
[31m-pub use adaptive_strategy::{
(B[m[31m-    AdaptiveStrategyManager, AdaptiveStrategyConfig, MemoryStrategy,
(B[m[31m-    StrategyPerformance, StrategyRecommendation, StrategyParameters
(B[m[32m+pub use lifecycle::MemoryLifecycle;
(B[m[32m+pub use llm_optimizer::{
(B[m[32m+    LlmOptimizationConfig, LlmOptimizer, LlmPerformanceMetrics, LlmProvider, OptimizationStrategy,
(B[m[32m+    OptimizedLlmResponse, PromptTemplate, PromptTemplateType,
(B[m };
[31m-pub use context_aware_search::{
(B[m[31m-    ContextAwareSearchEngine, ContextAwareSearchConfig, ContextualSearchQuery,
(B[m[31m-    SearchStrategy, ResultPreferences, ContextualSearchResult, SearchAnalytics
(B[m[32m+pub use logging::{
(B[m[32m+    AuditEntry, AuditEventType, AuditResult, ComplianceExport, LogEntry, LogLevel, LoggingConfig,
(B[m[32m+    LoggingSystem, SecurityEntry, SecurityEventType, SecuritySeverity,
(B[m };
[32m+pub use manager::MemoryManager;
(B[m pub use monitoring::{
[31m-    MonitoringSystem, MonitoringConfig, MetricPoint, MetricType, HealthStatus,
(B[m[31m-    ComponentStatus, AlertRule, AlertCondition, AlertSeverity, Alert, PerformanceProfile, SystemInfo
(B[m[32m+    Alert, AlertCondition, AlertRule, AlertSeverity, ComponentStatus, HealthStatus, MetricPoint,
(B[m[32m+    MetricType, MonitoringConfig, MonitoringSystem, PerformanceProfile, SystemInfo,
(B[m };
[31m-pub use logging::{
(B[m[31m-    LoggingSystem, LoggingConfig, LogLevel, LogEntry, AuditEntry, AuditEventType,
(B[m[31m-    AuditResult, SecurityEntry, SecurityEventType, SecuritySeverity, ComplianceExport
(B[m[31m-};
(B[m[32m+pub use operations::*;
(B[m pub use security::{
[31m-    SecuritySystem, SecurityConfig, Permission, Role, UserAccount, Session as SecuritySession,
(B[m[31m-    AccessControlEntry, ThreatRule, ThreatRuleType, ThreatSeverity, ThreatAction, ThreatIncident
(B[m[32m+    AccessControlEntry, Permission, Role, SecurityConfig, SecuritySystem,
(B[m[32m+    Session as SecuritySession, ThreatAction, ThreatIncident, ThreatRule, ThreatRuleType,
(B[m[32m+    ThreatSeverity, UserAccount,
(B[m };
[32m+pub use types::*;
(B[m 
 #[cfg(test)]
 mod tests {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lib.rs:76:
     use super::*;
[31m-    use agent_mem_traits::{Session, Message, MemoryProvider};
(B[m[32m+    use agent_mem_traits::{MemoryProvider, Message, Session};
(B[m     use tokio_test;
 
     #[tokio::test]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lib.rs:91:
             .with_user_id(Some("test-user".to_string()));
 
         // Test direct memory addition instead of using MemoryProvider trait
[31m-        let memory_id = manager.add_memory(
(B[m[31m-            "test-agent".to_string(),
(B[m[31m-            Some("test-user".to_string()),
(B[m[31m-            "I love playing tennis".to_string(),
(B[m[31m-            None,
(B[m[31m-            None,
(B[m[31m-            None,
(B[m[31m-        ).await.unwrap();
(B[m[32m+        let memory_id = manager
(B[m[32m+            .add_memory(
(B[m[32m+                "test-agent".to_string(),
(B[m[32m+                Some("test-user".to_string()),
(B[m[32m+                "I love playing tennis".to_string(),
(B[m[32m+                None,
(B[m[32m+                None,
(B[m[32m+                None,
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m 
         let retrieved = manager.get_memory(&memory_id).await.unwrap();
         assert!(retrieved.is_some());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lib.rs:110:
         let manager = MemoryManager::new();
 
         // Add some memories directly
[31m-        let _id1 = manager.add_memory(
(B[m[31m-            "test-agent".to_string(),
(B[m[31m-            None,
(B[m[31m-            "I love playing tennis".to_string(),
(B[m[31m-            None,
(B[m[31m-            None,
(B[m[31m-            None,
(B[m[31m-        ).await.unwrap();
(B[m[32m+        let _id1 = manager
(B[m[32m+            .add_memory(
(B[m[32m+                "test-agent".to_string(),
(B[m[32m+                None,
(B[m[32m+                "I love playing tennis".to_string(),
(B[m[32m+                None,
(B[m[32m+                None,
(B[m[32m+                None,
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m 
[31m-        let _id2 = manager.add_memory(
(B[m[31m-            "test-agent".to_string(),
(B[m[31m-            None,
(B[m[31m-            "I enjoy reading books".to_string(),
(B[m[31m-            None,
(B[m[31m-            None,
(B[m[31m-            None,
(B[m[31m-        ).await.unwrap();
(B[m[32m+        let _id2 = manager
(B[m[32m+            .add_memory(
(B[m[32m+                "test-agent".to_string(),
(B[m[32m+                None,
(B[m[32m+                "I enjoy reading books".to_string(),
(B[m[32m+                None,
(B[m[32m+                None,
(B[m[32m+                None,
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m 
[31m-        let _id3 = manager.add_memory(
(B[m[31m-            "test-agent".to_string(),
(B[m[31m-            None,
(B[m[31m-            "Tennis is my favorite sport".to_string(),
(B[m[31m-            None,
(B[m[31m-            None,
(B[m[31m-            None,
(B[m[31m-        ).await.unwrap();
(B[m[32m+        let _id3 = manager
(B[m[32m+            .add_memory(
(B[m[32m+                "test-agent".to_string(),
(B[m[32m+                None,
(B[m[32m+                "Tennis is my favorite sport".to_string(),
(B[m[32m+                None,
(B[m[32m+                None,
(B[m[32m+                None,
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m 
         // Search for tennis-related memories
         let query = crate::types::MemoryQuery::new("test-agent".to_string())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lib.rs:149:
     async fn test_update_memory() {
         let manager = MemoryManager::new();
 
[31m-        let memory_id = manager.add_memory(
(B[m[31m-            "test-agent".to_string(),
(B[m[31m-            None,
(B[m[31m-            "Original content".to_string(),
(B[m[31m-            None,
(B[m[31m-            None,
(B[m[31m-            None,
(B[m[31m-        ).await.unwrap();
(B[m[32m+        let memory_id = manager
(B[m[32m+            .add_memory(
(B[m[32m+                "test-agent".to_string(),
(B[m[32m+                None,
(B[m[32m+                "Original content".to_string(),
(B[m[32m+                None,
(B[m[32m+                None,
(B[m[32m+                None,
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m 
         // Update the memory
[31m-        manager.update_memory(
(B[m[31m-            &memory_id,
(B[m[31m-            Some("Updated content".to_string()),
(B[m[31m-            None,
(B[m[31m-            None,
(B[m[31m-        ).await.unwrap();
(B[m[32m+        manager
(B[m[32m+            .update_memory(&memory_id, Some("Updated content".to_string()), None, None)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m 
         // Verify the update
         let retrieved = manager.get_memory(&memory_id).await.unwrap();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lib.rs:176:
     async fn test_delete_memory() {
         let manager = MemoryManager::new();
 
[31m-        let memory_id = manager.add_memory(
(B[m[31m-            "test-agent".to_string(),
(B[m[31m-            None,
(B[m[31m-            "To be deleted".to_string(),
(B[m[31m-            None,
(B[m[31m-            None,
(B[m[31m-            None,
(B[m[31m-        ).await.unwrap();
(B[m[32m+        let memory_id = manager
(B[m[32m+            .add_memory(
(B[m[32m+                "test-agent".to_string(),
(B[m[32m+                None,
(B[m[32m+                "To be deleted".to_string(),
(B[m[32m+                None,
(B[m[32m+                None,
(B[m[32m+                None,
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m 
         // Delete the memory
         manager.delete_memory(&memory_id).await.unwrap();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:1:
 //! Memory lifecycle management
 
[31m-use crate::types::{Memory, MemoryType, ImportanceLevel};
(B[m[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use crate::types::{ImportanceLevel, Memory, MemoryType};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use std::collections::HashMap;
 
 /// Memory lifecycle states
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:99:
 
     /// Register a new memory
     pub fn register_memory(&mut self, memory: &Memory) -> Result<()> {
[31m-        self.memory_states.insert(memory.id.clone(), MemoryState::Created);
(B[m[31m-        
(B[m[32m+        self.memory_states
(B[m[32m+            .insert(memory.id.clone(), MemoryState::Created);
(B[m[32m+
(B[m         let event = LifecycleEvent {
             memory_id: memory.id.clone(),
             event_type: LifecycleEventType::Created,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:107:
             timestamp: chrono::Utc::now().timestamp(),
             metadata: HashMap::new(),
         };
[31m-        
(B[m[32m+
(B[m         self.add_event(event);
[31m-        
(B[m[32m+
(B[m         // Set expiration for working memories
         if memory.memory_type == MemoryType::Working && memory.expires_at.is_none() {
             let expiration = chrono::Utc::now().timestamp() + self.config.working_memory_ttl;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:116:
             self.set_expiration(&memory.id, expiration)?;
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:131:
         if let Some(state) = self.memory_states.get_mut(memory_id) {
             if *state == MemoryState::Archived {
                 *state = MemoryState::Active;
[31m-                
(B[m[32m+
(B[m                 let event = LifecycleEvent {
                     memory_id: memory_id.to_string(),
                     event_type: LifecycleEventType::Restored,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:148:
             timestamp: chrono::Utc::now().timestamp(),
             metadata: HashMap::new(),
         };
[31m-        
(B[m[32m+
(B[m         self.add_event(event);
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:155:
 
     /// Record memory update
[31m-    pub fn record_update(&mut self, memory_id: &str, old_version: u32, new_version: u32) -> Result<()> {
(B[m[32m+    pub fn record_update(
(B[m[32m+        &mut self,
(B[m[32m+        memory_id: &str,
(B[m[32m+        old_version: u32,
(B[m[32m+        new_version: u32,
(B[m[32m+    ) -> Result<()> {
(B[m         let mut metadata = HashMap::new();
         metadata.insert("old_version".to_string(), old_version.to_string());
         metadata.insert("new_version".to_string(), new_version.to_string());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:165:
             timestamp: chrono::Utc::now().timestamp(),
             metadata,
         };
[31m-        
(B[m[32m+
(B[m         self.add_event(event);
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:187:
             timestamp: chrono::Utc::now().timestamp(),
             metadata: HashMap::new(),
         };
[31m-        
(B[m[32m+
(B[m         self.add_event(event);
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:209:
             timestamp: chrono::Utc::now().timestamp(),
             metadata: HashMap::new(),
         };
[31m-        
(B[m[32m+
(B[m         self.add_event(event);
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:231:
             timestamp: chrono::Utc::now().timestamp(),
             metadata: HashMap::new(),
         };
[31m-        
(B[m[32m+
(B[m         self.add_event(event);
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:250:
             timestamp: chrono::Utc::now().timestamp(),
             metadata: HashMap::new(),
         };
[31m-        
(B[m[32m+
(B[m         self.add_event(event);
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:266:
             timestamp: chrono::Utc::now().timestamp(),
             metadata,
         };
[31m-        
(B[m[32m+
(B[m         self.add_event(event);
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:287:
 
     /// Get lifecycle events for a memory
     pub fn get_memory_events(&self, memory_id: &str) -> Vec<&LifecycleEvent> {
[31m-        self.events.iter()
(B[m[32m+        self.events
(B[m[32m+            .iter()
(B[m             .filter(|event| event.memory_id == memory_id)
             .collect()
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:308:
 
             // Auto-delete policy
             if let Some(delete_age) = self.config.auto_delete_age {
[31m-                if age > delete_age && current_importance < self.config.delete_importance_threshold {
(B[m[32m+                if age > delete_age && current_importance < self.config.delete_importance_threshold
(B[m[32m+                {
(B[m                     self.delete_memory(&memory.id)?;
                     affected_memories.push(memory.id.clone());
                     continue;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:317:
 
             // Auto-archive policy
             if let Some(archive_age) = self.config.auto_archive_age {
[31m-                if age > archive_age && current_importance < self.config.archive_importance_threshold {
(B[m[32m+                if age > archive_age
(B[m[32m+                    && current_importance < self.config.archive_importance_threshold
(B[m[32m+                {
(B[m                     if let Some(state) = self.memory_states.get(&memory.id) {
                         if *state == MemoryState::Active || *state == MemoryState::Created {
                             self.archive_memory(&memory.id)?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:334:
     /// Add an event to the history
     fn add_event(&mut self, event: LifecycleEvent) {
         self.events.push(event);
[31m-        
(B[m[32m+
(B[m         // Trim events if we exceed the maximum
         if self.events.len() > self.config.max_events_history {
             let excess = self.events.len() - self.config.max_events_history;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:345:
     /// Get statistics about lifecycle events
     pub fn get_lifecycle_stats(&self) -> HashMap<LifecycleEventType, usize> {
         let mut stats = HashMap::new();
[31m-        
(B[m[32m+
(B[m         for event in &self.events {
             *stats.entry(event.event_type.clone()).or_insert(0) += 1;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/lifecycle.rs:352:
[31m-        
(B[m[32m+
(B[m         stats
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:1:
 //! LLM Optimization Engine
[31m-//! 
(B[m[32m+//!
(B[m //! Advanced LLM optimization techniques ported from ContextEngine
 //! including prompt optimization, caching, and cost control.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m[32m+use chrono::{DateTime, Utc};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::time::{Duration, Instant};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:10:
[31m-use chrono::{DateTime, Utc};
(B[m 
 /// LLM optimization configuration
 #[derive(Debug, Clone, Serialize, Deserialize)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:185:
         // Calculate metrics
         let token_count = self.estimate_token_count(&response);
         let cost = self.calculate_cost(token_count);
[31m-        let quality_score = self.evaluate_response_quality(&response, &template_type).await?;
(B[m[32m+        let quality_score = self
(B[m[32m+            .evaluate_response_quality(&response, &template_type)
(B[m[32m+            .await?;
(B[m 
         let optimized_response = OptimizedLlmResponse {
             content: response,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:202:
         // Cache response if enabled
         if self.config.enable_caching {
             let cache_key = self.generate_cache_key(&optimized_prompt);
[31m-            self.response_cache.insert(cache_key, (optimized_response.clone(), Utc::now()));
(B[m[32m+            self.response_cache
(B[m[32m+                .insert(cache_key, (optimized_response.clone(), Utc::now()));
(B[m         }
 
         // Update metrics
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:217:
         template_type: &PromptTemplateType,
         variables: &HashMap<String, String>,
     ) -> Result<String> {
[31m-        let template = self.prompt_templates.get(template_type)
(B[m[31m-            .ok_or_else(|| AgentMemError::memory_error(&format!("Template not found: {:?}", template_type)))?;
(B[m[32m+        let template = self.prompt_templates.get(template_type).ok_or_else(|| {
(B[m[32m+            AgentMemError::memory_error(&format!("Template not found: {:?}", template_type))
(B[m[32m+        })?;
(B[m 
         let mut prompt = template.template.clone();
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:240:
     }
 
     /// Apply optimization strategy to prompt
[31m-    fn apply_optimization_strategy(&self, prompt: String, template_type: &PromptTemplateType) -> String {
(B[m[32m+    fn apply_optimization_strategy(
(B[m[32m+        &self,
(B[m[32m+        prompt: String,
(B[m[32m+        template_type: &PromptTemplateType,
(B[m[32m+    ) -> String {
(B[m         match self.config.strategy {
             OptimizationStrategy::CostEfficient => self.compress_prompt(prompt),
             OptimizationStrategy::QualityFocused => self.enhance_prompt(prompt, template_type),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:257:
             .replace("could you", "")
             .replace("I would like you to", "")
             .replace("  ", " ");
[31m-        
(B[m[32m+
(B[m         format!("Concise: {}", compressed.trim())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:264:
     /// Enhance prompt for quality
     fn enhance_prompt(&self, prompt: String, template_type: &PromptTemplateType) -> String {
         let enhancement = match template_type {
[31m-            PromptTemplateType::MemoryExtraction => "Be precise and extract all relevant information.",
(B[m[32m+            PromptTemplateType::MemoryExtraction => {
(B[m[32m+                "Be precise and extract all relevant information."
(B[m[32m+            }
(B[m             PromptTemplateType::MemorySearch => "Provide comprehensive and relevant results.",
[31m-            PromptTemplateType::MemoryConflictResolution => "Analyze carefully and resolve logically.",
(B[m[32m+            PromptTemplateType::MemoryConflictResolution => {
(B[m[32m+                "Analyze carefully and resolve logically."
(B[m[32m+            }
(B[m             _ => "Provide accurate and detailed response.",
         };
[31m-        
(B[m[32m+
(B[m         format!("{}\n\nInstructions: {}", prompt, enhancement)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:359:
         let mut optimizations = Vec::new();
 
         match self.config.strategy {
[31m-            OptimizationStrategy::CostEfficient => optimizations.push("cost_compression".to_string()),
(B[m[31m-            OptimizationStrategy::QualityFocused => optimizations.push("quality_enhancement".to_string()),
(B[m[31m-            OptimizationStrategy::SpeedOptimized => optimizations.push("speed_simplification".to_string()),
(B[m[31m-            OptimizationStrategy::Balanced => optimizations.push("balanced_optimization".to_string()),
(B[m[32m+            OptimizationStrategy::CostEfficient => {
(B[m[32m+                optimizations.push("cost_compression".to_string())
(B[m[32m+            }
(B[m[32m+            OptimizationStrategy::QualityFocused => {
(B[m[32m+                optimizations.push("quality_enhancement".to_string())
(B[m[32m+            }
(B[m[32m+            OptimizationStrategy::SpeedOptimized => {
(B[m[32m+                optimizations.push("speed_simplification".to_string())
(B[m[32m+            }
(B[m[32m+            OptimizationStrategy::Balanced => {
(B[m[32m+                optimizations.push("balanced_optimization".to_string())
(B[m[32m+            }
(B[m         }
 
         if self.config.enable_prompt_optimization {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:373:
     }
 
     /// Update performance metrics
[31m-    fn update_performance_metrics(&mut self, response: &OptimizedLlmResponse, template_type: &PromptTemplateType) {
(B[m[32m+    fn update_performance_metrics(
(B[m[32m+        &mut self,
(B[m[32m+        response: &OptimizedLlmResponse,
(B[m[32m+        template_type: &PromptTemplateType,
(B[m[32m+    ) {
(B[m         // Update averages
         let total = self.performance_metrics.total_requests as f64;
         self.performance_metrics.average_response_time = Duration::from_millis(
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:380:
[31m-            ((self.performance_metrics.average_response_time.as_millis() as f64 * (total - 1.0) + 
(B[m[31m-              response.response_time.as_millis() as f64) / total) as u64
(B[m[32m+            ((self.performance_metrics.average_response_time.as_millis() as f64 * (total - 1.0)
(B[m[32m+                + response.response_time.as_millis() as f64)
(B[m[32m+                / total) as u64,
(B[m         );
 
         self.performance_metrics.total_cost += response.cost;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:385:
[31m-        
(B[m[32m+
(B[m         self.quality_history.push(response.quality_score);
         self.cost_history.push(response.cost);
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:395:
         }
 
         // Update average quality score
[31m-        self.performance_metrics.average_quality_score = 
(B[m[32m+        self.performance_metrics.average_quality_score =
(B[m             self.quality_history.iter().sum::<f64>() / self.quality_history.len() as f64;
 
         // Update template usage
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:402:
[31m-        *self.performance_metrics.template_usage.entry(template_type.clone()).or_insert(0) += 1;
(B[m[32m+        *self
(B[m[32m+            .performance_metrics
(B[m[32m+            .template_usage
(B[m[32m+            .entry(template_type.clone())
(B[m[32m+            .or_insert(0) += 1;
(B[m 
         // Update optimization success rate
[31m-        let successful_optimizations = self.quality_history.iter()
(B[m[32m+        let successful_optimizations = self
(B[m[32m+            .quality_history
(B[m[32m+            .iter()
(B[m             .filter(|&&score| score >= self.config.quality_threshold)
             .count();
[31m-        self.performance_metrics.optimization_success_rate = 
(B[m[32m+        self.performance_metrics.optimization_success_rate =
(B[m             successful_optimizations as f64 / self.quality_history.len() as f64;
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:499:
         let mut variables = HashMap::new();
         variables.insert("text".to_string(), "Test memory content".to_string());
 
[31m-        let response = optimizer.optimize_request(
(B[m[31m-            PromptTemplateType::MemoryExtraction,
(B[m[31m-            variables,
(B[m[31m-            &provider,
(B[m[31m-        ).await;
(B[m[32m+        let response = optimizer
(B[m[32m+            .optimize_request(PromptTemplateType::MemoryExtraction, variables, &provider)
(B[m[32m+            .await;
(B[m 
         assert!(response.is_ok());
         let response = response.unwrap();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/llm_optimizer.rs:523:
         variables.insert("text".to_string(), "Test memory content".to_string());
 
         // First request
[31m-        let response1 = optimizer.optimize_request(
(B[m[31m-            PromptTemplateType::MemoryExtraction,
(B[m[31m-            variables.clone(),
(B[m[31m-            &provider,
(B[m[31m-        ).await.unwrap();
(B[m[32m+        let response1 = optimizer
(B[m[32m+            .optimize_request(
(B[m[32m+                PromptTemplateType::MemoryExtraction,
(B[m[32m+                variables.clone(),
(B[m[32m+                &provider,
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m 
         // Second request (should be cached)
[31m-        let response2 = optimizer.optimize_request(
(B[m[31m-            PromptTemplateType::MemoryExtraction,
(B[m[31m-            variables,
(B[m[31m-            &provider,
(B[m[31m-        ).await.unwrap();
(B[m[32m+        let response2 = optimizer
(B[m[32m+            .optimize_request(PromptTemplateType::MemoryExtraction, variables, &provider)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m 
         assert_eq!(response1.content, response2.content);
         // Note: The second response should be cached, but our simple test might not trigger it
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:1:
 //! Production Logging and Audit System
[31m-//! 
(B[m[32m+//!
(B[m //! Comprehensive logging, audit trails, and security monitoring for production
 //! environments with structured logging and compliance support.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m[32m+use chrono::{DateTime, Utc};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::{HashMap, VecDeque};
 use std::sync::Arc;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:10:
 use tokio::sync::RwLock;
[31m-use chrono::{DateTime, Utc};
(B[m use uuid::Uuid;
 
 /// Logging system configuration
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:242:
             None,
             HashMap::new(),
             Vec::new(),
[31m-        ).await
(B[m[32m+        )
(B[m[32m+        .await
(B[m     }
 
     /// Log a warning message
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:257:
             None,
             HashMap::new(),
             Vec::new(),
[31m-        ).await
(B[m[32m+        )
(B[m[32m+        .await
(B[m     }
 
     /// Log an error message
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:264:
[31m-    pub async fn error(&self, message: &str, component: &str, error: Option<&dyn std::error::Error>) -> Result<()> {
(B[m[32m+    pub async fn error(
(B[m[32m+        &self,
(B[m[32m+        message: &str,
(B[m[32m+        component: &str,
(B[m[32m+        error: Option<&dyn std::error::Error>,
(B[m[32m+    ) -> Result<()> {
(B[m         let mut fields = HashMap::new();
         if let Some(err) = error {
[31m-            fields.insert("error".to_string(), serde_json::Value::String(err.to_string()));
(B[m[32m+            fields.insert(
(B[m[32m+                "error".to_string(),
(B[m[32m+                serde_json::Value::String(err.to_string()),
(B[m[32m+            );
(B[m         }
 
         self.log(
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:277:
             None,
             fields,
             vec!["error".to_string()],
[31m-        ).await
(B[m[32m+        )
(B[m[32m+        .await
(B[m     }
 
     /// Log an audit event
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:400:
     /// Get log entries with optional filtering
     pub async fn get_logs(&self, filter: Option<&LogFilter>) -> Vec<LogEntry> {
         let log_entries = self.log_entries.read().await;
[31m-        
(B[m[32m+
(B[m         if let Some(filter) = filter {
             log_entries
                 .iter()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:487:
 
     /// Clean up old logs
     pub async fn cleanup_old_logs(&self) -> Result<()> {
[31m-        let cutoff_time = Utc::now() - chrono::Duration::days(self.config.log_retention_days as i64);
(B[m[32m+        let cutoff_time =
(B[m[32m+            Utc::now() - chrono::Duration::days(self.config.log_retention_days as i64);
(B[m 
         // Clean up old log entries
         {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:570:
     async fn test_logging_system_creation() {
         let config = LoggingConfig::default();
         let logging = LoggingSystem::new(config);
[31m-        
(B[m[31m-        logging.info("Test message", "test_component").await.unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        logging
(B[m[32m+            .info("Test message", "test_component")
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         let logs = logging.get_logs(None).await;
         assert_eq!(logs.len(), 1);
         assert_eq!(logs[0].message, "Test message");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:582:
     async fn test_audit_logging() {
         let config = LoggingConfig::default();
         let logging = LoggingSystem::new(config);
[31m-        
(B[m[32m+
(B[m         let mut details = HashMap::new();
[31m-        details.insert("memory_id".to_string(), serde_json::Value::String("test-123".to_string()));
(B[m[31m-        
(B[m[31m-        logging.audit(
(B[m[31m-            AuditEventType::MemoryCreated,
(B[m[31m-            Some("user123".to_string()),
(B[m[31m-            Some("session456".to_string()),
(B[m[31m-            Some("memory789".to_string()),
(B[m[31m-            Some("memory".to_string()),
(B[m[31m-            "create_memory".to_string(),
(B[m[31m-            AuditResult::Success,
(B[m[31m-            Some("192.168.1.1".to_string()),
(B[m[31m-            Some("Mozilla/5.0".to_string()),
(B[m[31m-            details,
(B[m[31m-        ).await.unwrap();
(B[m[31m-        
(B[m[32m+        details.insert(
(B[m[32m+            "memory_id".to_string(),
(B[m[32m+            serde_json::Value::String("test-123".to_string()),
(B[m[32m+        );
(B[m[32m+
(B[m[32m+        logging
(B[m[32m+            .audit(
(B[m[32m+                AuditEventType::MemoryCreated,
(B[m[32m+                Some("user123".to_string()),
(B[m[32m+                Some("session456".to_string()),
(B[m[32m+                Some("memory789".to_string()),
(B[m[32m+                Some("memory".to_string()),
(B[m[32m+                "create_memory".to_string(),
(B[m[32m+                AuditResult::Success,
(B[m[32m+                Some("192.168.1.1".to_string()),
(B[m[32m+                Some("Mozilla/5.0".to_string()),
(B[m[32m+                details,
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         let audit_logs = logging.get_audit_logs().await;
         assert_eq!(audit_logs.len(), 1);
         assert_eq!(audit_logs[0].action, "create_memory");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:609:
     async fn test_security_logging() {
         let config = LoggingConfig::default();
         let logging = LoggingSystem::new(config);
[31m-        
(B[m[31m-        logging.security(
(B[m[31m-            SecurityEventType::AuthenticationFailure,
(B[m[31m-            SecuritySeverity::High,
(B[m[31m-            Some("192.168.1.100".to_string()),
(B[m[31m-            Some("attacker".to_string()),
(B[m[31m-            None,
(B[m[31m-            "Multiple failed login attempts".to_string(),
(B[m[31m-            vec!["brute_force".to_string(), "suspicious_ip".to_string()],
(B[m[31m-            vec!["ip_blocked".to_string(), "user_notified".to_string()],
(B[m[31m-            HashMap::new(),
(B[m[31m-        ).await.unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        logging
(B[m[32m+            .security(
(B[m[32m+                SecurityEventType::AuthenticationFailure,
(B[m[32m+                SecuritySeverity::High,
(B[m[32m+                Some("192.168.1.100".to_string()),
(B[m[32m+                Some("attacker".to_string()),
(B[m[32m+                None,
(B[m[32m+                "Multiple failed login attempts".to_string(),
(B[m[32m+                vec!["brute_force".to_string(), "suspicious_ip".to_string()],
(B[m[32m+                vec!["ip_blocked".to_string(), "user_notified".to_string()],
(B[m[32m+                HashMap::new(),
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         let security_logs = logging.get_security_logs().await;
         assert_eq!(security_logs.len(), 1);
         assert_eq!(security_logs[0].severity, SecuritySeverity::High);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:628:
[31m-        
(B[m[32m+
(B[m         let critical_events = logging.get_critical_security_events().await;
         assert_eq!(critical_events.len(), 1);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/logging.rs:634:
     async fn test_risk_score_calculation() {
         let config = LoggingConfig::default();
         let logging = LoggingSystem::new(config);
[31m-        
(B[m[31m-        let score1 = logging.calculate_risk_score(&AuditEventType::MemoryAccessed, &AuditResult::Success);
(B[m[31m-        let score2 = logging.calculate_risk_score(&AuditEventType::SecurityViolation, &AuditResult::Denied);
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let score1 =
(B[m[32m+            logging.calculate_risk_score(&AuditEventType::MemoryAccessed, &AuditResult::Success);
(B[m[32m+        let score2 =
(B[m[32m+            logging.calculate_risk_score(&AuditEventType::SecurityViolation, &AuditResult::Denied);
(B[m[32m+
(B[m         assert!(score1 < score2);
         assert!(score2 > 90);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/manager.rs:1:
 //! Core memory manager implementation
 
 use crate::{
[32m+    history::{HistoryConfig, MemoryHistory},
(B[m[32m+    lifecycle::{LifecycleConfig, MemoryLifecycle},
(B[m[32m+    operations::{InMemoryOperations, MemoryOperations},
(B[m     types::{Memory, MemoryQuery, MemorySearchResult, MemoryStats, MemoryType},
[31m-    operations::{MemoryOperations, InMemoryOperations},
(B[m[31m-    lifecycle::{MemoryLifecycle, LifecycleConfig},
(B[m[31m-    history::{MemoryHistory, HistoryConfig},
(B[m };
[32m+use agent_mem_config::MemoryConfig;
(B[m use agent_mem_traits::{
[31m-    MemoryProvider, Result, AgentMemError, MemoryItem, Session, Message, HistoryEntry, MemoryEvent
(B[m[32m+    AgentMemError, HistoryEntry, MemoryEvent, MemoryItem, MemoryProvider, Message, Result, Session,
(B[m };
[31m-use agent_mem_config::MemoryConfig;
(B[m use std::sync::Arc;
 use tokio::sync::RwLock;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/manager.rs:33:
 
     /// Create a new memory manager with custom configuration
     pub fn with_config(config: MemoryConfig) -> Self {
[31m-        let operations: Box<dyn MemoryOperations + Send + Sync> = Box::new(InMemoryOperations::new());
(B[m[32m+        let operations: Box<dyn MemoryOperations + Send + Sync> =
(B[m[32m+            Box::new(InMemoryOperations::new());
(B[m         let lifecycle = MemoryLifecycle::with_default_config();
         let history = MemoryHistory::with_default_config();
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/manager.rs:51:
         lifecycle_config: LifecycleConfig,
         history_config: HistoryConfig,
     ) -> Self {
[31m-        let operations: Box<dyn MemoryOperations + Send + Sync> = Box::new(InMemoryOperations::new());
(B[m[32m+        let operations: Box<dyn MemoryOperations + Send + Sync> =
(B[m[32m+            Box::new(InMemoryOperations::new());
(B[m         let lifecycle = MemoryLifecycle::new(lifecycle_config);
         let history = MemoryHistory::new(history_config);
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/manager.rs:155:
         new_metadata: Option<std::collections::HashMap<String, String>>,
     ) -> Result<()> {
         let operations = self.operations.read().await;
[31m-        let mut memory = operations.get_memory(memory_id).await?
(B[m[32m+        let mut memory = operations
(B[m[32m+            .get_memory(memory_id)
(B[m[32m+            .await?
(B[m             .ok_or_else(|| AgentMemError::memory_error("Memory not found"))?;
 
         let old_content = memory.content.clone();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/manager.rs:180:
         // Record changes in history
         {
             let mut history = self.history.write().await;
[31m-            
(B[m[32m+
(B[m             if memory.content != old_content {
                 history.record_content_update(&memory, &old_content, None)?;
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/manager.rs:187:
[31m-            
(B[m[32m+
(B[m             if memory.importance != old_importance {
                 history.record_importance_change(&memory, old_importance)?;
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/manager.rs:222:
     }
 
     /// Get all memories for an agent
[31m-    pub async fn get_agent_memories(&self, agent_id: &str, limit: Option<usize>) -> Result<Vec<Memory>> {
(B[m[32m+    pub async fn get_agent_memories(
(B[m[32m+        &self,
(B[m[32m+        agent_id: &str,
(B[m[32m+        limit: Option<usize>,
(B[m[32m+    ) -> Result<Vec<Memory>> {
(B[m         let operations = self.operations.read().await;
         operations.get_agent_memories(agent_id, limit).await
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/manager.rs:229:
 
     /// Get memories by type
[31m-    pub async fn get_memories_by_type(&self, agent_id: &str, memory_type: MemoryType) -> Result<Vec<Memory>> {
(B[m[32m+    pub async fn get_memories_by_type(
(B[m[32m+        &self,
(B[m[32m+        agent_id: &str,
(B[m[32m+        memory_type: MemoryType,
(B[m[32m+    ) -> Result<Vec<Memory>> {
(B[m         let operations = self.operations.read().await;
         operations.get_memories_by_type(agent_id, memory_type).await
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/manager.rs:280:
         let mut results = Vec::new();
 
         for message in messages {
[31m-            let memory_id = self.add_memory(
(B[m[31m-                session.agent_id.clone().unwrap_or_else(|| "default".to_string()),
(B[m[31m-                session.user_id.clone(),
(B[m[31m-                message.content.clone(),
(B[m[31m-                None, // Use default memory type
(B[m[31m-                None, // Use default importance
(B[m[31m-                None, // No additional metadata
(B[m[31m-            ).await?;
(B[m[32m+            let memory_id = self
(B[m[32m+                .add_memory(
(B[m[32m+                    session
(B[m[32m+                        .agent_id
(B[m[32m+                        .clone()
(B[m[32m+                        .unwrap_or_else(|| "default".to_string()),
(B[m[32m+                    session.user_id.clone(),
(B[m[32m+                    message.content.clone(),
(B[m[32m+                    None, // Use default memory type
(B[m[32m+                    None, // Use default importance
(B[m[32m+                    None, // No additional metadata
(B[m[32m+                )
(B[m[32m+                .await?;
(B[m 
             if let Some(memory) = self.get_memory(&memory_id).await? {
                 results.push(memory.into());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/manager.rs:302:
         Ok(memory.map(|m| m.into()))
     }
 
[31m-    async fn search(&self, query: &str, session: &Session, limit: usize) -> Result<Vec<MemoryItem>> {
(B[m[32m+    async fn search(
(B[m[32m+        &self,
(B[m[32m+        query: &str,
(B[m[32m+        session: &Session,
(B[m[32m+        limit: usize,
(B[m[32m+    ) -> Result<Vec<MemoryItem>> {
(B[m         let mut memory_query = MemoryQuery::new(
[31m-            session.agent_id.clone().unwrap_or_else(|| "default".to_string())
(B[m[32m+            session
(B[m[32m+                .agent_id
(B[m[32m+                .clone()
(B[m[32m+                .unwrap_or_else(|| "default".to_string()),
(B[m         )
         .with_text_query(query.to_string())
         .with_limit(limit);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/manager.rs:323:
             Some(data.to_string()),
             None, // Don't update importance through this interface
             None, // No metadata updates
[31m-        ).await
(B[m[32m+        )
(B[m[32m+        .await
(B[m     }
 
     async fn delete(&self, memory_id: &str) -> Result<()> {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/manager.rs:339:
                 .map(|entry| {
                     let event = match entry.change_type {
                         crate::history::ChangeType::Created => MemoryEvent::Create,
[31m-                        crate::history::ChangeType::ContentUpdated |
(B[m[31m-                        crate::history::ChangeType::ImportanceChanged |
(B[m[31m-                        crate::history::ChangeType::MetadataUpdated => MemoryEvent::Update,
(B[m[32m+                        crate::history::ChangeType::ContentUpdated
(B[m[32m+                        | crate::history::ChangeType::ImportanceChanged
(B[m[32m+                        | crate::history::ChangeType::MetadataUpdated => MemoryEvent::Update,
(B[m                         crate::history::ChangeType::Deprecated => MemoryEvent::Delete,
                         _ => MemoryEvent::Update,
                     };
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/manager.rs:350:
                         id: format!("{}_{}", entry.memory_id, entry.version),
                         memory_id: entry.memory_id.clone(),
                         event,
[31m-                        timestamp: chrono::DateTime::from_timestamp(entry.timestamp, 0).unwrap_or_else(|| chrono::Utc::now()),
(B[m[32m+                        timestamp: chrono::DateTime::from_timestamp(entry.timestamp, 0)
(B[m[32m+                            .unwrap_or_else(|| chrono::Utc::now()),
(B[m                         data: Some(serde_json::json!({
                             "content": entry.content,
                             "change_type": entry.change_type.to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:1:
 //! Production Monitoring and Telemetry System
[31m-//! 
(B[m[32m+//!
(B[m //! Comprehensive monitoring, metrics collection, and telemetry for production
 //! environments with support for alerts, dashboards, and observability.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m[32m+use chrono::{DateTime, Duration, Utc};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::{HashMap, VecDeque};
 use std::sync::Arc;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:10:
 use tokio::sync::RwLock;
[31m-use chrono::{DateTime, Utc, Duration};
(B[m use uuid::Uuid;
 
 /// Monitoring system configuration
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:226:
     }
 
     /// Record a counter metric
[31m-    pub async fn increment_counter(&self, name: &str, labels: HashMap<String, String>) -> Result<()> {
(B[m[31m-        self.record_metric(name.to_string(), 1.0, MetricType::Counter, labels).await
(B[m[32m+    pub async fn increment_counter(
(B[m[32m+        &self,
(B[m[32m+        name: &str,
(B[m[32m+        labels: HashMap<String, String>,
(B[m[32m+    ) -> Result<()> {
(B[m[32m+        self.record_metric(name.to_string(), 1.0, MetricType::Counter, labels)
(B[m[32m+            .await
(B[m     }
 
     /// Record a gauge metric
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:234:
[31m-    pub async fn set_gauge(&self, name: &str, value: f64, labels: HashMap<String, String>) -> Result<()> {
(B[m[31m-        self.record_metric(name.to_string(), value, MetricType::Gauge, labels).await
(B[m[32m+    pub async fn set_gauge(
(B[m[32m+        &self,
(B[m[32m+        name: &str,
(B[m[32m+        value: f64,
(B[m[32m+        labels: HashMap<String, String>,
(B[m[32m+    ) -> Result<()> {
(B[m[32m+        self.record_metric(name.to_string(), value, MetricType::Gauge, labels)
(B[m[32m+            .await
(B[m     }
 
     /// Record a histogram metric
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:239:
[31m-    pub async fn record_histogram(&self, name: &str, value: f64, labels: HashMap<String, String>) -> Result<()> {
(B[m[31m-        self.record_metric(name.to_string(), value, MetricType::Histogram, labels).await
(B[m[32m+    pub async fn record_histogram(
(B[m[32m+        &self,
(B[m[32m+        name: &str,
(B[m[32m+        value: f64,
(B[m[32m+        labels: HashMap<String, String>,
(B[m[32m+    ) -> Result<()> {
(B[m[32m+        self.record_metric(name.to_string(), value, MetricType::Histogram, labels)
(B[m[32m+            .await
(B[m     }
 
     /// Update health check status
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:290:
             let recent_metrics: Vec<_> = metrics
                 .iter()
                 .filter(|m| {
[31m-                    m.name == rule.metric_name &&
(B[m[31m-                    Utc::now().signed_duration_since(m.timestamp).num_seconds() <= rule.duration_seconds as i64
(B[m[32m+                    m.name == rule.metric_name
(B[m[32m+                        && Utc::now().signed_duration_since(m.timestamp).num_seconds()
(B[m[32m+                            <= rule.duration_seconds as i64
(B[m                 })
                 .collect();
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:300:
             }
 
             // Calculate aggregate value (average for simplicity)
[31m-            let avg_value = recent_metrics.iter().map(|m| m.value).sum::<f64>() / recent_metrics.len() as f64;
(B[m[32m+            let avg_value =
(B[m[32m+                recent_metrics.iter().map(|m| m.value).sum::<f64>() / recent_metrics.len() as f64;
(B[m 
             // Check condition
             let condition_met = match rule.condition {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:320:
                     severity: rule.severity.clone(),
                     message: format!(
                         "Alert {} triggered: {} {} {} (current: {})",
[31m-                        rule.name, rule.metric_name, format!("{:?}", rule.condition), rule.threshold, avg_value
(B[m[32m+                        rule.name,
(B[m[32m+                        rule.metric_name,
(B[m[32m+                        format!("{:?}", rule.condition),
(B[m[32m+                        rule.threshold,
(B[m[32m+                        avg_value
(B[m                     ),
                     started_at: Utc::now(),
                     last_triggered: Utc::now(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:379:
     /// Get overall system health
     pub async fn get_overall_health(&self) -> ComponentStatus {
         let health_checks = self.health_checks.read().await;
[31m-        
(B[m[32m+
(B[m         if health_checks.is_empty() {
             return ComponentStatus::Unknown;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:447:
         // Start alert evaluation task
         let monitoring_system = self.clone();
         tokio::spawn(async move {
[31m-            let mut interval = tokio::time::interval(
(B[m[31m-                tokio::time::Duration::from_secs(monitoring_system.config.alert_evaluation_interval_seconds)
(B[m[31m-            );
(B[m[32m+            let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(
(B[m[32m+                monitoring_system.config.alert_evaluation_interval_seconds,
(B[m[32m+            ));
(B[m 
             loop {
                 interval.tick().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:498:
     async fn test_monitoring_system_creation() {
         let config = MonitoringConfig::default();
         let monitoring = MonitoringSystem::new(config);
[31m-        
(B[m[32m+
(B[m         let system_info = monitoring.get_system_info().await;
         assert!(!system_info.version.is_empty());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:507:
     async fn test_metric_recording() {
         let config = MonitoringConfig::default();
         let monitoring = MonitoringSystem::new(config);
[31m-        
(B[m[32m+
(B[m         let mut labels = HashMap::new();
         labels.insert("component".to_string(), "test".to_string());
[31m-        
(B[m[31m-        monitoring.increment_counter("test_counter", labels.clone()).await.unwrap();
(B[m[31m-        monitoring.set_gauge("test_gauge", 42.0, labels).await.unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        monitoring
(B[m[32m+            .increment_counter("test_counter", labels.clone())
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+        monitoring
(B[m[32m+            .set_gauge("test_gauge", 42.0, labels)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         let metrics = monitoring.get_metrics().await;
         assert_eq!(metrics.len(), 2);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:522:
     async fn test_health_checks() {
         let config = MonitoringConfig::default();
         let monitoring = MonitoringSystem::new(config);
[31m-        
(B[m[32m+
(B[m         let mut details = HashMap::new();
         details.insert("version".to_string(), "1.0.0".to_string());
[31m-        
(B[m[31m-        monitoring.update_health_check(
(B[m[31m-            "database".to_string(),
(B[m[31m-            ComponentStatus::Healthy,
(B[m[31m-            "All systems operational".to_string(),
(B[m[31m-            50,
(B[m[31m-            details,
(B[m[31m-        ).await.unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        monitoring
(B[m[32m+            .update_health_check(
(B[m[32m+                "database".to_string(),
(B[m[32m+                ComponentStatus::Healthy,
(B[m[32m+                "All systems operational".to_string(),
(B[m[32m+                50,
(B[m[32m+                details,
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         let health_status = monitoring.get_health_status().await;
         assert_eq!(health_status.len(), 1);
[31m-        assert_eq!(health_status.get("database").unwrap().status, ComponentStatus::Healthy);
(B[m[31m-        
(B[m[32m+        assert_eq!(
(B[m[32m+            health_status.get("database").unwrap().status,
(B[m[32m+            ComponentStatus::Healthy
(B[m[32m+        );
(B[m[32m+
(B[m         let overall_health = monitoring.get_overall_health().await;
         assert_eq!(overall_health, ComponentStatus::Healthy);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:546:
     async fn test_alert_rules() {
         let config = MonitoringConfig::default();
         let monitoring = MonitoringSystem::new(config);
[31m-        
(B[m[32m+
(B[m         let rule = AlertRule {
             id: "test_rule".to_string(),
             name: "High CPU Usage".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/monitoring.rs:558:
             enabled: true,
             labels: HashMap::new(),
         };
[31m-        
(B[m[32m+
(B[m         monitoring.add_alert_rule(rule).await.unwrap();
[31m-        
(B[m[32m+
(B[m         // Record high CPU usage
[31m-        monitoring.set_gauge("cpu_usage", 85.0, HashMap::new()).await.unwrap();
(B[m[31m-        
(B[m[32m+        monitoring
(B[m[32m+            .set_gauge("cpu_usage", 85.0, HashMap::new())
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         let alerts = monitoring.evaluate_alerts().await.unwrap();
         assert_eq!(alerts.len(), 1);
         assert_eq!(alerts[0].severity, AlertSeverity::Warning);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:1:
 //! Memory CRUD operations
 
[31m-use crate::types::{Memory, MemoryQuery, MemorySearchResult, MemoryStats, MemoryType, MatchType};
(B[m[31m-use agent_mem_traits::{Result, AgentMemError, Vector};
(B[m[32m+use crate::types::{MatchType, Memory, MemoryQuery, MemorySearchResult, MemoryStats, MemoryType};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result, Vector};
(B[m use agent_mem_utils::jaccard_similarity;
[31m-use std::collections::HashMap;
(B[m use serde::{Deserialize, Serialize};
[32m+use std::collections::HashMap;
(B[m 
 /// Memory operations interface
 #[async_trait::async_trait]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:11:
 pub trait MemoryOperations {
     /// Create a new memory
     async fn create_memory(&mut self, memory: Memory) -> Result<String>;
[31m-    
(B[m[32m+
(B[m     /// Get a memory by ID
     async fn get_memory(&self, memory_id: &str) -> Result<Option<Memory>>;
[31m-    
(B[m[32m+
(B[m     /// Update an existing memory
     async fn update_memory(&mut self, memory: Memory) -> Result<()>;
[31m-    
(B[m[32m+
(B[m     /// Delete a memory
     async fn delete_memory(&mut self, memory_id: &str) -> Result<bool>;
[31m-    
(B[m[32m+
(B[m     /// Search memories
     async fn search_memories(&self, query: MemoryQuery) -> Result<Vec<MemorySearchResult>>;
[31m-    
(B[m[32m+
(B[m     /// Get all memories for an agent
[31m-    async fn get_agent_memories(&self, agent_id: &str, limit: Option<usize>) -> Result<Vec<Memory>>;
(B[m[31m-    
(B[m[32m+    async fn get_agent_memories(&self, agent_id: &str, limit: Option<usize>)
(B[m[32m+        -> Result<Vec<Memory>>;
(B[m[32m+
(B[m     /// Get memories by type
[31m-    async fn get_memories_by_type(&self, agent_id: &str, memory_type: MemoryType) -> Result<Vec<Memory>>;
(B[m[31m-    
(B[m[32m+    async fn get_memories_by_type(
(B[m[32m+        &self,
(B[m[32m+        agent_id: &str,
(B[m[32m+        memory_type: MemoryType,
(B[m[32m+    ) -> Result<Vec<Memory>>;
(B[m[32m+
(B[m     /// Get memory statistics
     async fn get_memory_stats(&self, agent_id: Option<&str>) -> Result<MemoryStats>;
[31m-    
(B[m[32m+
(B[m     /// Batch create memories
     async fn batch_create_memories(&mut self, memories: Vec<Memory>) -> Result<Vec<String>>;
[31m-    
(B[m[32m+
(B[m     /// Batch delete memories
     async fn batch_delete_memories(&mut self, memory_ids: Vec<String>) -> Result<usize>;
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:97:
 
         for memory in memories {
             let content_lower = memory.content.to_lowercase();
[31m-            
(B[m[32m+
(B[m             if content_lower.contains(&query_lower) {
                 let match_type = if content_lower == query_lower {
                     MatchType::ExactText
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:117:
         }
 
         // Sort by score descending
[31m-        results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap_or(std::cmp::Ordering::Equal));
(B[m[32m+        results.sort_by(|a, b| {
(B[m[32m+            b.score
(B[m[32m+                .partial_cmp(&a.score)
(B[m[32m+                .unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+        });
(B[m         results
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:124:
     /// Perform vector-based semantic search
[31m-    fn search_by_vector(&self, memories: &[&Memory], query_vector: &Vector) -> Vec<MemorySearchResult> {
(B[m[32m+    fn search_by_vector(
(B[m[32m+        &self,
(B[m[32m+        memories: &[&Memory],
(B[m[32m+        query_vector: &Vector,
(B[m[32m+    ) -> Vec<MemorySearchResult> {
(B[m         let mut results = Vec::new();
 
         for memory in memories {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:129:
             if let Some(ref embedding) = memory.embedding {
                 // Calculate cosine similarity
                 let similarity = self.cosine_similarity(&query_vector.values, &embedding.values);
[31m-                
(B[m[31m-                if similarity > 0.1 { // Minimum similarity threshold
(B[m[32m+
(B[m[32m+                if similarity > 0.1 {
(B[m[32m+                    // Minimum similarity threshold
(B[m                     results.push(MemorySearchResult {
                         memory: (*memory).clone(),
                         score: similarity,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:141:
         }
 
         // Sort by similarity descending
[31m-        results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap_or(std::cmp::Ordering::Equal));
(B[m[32m+        results.sort_by(|a, b| {
(B[m[32m+            b.score
(B[m[32m+                .partial_cmp(&a.score)
(B[m[32m+                .unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+        });
(B[m         results
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:165:
     /// Filter memories based on query criteria
     fn filter_memories(&self, query: &MemoryQuery) -> Vec<&Memory> {
         let current_time = chrono::Utc::now().timestamp();
[31m-        
(B[m[32m+
(B[m         self.memories
             .values()
             .filter(|memory| {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:218:
 impl MemoryOperations for InMemoryOperations {
     async fn create_memory(&mut self, memory: Memory) -> Result<String> {
         let memory_id = memory.id.clone();
[31m-        
(B[m[32m+
(B[m         if self.memories.contains_key(&memory_id) {
             return Err(AgentMemError::memory_error("Memory already exists"));
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:225:
 
         self.update_indices(&memory);
         self.memories.insert(memory_id.clone(), memory);
[31m-        
(B[m[32m+
(B[m         Ok(memory_id)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:238:
 
         if let Some(existing) = self.memories.get(&memory_id) {
             // Check if indices need updating
[31m-            let needs_reindex = existing.agent_id != memory.agent_id || existing.memory_type != memory.memory_type;
(B[m[32m+            let needs_reindex =
(B[m[32m+                existing.agent_id != memory.agent_id || existing.memory_type != memory.memory_type;
(B[m 
             if needs_reindex {
                 // Clone the existing memory to avoid borrow issues
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:265:
 
     async fn search_memories(&self, query: MemoryQuery) -> Result<Vec<MemorySearchResult>> {
         let filtered_memories = self.filter_memories(&query);
[31m-        
(B[m[32m+
(B[m         let mut results = if let Some(ref text_query) = query.text_query {
             self.search_by_text(&filtered_memories, text_query)
         } else if let Some(ref vector_query) = query.vector_query {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:287:
         Ok(results)
     }
 
[31m-    async fn get_agent_memories(&self, agent_id: &str, limit: Option<usize>) -> Result<Vec<Memory>> {
(B[m[32m+    async fn get_agent_memories(
(B[m[32m+        &self,
(B[m[32m+        agent_id: &str,
(B[m[32m+        limit: Option<usize>,
(B[m[32m+    ) -> Result<Vec<Memory>> {
(B[m         let memory_ids = self.agent_index.get(agent_id).cloned().unwrap_or_default();
         let mut memories: Vec<Memory> = memory_ids
             .iter()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:305:
         Ok(memories)
     }
 
[31m-    async fn get_memories_by_type(&self, agent_id: &str, memory_type: MemoryType) -> Result<Vec<Memory>> {
(B[m[31m-        let memory_ids = self.type_index.get(&memory_type).cloned().unwrap_or_default();
(B[m[32m+    async fn get_memories_by_type(
(B[m[32m+        &self,
(B[m[32m+        agent_id: &str,
(B[m[32m+        memory_type: MemoryType,
(B[m[32m+    ) -> Result<Vec<Memory>> {
(B[m[32m+        let memory_ids = self
(B[m[32m+            .type_index
(B[m[32m+            .get(&memory_type)
(B[m[32m+            .cloned()
(B[m[32m+            .unwrap_or_default();
(B[m         let memories: Vec<Memory> = memory_ids
             .iter()
             .filter_map(|id| self.memories.get(id))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:343:
 
         for memory in &memories {
             // Type distribution
[31m-            *stats.memories_by_type.entry(memory.memory_type).or_insert(0) += 1;
(B[m[31m-            
(B[m[32m+            *stats
(B[m[32m+                .memories_by_type
(B[m[32m+                .entry(memory.memory_type)
(B[m[32m+                .or_insert(0) += 1;
(B[m[32m+
(B[m             // Agent distribution
[31m-            *stats.memories_by_agent.entry(memory.agent_id.clone()).or_insert(0) += 1;
(B[m[31m-            
(B[m[32m+            *stats
(B[m[32m+                .memories_by_agent
(B[m[32m+                .entry(memory.agent_id.clone())
(B[m[32m+                .or_insert(0) += 1;
(B[m[32m+
(B[m             // Importance and access stats
             total_importance += memory.importance;
             total_access_count += memory.access_count as u64;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:354:
[31m-            
(B[m[32m+
(B[m             if memory.access_count > most_accessed_count {
                 most_accessed_count = memory.access_count;
                 stats.most_accessed_memory_id = Some(memory.id.clone());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:358:
             }
[31m-            
(B[m[32m+
(B[m             if memory.created_at < oldest_timestamp {
                 oldest_timestamp = memory.created_at;
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:371:
 
     async fn batch_create_memories(&mut self, memories: Vec<Memory>) -> Result<Vec<String>> {
         let mut created_ids = Vec::new();
[31m-        
(B[m[32m+
(B[m         for memory in memories {
             let memory_id = memory.id.clone();
[31m-            
(B[m[32m+
(B[m             if self.memories.contains_key(&memory_id) {
[31m-                return Err(AgentMemError::memory_error(&format!("Memory {} already exists", memory_id)));
(B[m[32m+                return Err(AgentMemError::memory_error(&format!(
(B[m[32m+                    "Memory {} already exists",
(B[m[32m+                    memory_id
(B[m[32m+                )));
(B[m             }
[31m-            
(B[m[32m+
(B[m             self.update_indices(&memory);
             self.memories.insert(memory_id.clone(), memory);
             created_ids.push(memory_id);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:385:
         }
[31m-        
(B[m[32m+
(B[m         Ok(created_ids)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:390:
     async fn batch_delete_memories(&mut self, memory_ids: Vec<String>) -> Result<usize> {
         let mut deleted_count = 0;
[31m-        
(B[m[32m+
(B[m         for memory_id in memory_ids {
             if let Some(memory) = self.memories.remove(&memory_id) {
                 self.remove_from_indices(&memory);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/operations.rs:396:
                 deleted_count += 1;
             }
         }
[31m-        
(B[m[32m+
(B[m         Ok(deleted_count)
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:1:
 //! Production Security and Hardening System
[31m-//! 
(B[m[32m+//!
(B[m //! Comprehensive security features including encryption, access control,
 //! threat detection, and security hardening for production environments.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m[32m+use chrono::{DateTime, Duration, Utc};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::{HashMap, HashSet};
 use std::sync::Arc;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:10:
 use tokio::sync::RwLock;
[31m-use chrono::{DateTime, Utc, Duration};
(B[m use uuid::Uuid;
 
 /// Security system configuration
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:253:
                 Permission::ImportData,
                 Permission::ManageUsers,
                 Permission::ViewMetrics,
[31m-            ].iter().cloned().collect(),
(B[m[32m+            ]
(B[m[32m+            .iter()
(B[m[32m+            .cloned()
(B[m[32m+            .collect(),
(B[m             description: "Full system administrator".to_string(),
[31m-        }).await?;
(B[m[32m+        })
(B[m[32m+        .await?;
(B[m 
         self.create_role(Role {
             name: "user".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:262:
[31m-            permissions: [
(B[m[31m-                Permission::ReadMemory,
(B[m[31m-                Permission::WriteMemory,
(B[m[31m-            ].iter().cloned().collect(),
(B[m[32m+            permissions: [Permission::ReadMemory, Permission::WriteMemory]
(B[m[32m+                .iter()
(B[m[32m+                .cloned()
(B[m[32m+                .collect(),
(B[m             description: "Regular user with basic memory access".to_string(),
[31m-        }).await?;
(B[m[32m+        })
(B[m[32m+        .await?;
(B[m 
         self.create_role(Role {
             name: "readonly".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:271:
             permissions: [Permission::ReadMemory].iter().cloned().collect(),
             description: "Read-only access to memories".to_string(),
[31m-        }).await?;
(B[m[32m+        })
(B[m[32m+        .await?;
(B[m 
         // Create default threat rules
         self.add_threat_rule(ThreatRule {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:283:
             severity: ThreatSeverity::Medium,
             enabled: true,
             actions: vec![ThreatAction::LogEvent, ThreatAction::LockAccount],
[31m-        }).await?;
(B[m[32m+        })
(B[m[32m+        .await?;
(B[m 
         self.add_threat_rule(ThreatRule {
             id: "rate_limit_exceeded".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:295:
             severity: ThreatSeverity::High,
             enabled: true,
             actions: vec![ThreatAction::LogEvent, ThreatAction::BlockIP],
[31m-        }).await?;
(B[m[32m+        })
(B[m[32m+        .await?;
(B[m 
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:333:
         }
 
         let mut users = self.users.write().await;
[31m-        let user = users.values_mut()
(B[m[32m+        let user = users
(B[m[32m+            .values_mut()
(B[m             .find(|u| u.username == username && u.active)
             .ok_or_else(|| AgentMemError::memory_error("Invalid credentials"))?;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:353:
 
         if !password_valid {
             user.failed_login_attempts += 1;
[31m-            
(B[m[32m+
(B[m             // Lock account if too many failed attempts
             if user.failed_login_attempts >= self.config.max_failed_login_attempts {
                 user.locked_until = Some(
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:360:
[31m-                    Utc::now() + Duration::minutes(self.config.account_lockout_duration_minutes as i64)
(B[m[32m+                    Utc::now()
(B[m[32m+                        + Duration::minutes(self.config.account_lockout_duration_minutes as i64),
(B[m                 );
             }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:364:
             // Trigger threat detection
[31m-            self.detect_threat(ThreatRuleType::FailedLoginAttempts, ip_address, Some(&user.user_id)).await?;
(B[m[32m+            self.detect_threat(
(B[m[32m+                ThreatRuleType::FailedLoginAttempts,
(B[m[32m+                ip_address,
(B[m[32m+                Some(&user.user_id),
(B[m[32m+            )
(B[m[32m+            .await?;
(B[m 
             return Err(AgentMemError::memory_error("Invalid credentials"));
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:393:
     /// Validate session
     pub async fn validate_session(&self, session_id: &str) -> Result<Session> {
         let mut sessions = self.sessions.write().await;
[31m-        let session = sessions.get_mut(session_id)
(B[m[32m+        let session = sessions
(B[m[32m+            .get_mut(session_id)
(B[m             .ok_or_else(|| AgentMemError::memory_error("Invalid session"))?;
 
         if !session.active || Utc::now() > session.expires_at {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:403:
 
         // Update last accessed time
         session.last_accessed = Utc::now();
[31m-        session.expires_at = Utc::now() + Duration::minutes(self.config.session_timeout_minutes as i64);
(B[m[32m+        session.expires_at =
(B[m[32m+            Utc::now() + Duration::minutes(self.config.session_timeout_minutes as i64);
(B[m 
         Ok(session.clone())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:415:
         }
 
         let users = self.users.read().await;
[31m-        let user = users.get(user_id)
(B[m[32m+        let user = users
(B[m[32m+            .get(user_id)
(B[m             .ok_or_else(|| AgentMemError::memory_error("User not found"))?;
 
         let roles = self.roles.read().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:449:
         }
 
         let threat_rules = self.threat_rules.read().await;
[31m-        let matching_rules: Vec<_> = threat_rules.values()
(B[m[31m-            .filter(|rule| rule.enabled && std::mem::discriminant(&rule.rule_type) == std::mem::discriminant(&rule_type))
(B[m[32m+        let matching_rules: Vec<_> = threat_rules
(B[m[32m+            .values()
(B[m[32m+            .filter(|rule| {
(B[m[32m+                rule.enabled
(B[m[32m+                    && std::mem::discriminant(&rule.rule_type) == std::mem::discriminant(&rule_type)
(B[m[32m+            })
(B[m             .collect();
 
         for rule in matching_rules {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:472:
 
             // Execute threat actions
             for action in &rule.actions {
[31m-                self.execute_threat_action(action, source_ip, user_id).await?;
(B[m[32m+                self.execute_threat_action(action, source_ip, user_id)
(B[m[32m+                    .await?;
(B[m             }
 
             // Store incident
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:545:
         let mut users = self.users.write().await;
         if let Some(user) = users.get_mut(user_id) {
             user.locked_until = Some(
[31m-                Utc::now() + Duration::minutes(self.config.account_lockout_duration_minutes as i64)
(B[m[32m+                Utc::now() + Duration::minutes(self.config.account_lockout_duration_minutes as i64),
(B[m             );
         }
         Ok(())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:571:
     /// Get active sessions
     pub async fn get_active_sessions(&self) -> Vec<Session> {
         let sessions = self.sessions.read().await;
[31m-        sessions.values()
(B[m[32m+        sessions
(B[m[32m+            .values()
(B[m             .filter(|s| s.active && Utc::now() <= s.expires_at)
             .cloned()
             .collect()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:586:
     async fn test_security_system_creation() {
         let config = SecurityConfig::default();
         let security = SecuritySystem::new(config);
[31m-        
(B[m[32m+
(B[m         // Wait for initialization
         tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
[31m-        
(B[m[32m+
(B[m         let roles = security.roles.read().await;
         assert!(roles.contains_key("admin"));
         assert!(roles.contains_key("user"));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:599:
     async fn test_user_authentication() {
         let config = SecurityConfig::default();
         let security = SecuritySystem::new(config);
[31m-        
(B[m[32m+
(B[m         // Create test user
         let user = UserAccount {
             user_id: "test_user".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:613:
             active: true,
             metadata: HashMap::new(),
         };
[31m-        
(B[m[32m+
(B[m         security.create_user(user).await.unwrap();
[31m-        
(B[m[32m+
(B[m         // Test authentication failure
[31m-        let result = security.authenticate_user(
(B[m[31m-            "testuser",
(B[m[31m-            "wrong_password",
(B[m[31m-            "192.168.1.1",
(B[m[31m-            "Mozilla/5.0"
(B[m[31m-        ).await;
(B[m[32m+        let result = security
(B[m[32m+            .authenticate_user("testuser", "wrong_password", "192.168.1.1", "Mozilla/5.0")
(B[m[32m+            .await;
(B[m         assert!(result.is_err());
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:630:
     async fn test_permission_checking() {
         let config = SecurityConfig::default();
         let security = SecuritySystem::new(config);
[31m-        
(B[m[32m+
(B[m         // Wait for initialization
         tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
[31m-        
(B[m[32m+
(B[m         // Create test user with admin role
         let user = UserAccount {
             user_id: "admin_user".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:647:
             active: true,
             metadata: HashMap::new(),
         };
[31m-        
(B[m[32m+
(B[m         security.create_user(user).await.unwrap();
[31m-        
(B[m[32m+
(B[m         // Check admin permissions
[31m-        let has_admin_access = security.check_permission("admin_user", &Permission::AdminAccess).await.unwrap();
(B[m[32m+        let has_admin_access = security
(B[m[32m+            .check_permission("admin_user", &Permission::AdminAccess)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m         assert!(has_admin_access);
[31m-        
(B[m[31m-        let has_read_access = security.check_permission("admin_user", &Permission::ReadMemory).await.unwrap();
(B[m[32m+
(B[m[32m+        let has_read_access = security
(B[m[32m+            .check_permission("admin_user", &Permission::ReadMemory)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m         assert!(has_read_access);
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/security.rs:662:
     async fn test_threat_detection() {
         let config = SecurityConfig::default();
         let security = SecuritySystem::new(config);
[31m-        
(B[m[32m+
(B[m         // Wait for initialization
         tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
[31m-        
(B[m[32m+
(B[m         // Trigger threat detection
[31m-        security.detect_threat(
(B[m[31m-            ThreatRuleType::FailedLoginAttempts,
(B[m[31m-            "192.168.1.100",
(B[m[31m-            Some("test_user")
(B[m[31m-        ).await.unwrap();
(B[m[31m-        
(B[m[32m+        security
(B[m[32m+            .detect_threat(
(B[m[32m+                ThreatRuleType::FailedLoginAttempts,
(B[m[32m+                "192.168.1.100",
(B[m[32m+                Some("test_user"),
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         let incidents = security.get_threat_incidents().await;
         assert!(!incidents.is_empty());
         assert_eq!(incidents[0].severity, ThreatSeverity::Medium);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/types.rs:1:
 //! Core memory types and data structures
 
[32m+use agent_mem_traits::{AgentMemError, MemoryItem, Result, Vector};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use uuid::Uuid;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/types.rs:6:
[31m-use agent_mem_traits::{MemoryItem, Vector, Result, AgentMemError};
(B[m 
 /// Memory type classification
 #[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Hash)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/types.rs:140:
         let current_time = chrono::Utc::now().timestamp();
         let time_decay = (current_time - self.created_at) as f32 / (24.0 * 3600.0); // days
         let access_factor = (self.access_count as f32 + 1.0).ln();
[31m-        
(B[m[32m+
(B[m         // Apply time decay and access boost
         self.importance * (-time_decay * 0.01).exp() * (1.0 + access_factor * 0.1)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/types.rs:179:
 
 impl From<Memory> for MemoryItem {
     fn from(memory: Memory) -> Self {
[31m-        use agent_mem_traits::{Session, MemoryType as TraitMemoryType, Entity, Relation};
(B[m[32m+        use agent_mem_traits::{Entity, MemoryType as TraitMemoryType, Relation, Session};
(B[m         use chrono::{DateTime, Utc};
 
         // Convert metadata from String to serde_json::Value
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/types.rs:186:
[31m-        let metadata: std::collections::HashMap<String, serde_json::Value> = memory.metadata
(B[m[32m+        let metadata: std::collections::HashMap<String, serde_json::Value> = memory
(B[m[32m+            .metadata
(B[m             .into_iter()
             .map(|(k, v)| (k, serde_json::Value::String(v)))
             .collect();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/types.rs:201:
             hash: None, // TODO: Calculate hash if needed
             metadata,
             score: Some(memory.importance),
[31m-            created_at: DateTime::from_timestamp(memory.created_at, 0).unwrap_or_else(|| Utc::now()),
(B[m[31m-            updated_at: Some(DateTime::from_timestamp(memory.last_accessed_at, 0).unwrap_or_else(|| Utc::now())),
(B[m[32m+            created_at: DateTime::from_timestamp(memory.created_at, 0)
(B[m[32m+                .unwrap_or_else(|| Utc::now()),
(B[m[32m+            updated_at: Some(
(B[m[32m+                DateTime::from_timestamp(memory.last_accessed_at, 0).unwrap_or_else(|| Utc::now()),
(B[m[32m+            ),
(B[m             session,
             memory_type: match memory.memory_type {
                 MemoryType::Episodic => TraitMemoryType::Episodic,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/types.rs:210:
                 MemoryType::Procedural => TraitMemoryType::Procedural,
                 MemoryType::Working => TraitMemoryType::Working,
             },
[31m-            entities: Vec::new(), // TODO: Extract entities if needed
(B[m[32m+            entities: Vec::new(),  // TODO: Extract entities if needed
(B[m             relations: Vec::new(), // TODO: Extract relations if needed
         }
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/types.rs:221:
 
     fn try_from(item: MemoryItem) -> Result<Self> {
         // Convert metadata from serde_json::Value to String
[31m-        let metadata: std::collections::HashMap<String, String> = item.metadata
(B[m[32m+        let metadata: std::collections::HashMap<String, String> = item
(B[m[32m+            .metadata
(B[m             .into_iter()
[31m-            .filter_map(|(k, v)| {
(B[m[31m-                match v {
(B[m[31m-                    serde_json::Value::String(s) => Some((k, s)),
(B[m[31m-                    _ => Some((k, v.to_string())),
(B[m[31m-                }
(B[m[32m+            .filter_map(|(k, v)| match v {
(B[m[32m+                serde_json::Value::String(s) => Some((k, s)),
(B[m[32m+                _ => Some((k, v.to_string())),
(B[m             })
             .collect();
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/types.rs:234:
[31m-        let agent_id = item.session.agent_id
(B[m[32m+        let agent_id = item
(B[m[32m+            .session
(B[m[32m+            .agent_id
(B[m             .ok_or_else(|| AgentMemError::memory_error("Missing agent_id in session"))?;
 
         let memory_type = match item.memory_type {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-core/src/types.rs:251:
             importance: item.score.unwrap_or(0.5),
             embedding: None,
             created_at: item.created_at.timestamp(),
[31m-            last_accessed_at: item.updated_at.map(|dt| dt.timestamp()).unwrap_or_else(|| chrono::Utc::now().timestamp()),
(B[m[31m-            access_count: 0, // Default value
(B[m[32m+            last_accessed_at: item
(B[m[32m+                .updated_at
(B[m[32m+                .map(|dt| dt.timestamp())
(B[m[32m+                .unwrap_or_else(|| chrono::Utc::now().timestamp()),
(B[m[32m+            access_count: 0,  // Default value
(B[m             expires_at: None, // Default value
             metadata,
             version: 1,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:1:
 //! Cluster management for distributed AgentMem
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides cluster management capabilities including
 //! node discovery, health monitoring, and cluster coordination.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::net::SocketAddr;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:11:
 use std::time::{Duration, Instant};
 use tokio::sync::RwLock;
 use tokio::time::{interval, sleep};
[31m-use tracing::{debug, info, warn, error};
(B[m[32m+use tracing::{debug, error, info, warn};
(B[m use uuid::Uuid;
 
 /// Cluster configuration
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:111:
     /// Create a new cluster manager
     pub async fn new(config: ClusterConfig, node_id: Uuid) -> Result<Self> {
         let local_node = ClusterNode::new(node_id, config.node_address);
[31m-        
(B[m[32m+
(B[m         let manager = Self {
             config,
             node_id,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:120:
             is_running: Arc::new(RwLock::new(false)),
         };
 
[31m-        info!("Cluster manager created for node {} at {}", 
(B[m[31m-              node_id, manager.config.node_address);
(B[m[31m-        
(B[m[32m+        info!(
(B[m[32m+            "Cluster manager created for node {} at {}",
(B[m[32m+            node_id, manager.config.node_address
(B[m[32m+        );
(B[m[32m+
(B[m         Ok(manager)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:129:
     /// Start cluster services
     pub async fn start(&self) -> Result<()> {
         *self.is_running.write().await = true;
[31m-        
(B[m[32m+
(B[m         // Add local node to cluster
         {
             let local_node = self.local_node.read().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:139:
 
         // Start health monitoring
         self.start_health_monitor().await;
[31m-        
(B[m[32m+
(B[m         // Start node discovery if enabled
         if self.config.enable_auto_discovery {
             self.start_node_discovery().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:176:
         // Simplified node discovery - in practice would use HTTP/gRPC
         let node_id = Uuid::new_v4(); // Would get from actual node
         let node = ClusterNode::new(node_id, address);
[31m-        
(B[m[32m+
(B[m         debug!("Discovered node {} at {}", node_id, address);
         Ok(node)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:191:
 
         tokio::spawn(async move {
             let mut interval = interval(interval_duration);
[31m-            
(B[m[32m+
(B[m             while *is_running.read().await {
                 interval.tick().await;
[31m-                
(B[m[32m+
(B[m                 // Update local node health
                 {
                     let mut local = local_node.write().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:205:
                 {
                     let mut nodes_guard = nodes.write().await;
                     let mut failed_nodes = Vec::new();
[31m-                    
(B[m[32m+
(B[m                     for (node_id, node) in nodes_guard.iter_mut() {
                         if !node.is_healthy(timeout) && node.status != NodeStatus::Failed {
                             warn!("Node {} marked as failed", node_id);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:213:
                             failed_nodes.push(*node_id);
                         }
                     }
[31m-                    
(B[m[32m+
(B[m                     // Remove failed nodes after timeout
                     for node_id in failed_nodes {
                         if let Some(node) = nodes_guard.get(&node_id) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:236:
 
         tokio::spawn(async move {
             let mut interval = interval(Duration::from_secs(60)); // Discovery every minute
[31m-            
(B[m[32m+
(B[m             while *is_running.read().await {
                 interval.tick().await;
[31m-                
(B[m[32m+
(B[m                 // Simplified auto-discovery - in practice would use multicast, consul, etc.
[31m-                debug!("Running node auto-discovery for cluster {}", config.cluster_name);
(B[m[32m+                debug!(
(B[m[32m+                    "Running node auto-discovery for cluster {}",
(B[m[32m+                    config.cluster_name
(B[m[32m+                );
(B[m             }
         });
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:249:
     /// Add a node to the cluster
     pub async fn add_node(&self, node: ClusterNode) -> Result<()> {
         let mut nodes = self.nodes.write().await;
[31m-        
(B[m[32m+
(B[m         if nodes.len() >= self.config.max_cluster_size {
             return Err(AgentMemError::memory_error("Cluster size limit reached"));
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:256:
[31m-        
(B[m[32m+
(B[m         nodes.insert(node.id, node.clone());
         info!("Added node {} to cluster", node.id);
         Ok(())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:262:
     /// Remove a node from the cluster
     pub async fn remove_node(&self, node_id: Uuid) -> Result<()> {
         let mut nodes = self.nodes.write().await;
[31m-        
(B[m[32m+
(B[m         if let Some(mut node) = nodes.get_mut(&node_id) {
             node.status = NodeStatus::Leaving;
             info!("Marked node {} as leaving", node_id);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:269:
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:274:
     /// Get cluster information
     pub async fn get_cluster_info(&self) -> Result<super::ClusterInfo> {
         let nodes = self.nodes.read().await;
[31m-        let healthy_nodes = nodes.values()
(B[m[32m+        let healthy_nodes = nodes
(B[m[32m+            .values()
(B[m             .filter(|n| n.status == NodeStatus::Healthy)
             .count();
[31m-        
(B[m[32m+
(B[m         let leader_node = self.find_leader(&nodes).await;
[31m-        
(B[m[32m+
(B[m         Ok(super::ClusterInfo {
             total_nodes: nodes.len(),
             healthy_nodes,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:290:
 
     /// Find the cluster leader (simplified - highest node ID)
     async fn find_leader(&self, nodes: &HashMap<Uuid, ClusterNode>) -> Option<Uuid> {
[31m-        nodes.values()
(B[m[32m+        nodes
(B[m[32m+            .values()
(B[m             .filter(|n| n.status == NodeStatus::Healthy)
             .max_by_key(|n| n.id)
             .map(|n| n.id)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:299:
     /// Get healthy nodes
     pub async fn get_healthy_nodes(&self) -> Result<Vec<ClusterNode>> {
         let nodes = self.nodes.read().await;
[31m-        let healthy_nodes = nodes.values()
(B[m[32m+        let healthy_nodes = nodes
(B[m[32m+            .values()
(B[m             .filter(|n| n.status == NodeStatus::Healthy)
             .cloned()
             .collect();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:306:
[31m-        
(B[m[32m+
(B[m         Ok(healthy_nodes)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:310:
     /// Check if cluster has minimum required nodes
     pub async fn has_quorum(&self) -> bool {
         let nodes = self.nodes.read().await;
[31m-        let healthy_count = nodes.values()
(B[m[32m+        let healthy_count = nodes
(B[m[32m+            .values()
(B[m             .filter(|n| n.status == NodeStatus::Healthy)
             .count();
[31m-        
(B[m[32m+
(B[m         healthy_count >= self.config.min_cluster_size
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:324:
     }
 
     /// Update node metadata
[31m-    pub async fn update_node_metadata(&self, node_id: Uuid, metadata: HashMap<String, String>) -> Result<()> {
(B[m[32m+    pub async fn update_node_metadata(
(B[m[32m+        &self,
(B[m[32m+        node_id: Uuid,
(B[m[32m+        metadata: HashMap<String, String>,
(B[m[32m+    ) -> Result<()> {
(B[m         let mut nodes = self.nodes.write().await;
[31m-        
(B[m[32m+
(B[m         if let Some(node) = nodes.get_mut(&node_id) {
             node.metadata = metadata;
             info!("Updated metadata for node {}", node_id);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:333:
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:338:
     /// Shutdown cluster services
     pub async fn shutdown(&self) -> Result<()> {
         *self.is_running.write().await = false;
[31m-        
(B[m[32m+
(B[m         // Mark local node as leaving
         {
             let mut local_node = self.local_node.write().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:367:
         let node_id = Uuid::new_v4();
         let address = "127.0.0.1:8080".parse().unwrap();
         let mut node = ClusterNode::new(node_id, address);
[31m-        
(B[m[32m+
(B[m         assert_eq!(node.status, NodeStatus::Joining);
[31m-        
(B[m[32m+
(B[m         node.update_health();
         assert_eq!(node.status, NodeStatus::Healthy);
[31m-        
(B[m[32m+
(B[m         let timeout = Duration::from_millis(1);
         sleep(Duration::from_millis(2)).await;
         assert!(!node.is_healthy(timeout));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:386:
         };
         let node_id = Uuid::new_v4();
         let manager = ClusterManager::new(config, node_id).await.unwrap();
[31m-        
(B[m[32m+
(B[m         // Start with no quorum (only local node)
         manager.start().await.unwrap();
         assert!(!manager.has_quorum().await);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:393:
[31m-        
(B[m[32m+
(B[m         // Add nodes to reach quorum
         for i in 0..2 {
             let new_node = ClusterNode {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/cluster.rs:404:
             };
             manager.add_node(new_node).await.unwrap();
         }
[31m-        
(B[m[32m+
(B[m         // Note: The test may need time for nodes to be properly registered
         // In a real implementation, this would be more deterministic
         let has_quorum = manager.has_quorum().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/consensus.rs:1:
 //! Consensus management for distributed AgentMem
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides consensus capabilities for distributed coordination
 //! and leader election.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/consensus.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::sync::Arc;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/consensus.rs:130:
                 sleep(election_timeout).await;
 
                 let current_state = state.read().await.clone();
[31m-                if current_state == ConsensusState::Follower || current_state == ConsensusState::Candidate {
(B[m[32m+                if current_state == ConsensusState::Follower
(B[m[32m+                    || current_state == ConsensusState::Candidate
(B[m[32m+                {
(B[m                     // Start election
                     info!("Node {} starting election", node_id);
[31m-                    
(B[m[32m+
(B[m                     *state.write().await = ConsensusState::Candidate;
                     *current_term.write().await += 1;
                     *voted_for.write().await = Some(node_id);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/consensus.rs:181:
             last_heartbeat: Instant::now(),
         };
         peers.insert(peer_id, peer_info);
[31m-        
(B[m[32m+
(B[m         info!("Added peer {} to consensus group", peer_id);
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/consensus.rs:190:
     pub async fn remove_peer(&self, peer_id: Uuid) -> Result<()> {
         let mut peers = self.peers.write().await;
         peers.remove(&peer_id);
[31m-        
(B[m[32m+
(B[m         info!("Removed peer {} from consensus group", peer_id);
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/consensus.rs:199:
     pub async fn append_entry(&self, command: String) -> Result<u64> {
         let state = self.state.read().await.clone();
         if state != ConsensusState::Leader {
[31m-            return Err(AgentMemError::memory_error("Only leader can append entries"));
(B[m[32m+            return Err(AgentMemError::memory_error(
(B[m[32m+                "Only leader can append entries",
(B[m[32m+            ));
(B[m         }
 
         let mut log = self.log.write().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/consensus.rs:249:
     pub async fn shutdown(&self) -> Result<()> {
         *self.is_running.write().await = false;
         *self.state.write().await = ConsensusState::Follower;
[31m-        
(B[m[32m+
(B[m         info!("Consensus services shutdown for node {}", self.node_id);
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/consensus.rs:272:
         let config = ConsensusConfig::default();
         let node_id = Uuid::new_v4();
         let manager = ConsensusManager::new(config, node_id).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let state = manager.get_state().await.unwrap();
         assert_eq!(state, ConsensusState::Follower);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/consensus.rs:282:
         let config = ConsensusConfig::default();
         let node_id = Uuid::new_v4();
         let manager = ConsensusManager::new(config, node_id).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let peer_id = Uuid::new_v4();
         manager.add_peer(peer_id).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let peers = manager.peers.read().await;
         assert!(peers.contains_key(&peer_id));
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/consensus.rs:295:
         let config = ConsensusConfig::default();
         let node_id = Uuid::new_v4();
         let manager = ConsensusManager::new(config, node_id).await.unwrap();
[31m-        
(B[m[32m+
(B[m         // Set as leader to allow log append
         *manager.state.write().await = ConsensusState::Leader;
[31m-        
(B[m[32m+
(B[m         let result = manager.append_entry("test command".to_string()).await;
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let log_length = manager.get_log_length().await;
         assert_eq!(log_length, 1);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/coordination.rs:1:
 //! Coordination services for distributed AgentMem
 
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::sync::Arc;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/coordination.rs:79:
     async fn test_coordination_manager() {
         let config = CoordinationConfig::default();
         let manager = CoordinationManager::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let node_id = Uuid::new_v4();
         let acquired = manager.acquire_lock("test_key", node_id).await.unwrap();
         assert!(acquired);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/coordination.rs:86:
[31m-        
(B[m[32m+
(B[m         let released = manager.release_lock("test_key", node_id).await.unwrap();
         assert!(released);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/discovery.rs:1:
 //! Service discovery for distributed AgentMem
 
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::net::SocketAddr;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/discovery.rs:78:
     async fn test_service_discovery() {
         let config = DiscoveryConfig::default();
         let discovery = ServiceDiscovery::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let service = ServiceInfo {
             id: Uuid::new_v4(),
             name: "test-service".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/discovery.rs:85:
             address: "127.0.0.1:8080".parse().unwrap(),
             metadata: HashMap::new(),
         };
[31m-        
(B[m[32m+
(B[m         discovery.register_service(service.clone()).await.unwrap();
         let services = discovery.discover_services().await.unwrap();
         assert_eq!(services.len(), 1);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/lib.rs:1:
 //! AgentMem Distributed Computing Module
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides distributed computing capabilities including:
 //! - Cluster mode support
 //! - Data sharding strategies
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/lib.rs:8:
 //! - Load balancing
 
 pub mod cluster;
[31m-pub mod sharding;
(B[m pub mod consensus;
[31m-pub mod discovery;
(B[m pub mod coordination;
[31m-pub mod replication;
(B[m[32m+pub mod discovery;
(B[m pub mod load_balancer;
[32m+pub mod replication;
(B[m[32m+pub mod sharding;
(B[m 
 // Re-export main types
[31m-pub use cluster::{ClusterManager, ClusterConfig, ClusterNode, NodeStatus};
(B[m[31m-pub use sharding::{ShardManager, ShardConfig, ShardKey, ShardStrategy};
(B[m[31m-pub use consensus::{ConsensusManager, ConsensusConfig, ConsensusState};
(B[m[31m-pub use discovery::{ServiceDiscovery, DiscoveryConfig, ServiceInfo};
(B[m[31m-pub use coordination::{CoordinationManager, CoordinationConfig};
(B[m[31m-pub use replication::{ReplicationManager, ReplicationConfig, ReplicationStrategy};
(B[m[32m+pub use cluster::{ClusterConfig, ClusterManager, ClusterNode, NodeStatus};
(B[m[32m+pub use consensus::{ConsensusConfig, ConsensusManager, ConsensusState};
(B[m[32m+pub use coordination::{CoordinationConfig, CoordinationManager};
(B[m[32m+pub use discovery::{DiscoveryConfig, ServiceDiscovery, ServiceInfo};
(B[m pub use load_balancer::{LoadBalancer, LoadBalancerConfig, LoadBalancingStrategy};
[32m+pub use replication::{ReplicationConfig, ReplicationManager, ReplicationStrategy};
(B[m[32m+pub use sharding::{ShardConfig, ShardKey, ShardManager, ShardStrategy};
(B[m 
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::net::SocketAddr;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/lib.rs:89:
     /// Create a new distributed manager
     pub async fn new(config: DistributedConfig) -> Result<Self> {
         let node_id = Uuid::new_v4();
[31m-        
(B[m[32m+
(B[m         let cluster_manager = Arc::new(ClusterManager::new(config.cluster.clone(), node_id).await?);
         let shard_manager = Arc::new(ShardManager::new(config.sharding.clone()).await?);
[31m-        let consensus_manager = Arc::new(ConsensusManager::new(config.consensus.clone(), node_id).await?);
(B[m[32m+        let consensus_manager =
(B[m[32m+            Arc::new(ConsensusManager::new(config.consensus.clone(), node_id).await?);
(B[m         let service_discovery = Arc::new(ServiceDiscovery::new(config.discovery.clone()).await?);
[31m-        let coordination_manager = Arc::new(CoordinationManager::new(config.coordination.clone()).await?);
(B[m[31m-        let replication_manager = Arc::new(ReplicationManager::new(config.replication.clone()).await?);
(B[m[32m+        let coordination_manager =
(B[m[32m+            Arc::new(CoordinationManager::new(config.coordination.clone()).await?);
(B[m[32m+        let replication_manager =
(B[m[32m+            Arc::new(ReplicationManager::new(config.replication.clone()).await?);
(B[m         let load_balancer = Arc::new(LoadBalancer::new(config.load_balancer.clone()).await?);
 
         let manager = Self {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/lib.rs:122:
     async fn start_distributed_services(&self) -> Result<()> {
         // Start cluster management
         self.cluster_manager.start().await?;
[31m-        
(B[m[32m+
(B[m         // Start service discovery
         self.service_discovery.start().await?;
[31m-        
(B[m[32m+
(B[m         // Start consensus if enabled
         if self.config.enable_ha {
             self.consensus_manager.start().await?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/lib.rs:132:
         }
[31m-        
(B[m[32m+
(B[m         // Start coordination
         self.coordination_manager.start().await?;
[31m-        
(B[m[32m+
(B[m         // Start replication
         self.replication_manager.start().await?;
[31m-        
(B[m[32m+
(B[m         tracing::info!("Distributed services started for node {}", self.node_id);
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/lib.rs:209:
     pub async fn shutdown(&self) -> Result<()> {
         self.replication_manager.shutdown().await?;
         self.coordination_manager.shutdown().await?;
[31m-        
(B[m[32m+
(B[m         if self.config.enable_ha {
             self.consensus_manager.shutdown().await?;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/lib.rs:216:
[31m-        
(B[m[32m+
(B[m         self.service_discovery.shutdown().await?;
         self.cluster_manager.shutdown().await?;
[31m-        
(B[m[32m+
(B[m         tracing::info!("Distributed services shutdown for node {}", self.node_id);
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/load_balancer.rs:1:
 //! Load balancing for distributed AgentMem
 
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::sync::Arc;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/load_balancer.rs:91:
     async fn test_load_balancer() {
         let config = LoadBalancerConfig::default();
         let lb = LoadBalancer::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let node1 = Uuid::new_v4();
         let node2 = Uuid::new_v4();
[31m-        
(B[m[32m+
(B[m         lb.add_node(node1).await.unwrap();
         lb.add_node(node2).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let selected1 = lb.select_node().await.unwrap();
         let selected2 = lb.select_node().await.unwrap();
[31m-        
(B[m[32m+
(B[m         assert!(selected1.is_some());
         assert!(selected2.is_some());
         assert_ne!(selected1, selected2); // Round robin should select different nodes
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/replication.rs:1:
 //! Data replication for distributed AgentMem
 
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::sync::Arc;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/replication.rs:70:
     async fn test_replication_manager() {
         let config = ReplicationConfig::default();
         let manager = ReplicationManager::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let nodes = vec![Uuid::new_v4(), Uuid::new_v4()];
[31m-        let result = manager.replicate_data("test_key", b"test_data", &nodes).await;
(B[m[32m+        let result = manager
(B[m[32m+            .replicate_data("test_key", b"test_data", &nodes)
(B[m[32m+            .await;
(B[m         assert!(result.is_ok());
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:1:
 //! Data sharding for distributed AgentMem
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides data sharding capabilities including
 //! consistent hashing, shard distribution, and rebalancing.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use ring::digest::{Context, SHA256};
 use serde::{Deserialize, Serialize};
 use std::collections::{HashMap, HashSet};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:81:
         }
         context.update(self.key.as_bytes());
         let digest = context.finish();
[31m-        
(B[m[32m+
(B[m         // Convert first 8 bytes to u64
         let bytes = digest.as_ref();
         u64::from_be_bytes([
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:88:
[31m-            bytes[0], bytes[1], bytes[2], bytes[3],
(B[m[31m-            bytes[4], bytes[5], bytes[6], bytes[7],
(B[m[32m+            bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7],
(B[m         ])
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:130:
 
     fn rebuild_ring(&mut self) {
         self.ring.clear();
[31m-        
(B[m[32m+
(B[m         for (&node_id, &weight) in &self.nodes {
             // Create virtual nodes based on weight
             let virtual_count = weight as usize * 100; // 100 virtual nodes per weight unit
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:140:
                 self.ring.push((hash, node_id));
             }
         }
[31m-        
(B[m[32m+
(B[m         self.ring.sort_by_key(|&(hash, _)| hash);
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:150:
         }
 
         let hash = self.hash_key(key);
[31m-        
(B[m[32m+
(B[m         // Find first node with hash >= key hash
         match self.ring.binary_search_by_key(&hash, |&(h, _)| h) {
             Ok(index) => Some(self.ring[index].1),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:169:
         let mut context = Context::new(&SHA256);
         context.update(key.as_bytes());
         let digest = context.finish();
[31m-        
(B[m[32m+
(B[m         let bytes = digest.as_ref();
         u64::from_be_bytes([
[31m-            bytes[0], bytes[1], bytes[2], bytes[3],
(B[m[31m-            bytes[4], bytes[5], bytes[6], bytes[7],
(B[m[32m+            bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7],
(B[m         ])
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:199:
         // Initialize shards
         manager.initialize_shards().await?;
 
[31m-        info!("Shard manager created with {} shards", manager.config.shard_count);
(B[m[32m+        info!(
(B[m[32m+            "Shard manager created with {} shards",
(B[m[32m+            manager.config.shard_count
(B[m[32m+        );
(B[m         Ok(manager)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:206:
     /// Initialize shards
     async fn initialize_shards(&self) -> Result<()> {
         let mut shards = self.shards.write().await;
[31m-        
(B[m[32m+
(B[m         for shard_id in 0..self.config.shard_count {
             let shard = Shard {
                 id: shard_id,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:270:
             }
             ShardStrategy::Custom(_) => {
                 // Custom strategy would be implemented here
[31m-                Err(AgentMemError::memory_error("Custom sharding strategy not implemented"))
(B[m[32m+                Err(AgentMemError::memory_error(
(B[m[32m+                    "Custom sharding strategy not implemented",
(B[m[32m+                ))
(B[m             }
         }
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:285:
                 Ok(None)
             }
         } else {
[31m-            Err(AgentMemError::memory_error(&format!("Shard {} not found", shard_id)))
(B[m[32m+            Err(AgentMemError::memory_error(&format!(
(B[m[32m+                "Shard {} not found",
(B[m[32m+                shard_id
(B[m[32m+            )))
(B[m         }
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:295:
         if let Some(shard) = shards.get(&shard_id) {
             Ok(shard.replica_nodes.clone())
         } else {
[31m-            Err(AgentMemError::memory_error(&format!("Shard {} not found", shard_id)))
(B[m[32m+            Err(AgentMemError::memory_error(&format!(
(B[m[32m+                "Shard {} not found",
(B[m[32m+                shard_id
(B[m[32m+            )))
(B[m         }
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:308:
             nodes.retain(|&id| id != Uuid::nil());
             Ok(nodes)
         } else {
[31m-            Err(AgentMemError::memory_error(&format!("Shard {} not found", shard_id)))
(B[m[32m+            Err(AgentMemError::memory_error(&format!(
(B[m[32m+                "Shard {} not found",
(B[m[32m+                shard_id
(B[m[32m+            )))
(B[m         }
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:315:
     /// Get shards assigned to a node
     pub async fn get_node_shards(&self, node_id: Uuid) -> Result<Vec<u32>> {
         let node_shards = self.node_shards.read().await;
[31m-        Ok(node_shards.get(&node_id).cloned().unwrap_or_default().into_iter().collect())
(B[m[32m+        Ok(node_shards
(B[m[32m+            .get(&node_id)
(B[m[32m+            .cloned()
(B[m[32m+            .unwrap_or_default()
(B[m[32m+            .into_iter()
(B[m[32m+            .collect())
(B[m     }
 
     /// Rebalance shards across nodes
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:334:
         // Reassign shards using consistent hashing
         for (shard_id, shard) in shards.iter_mut() {
             let shard_key = format!("shard_{}", shard_id);
[31m-            
(B[m[32m+
(B[m             if let Some(primary_node_id) = hash_ring.get_node(&shard_key) {
                 shard.primary_node = primary_node_id;
[31m-                
(B[m[32m+
(B[m                 // Add to node_shards mapping
[31m-                node_shards.entry(primary_node_id)
(B[m[32m+                node_shards
(B[m[32m+                    .entry(primary_node_id)
(B[m                     .or_insert_with(HashSet::new)
                     .insert(*shard_id);
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:350:
                     if let Some(replica_node_id) = hash_ring.get_node(&replica_key) {
                         if replica_node_id != primary_node_id {
                             shard.replica_nodes.push(replica_node_id);
[31m-                            node_shards.entry(replica_node_id)
(B[m[32m+                            node_shards
(B[m[32m+                                .entry(replica_node_id)
(B[m                                 .or_insert_with(HashSet::new)
                                 .insert(*shard_id);
                         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:367:
     async fn reassign_shards_from_node(&self, removed_node_id: Uuid) -> Result<()> {
         let mut shards = self.shards.write().await;
         let mut node_shards = self.node_shards.write().await;
[31m-        
(B[m[32m+
(B[m         // Remove node from mappings
         node_shards.remove(&removed_node_id);
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:387:
                 if let Some(new_primary) = shard.replica_nodes.first().cloned() {
                     shard.primary_node = new_primary;
                     shard.replica_nodes.remove(0);
[31m-                    
(B[m[31m-                    node_shards.entry(new_primary)
(B[m[32m+
(B[m[32m+                    node_shards
(B[m[32m+                        .entry(new_primary)
(B[m                         .or_insert_with(HashSet::new)
                         .insert(shard_id);
                 } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:406:
     /// Get shard information
     pub async fn get_shard_info(&self) -> Result<super::ShardInfo> {
         let shards = self.shards.read().await;
[31m-        
(B[m[32m+
(B[m         let local_shards = vec![]; // Would be populated with actual local shards
         let mut shard_distribution = HashMap::new();
[31m-        
(B[m[32m+
(B[m         for (shard_id, shard) in shards.iter() {
             let mut nodes = vec![shard.primary_node];
             nodes.extend(shard.replica_nodes.iter().cloned());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:425:
     }
 
     /// Update shard statistics
[31m-    pub async fn update_shard_stats(&self, shard_id: u32, data_size: u64, item_count: u64) -> Result<()> {
(B[m[32m+    pub async fn update_shard_stats(
(B[m[32m+        &self,
(B[m[32m+        shard_id: u32,
(B[m[32m+        data_size: u64,
(B[m[32m+        item_count: u64,
(B[m[32m+    ) -> Result<()> {
(B[m         let mut shards = self.shards.write().await;
         if let Some(shard) = shards.get_mut(&shard_id) {
             shard.data_size = data_size;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:452:
         let key1 = ShardKey::new("test_key".to_string());
         let key2 = ShardKey::new("test_key".to_string());
         let key3 = ShardKey::new("different_key".to_string());
[31m-        
(B[m[32m+
(B[m         assert_eq!(key1.hash(), key2.hash());
         assert_ne!(key1.hash(), key3.hash());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:461:
     async fn test_shard_assignment() {
         let config = ShardConfig::default();
         let manager = ShardManager::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let key = ShardKey::new("test_key".to_string());
         let shard_id = manager.get_shard_id(&key).await.unwrap();
[31m-        
(B[m[32m+
(B[m         assert!(shard_id < 256); // Default shard count
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-distributed/src/sharding.rs:472:
     async fn test_node_management() {
         let config = ShardConfig::default();
         let manager = ShardManager::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let node_id = Uuid::new_v4();
         manager.add_node(node_id, 100).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let node_shards = manager.get_node_shards(node_id).await.unwrap();
         // After rebalancing, node should have some shards assigned
         // (exact count depends on consistent hashing implementation)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/config.rs:9:
 pub struct EmbeddingConfig {
     /// 提供商名称 (openai, huggingface, local)
     pub provider: String,
[31m-    
(B[m[32m+
(B[m     /// 模型名称
     pub model: String,
[31m-    
(B[m[32m+
(B[m     /// API密钥（用于远程提供商）
     pub api_key: Option<String>,
[31m-    
(B[m[32m+
(B[m     /// 基础URL（用于自定义端点）
     pub base_url: Option<String>,
[31m-    
(B[m[32m+
(B[m     /// 嵌入维度
     pub dimension: usize,
[31m-    
(B[m[32m+
(B[m     /// 批处理大小
     pub batch_size: usize,
[31m-    
(B[m[32m+
(B[m     /// 请求超时时间（秒）
     pub timeout_seconds: u64,
[31m-    
(B[m[32m+
(B[m     /// 最大重试次数
     pub max_retries: u32,
[31m-    
(B[m[32m+
(B[m     /// 额外配置参数
     pub extra_params: HashMap<String, String>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/config.rs:116:
     pub fn local(model_path: &str, dimension: usize) -> Self {
         let mut extra_params = HashMap::new();
         extra_params.insert("model_path".to_string(), model_path.to_string());
[31m-        
(B[m[32m+
(B[m         Self {
             provider: "local".to_string(),
             model: "local".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/config.rs:133:
     /// 验证配置
     pub fn validate(&self) -> agent_mem_traits::Result<()> {
         if self.provider.is_empty() {
[31m-            return Err(agent_mem_traits::AgentMemError::config_error("Provider cannot be empty"));
(B[m[32m+            return Err(agent_mem_traits::AgentMemError::config_error(
(B[m[32m+                "Provider cannot be empty",
(B[m[32m+            ));
(B[m         }
 
         if self.model.is_empty() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/config.rs:140:
[31m-            return Err(agent_mem_traits::AgentMemError::config_error("Model cannot be empty"));
(B[m[32m+            return Err(agent_mem_traits::AgentMemError::config_error(
(B[m[32m+                "Model cannot be empty",
(B[m[32m+            ));
(B[m         }
 
         if self.dimension == 0 {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/config.rs:144:
[31m-            return Err(agent_mem_traits::AgentMemError::config_error("Dimension must be greater than 0"));
(B[m[32m+            return Err(agent_mem_traits::AgentMemError::config_error(
(B[m[32m+                "Dimension must be greater than 0",
(B[m[32m+            ));
(B[m         }
 
         if self.batch_size == 0 {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/config.rs:148:
[31m-            return Err(agent_mem_traits::AgentMemError::config_error("Batch size must be greater than 0"));
(B[m[32m+            return Err(agent_mem_traits::AgentMemError::config_error(
(B[m[32m+                "Batch size must be greater than 0",
(B[m[32m+            ));
(B[m         }
 
         // 验证提供商特定的配置
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/config.rs:152:
         match self.provider.as_str() {
             "openai" => {
                 if self.api_key.is_none() {
[31m-                    return Err(agent_mem_traits::AgentMemError::config_error("OpenAI provider requires an API key"));
(B[m[32m+                    return Err(agent_mem_traits::AgentMemError::config_error(
(B[m[32m+                        "OpenAI provider requires an API key",
(B[m[32m+                    ));
(B[m                 }
             }
             "local" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/config.rs:159:
                 if !self.extra_params.contains_key("model_path") {
[31m-                    return Err(agent_mem_traits::AgentMemError::config_error("Local provider requires model_path in extra_params"));
(B[m[32m+                    return Err(agent_mem_traits::AgentMemError::config_error(
(B[m[32m+                        "Local provider requires model_path in extra_params",
(B[m[32m+                    ));
(B[m                 }
             }
             _ => {} // 其他提供商暂时不需要特殊验证
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:1:
 //! 嵌入模型工厂模式实现
 
 use crate::config::EmbeddingConfig;
[31m-use crate::providers::{OpenAIEmbedder, HuggingFaceEmbedder, LocalEmbedder, AnthropicEmbedder, CohereEmbedder};
(B[m[31m-use agent_mem_traits::{Embedder, Result, AgentMemError};
(B[m[32m+use crate::providers::{
(B[m[32m+    AnthropicEmbedder, CohereEmbedder, HuggingFaceEmbedder, LocalEmbedder, OpenAIEmbedder,
(B[m[32m+};
(B[m[32m+use agent_mem_traits::{AgentMemError, Embedder, Result};
(B[m use async_trait::async_trait;
 use std::sync::Arc;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:107:
 
 impl EmbeddingFactory {
     /// 根据配置创建嵌入器实例
[31m-    pub async fn create_embedder(config: &EmbeddingConfig) -> Result<Arc<dyn Embedder + Send + Sync>> {
(B[m[32m+    pub async fn create_embedder(
(B[m[32m+        config: &EmbeddingConfig,
(B[m[32m+    ) -> Result<Arc<dyn Embedder + Send + Sync>> {
(B[m         // 验证配置
         config.validate()?;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:124:
                 }
                 #[cfg(not(feature = "huggingface"))]
                 {
[31m-                    return Err(AgentMemError::unsupported_provider("HuggingFace feature not enabled"));
(B[m[32m+                    return Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "HuggingFace feature not enabled",
(B[m[32m+                    ));
(B[m                 }
             }
             "local" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:135:
                 }
                 #[cfg(not(feature = "local"))]
                 {
[31m-                    return Err(AgentMemError::unsupported_provider("Local feature not enabled"));
(B[m[32m+                    return Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Local feature not enabled",
(B[m[32m+                    ));
(B[m                 }
             }
             "anthropic" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:146:
                 }
                 #[cfg(not(feature = "anthropic"))]
                 {
[31m-                    return Err(AgentMemError::unsupported_provider("Anthropic feature not enabled"));
(B[m[32m+                    return Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Anthropic feature not enabled",
(B[m[32m+                    ));
(B[m                 }
             }
             "cohere" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:157:
                 }
                 #[cfg(not(feature = "cohere"))]
                 {
[31m-                    return Err(AgentMemError::unsupported_provider("Cohere feature not enabled"));
(B[m[32m+                    return Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Cohere feature not enabled",
(B[m[32m+                    ));
(B[m                 }
             }
             _ => return Err(AgentMemError::unsupported_provider(&config.provider)),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:193:
     }
 
     /// 创建默认的OpenAI嵌入器
[31m-    pub async fn create_openai_embedder(api_key: String) -> Result<Arc<dyn Embedder + Send + Sync>> {
(B[m[32m+    pub async fn create_openai_embedder(
(B[m[32m+        api_key: String,
(B[m[32m+    ) -> Result<Arc<dyn Embedder + Send + Sync>> {
(B[m         let config = EmbeddingConfig::openai(Some(api_key));
         Self::create_embedder(&config).await
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:212:
 
     /// 创建HuggingFace嵌入器
     #[cfg(feature = "huggingface")]
[31m-    pub async fn create_huggingface_embedder(model: &str) -> Result<Arc<dyn Embedder + Send + Sync>> {
(B[m[32m+    pub async fn create_huggingface_embedder(
(B[m[32m+        model: &str,
(B[m[32m+    ) -> Result<Arc<dyn Embedder + Send + Sync>> {
(B[m         let config = EmbeddingConfig::huggingface(model);
         Self::create_embedder(&config).await
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:219:
 
     /// 创建本地嵌入器
     #[cfg(feature = "local")]
[31m-    pub async fn create_local_embedder(model_path: &str, dimension: usize) -> Result<Arc<dyn Embedder + Send + Sync>> {
(B[m[32m+    pub async fn create_local_embedder(
(B[m[32m+        model_path: &str,
(B[m[32m+        dimension: usize,
(B[m[32m+    ) -> Result<Arc<dyn Embedder + Send + Sync>> {
(B[m         let config = EmbeddingConfig::local(model_path, dimension);
         Self::create_embedder(&config).await
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:226:
 
     /// 创建Anthropic嵌入器
     #[cfg(feature = "anthropic")]
[31m-    pub async fn create_anthropic_embedder(api_key: String) -> Result<Arc<dyn Embedder + Send + Sync>> {
(B[m[32m+    pub async fn create_anthropic_embedder(
(B[m[32m+        api_key: String,
(B[m[32m+    ) -> Result<Arc<dyn Embedder + Send + Sync>> {
(B[m         let config = EmbeddingConfig {
             provider: "anthropic".to_string(),
             model: "claude-embedding".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:239:
 
     /// 创建Cohere嵌入器
     #[cfg(feature = "cohere")]
[31m-    pub async fn create_cohere_embedder(api_key: String, model: Option<&str>) -> Result<Arc<dyn Embedder + Send + Sync>> {
(B[m[32m+    pub async fn create_cohere_embedder(
(B[m[32m+        api_key: String,
(B[m[32m+        model: Option<&str>,
(B[m[32m+    ) -> Result<Arc<dyn Embedder + Send + Sync>> {
(B[m         let config = EmbeddingConfig {
             provider: "cohere".to_string(),
             model: model.unwrap_or("embed-english-v3.0").to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:254:
     /// 从环境变量创建嵌入器
     pub async fn from_env() -> Result<Arc<dyn Embedder + Send + Sync>> {
         let provider = std::env::var("EMBEDDING_PROVIDER").unwrap_or_else(|_| "openai".to_string());
[31m-        
(B[m[32m+
(B[m         match provider.as_str() {
             "openai" => {
[31m-                let api_key = std::env::var("OPENAI_API_KEY")
(B[m[31m-                    .map_err(|_| AgentMemError::config_error("OPENAI_API_KEY environment variable not set"))?;
(B[m[32m+                let api_key = std::env::var("OPENAI_API_KEY").map_err(|_| {
(B[m[32m+                    AgentMemError::config_error("OPENAI_API_KEY environment variable not set")
(B[m[32m+                })?;
(B[m                 Self::create_openai_embedder(api_key).await
             }
             "huggingface" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:270:
                 }
                 #[cfg(not(feature = "huggingface"))]
                 {
[31m-                    Err(AgentMemError::unsupported_provider("HuggingFace feature not enabled"))
(B[m[32m+                    Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "HuggingFace feature not enabled",
(B[m[32m+                    ))
(B[m                 }
             }
             "local" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:277:
                 #[cfg(feature = "local")]
                 {
[31m-                    let model_path = std::env::var("LOCAL_MODEL_PATH")
(B[m[31m-                        .map_err(|_| AgentMemError::config_error("LOCAL_MODEL_PATH environment variable not set"))?;
(B[m[32m+                    let model_path = std::env::var("LOCAL_MODEL_PATH").map_err(|_| {
(B[m[32m+                        AgentMemError::config_error("LOCAL_MODEL_PATH environment variable not set")
(B[m[32m+                    })?;
(B[m                     let dimension = std::env::var("LOCAL_MODEL_DIMENSION")
                         .unwrap_or_else(|_| "768".to_string())
                         .parse::<usize>()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:284:
[31m-                        .map_err(|_| AgentMemError::config_error("Invalid LOCAL_MODEL_DIMENSION"))?;
(B[m[32m+                        .map_err(|_| {
(B[m[32m+                            AgentMemError::config_error("Invalid LOCAL_MODEL_DIMENSION")
(B[m[32m+                        })?;
(B[m                     Self::create_local_embedder(&model_path, dimension).await
                 }
                 #[cfg(not(feature = "local"))]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:288:
                 {
[31m-                    Err(AgentMemError::unsupported_provider("Local feature not enabled"))
(B[m[32m+                    Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Local feature not enabled",
(B[m[32m+                    ))
(B[m                 }
             }
             "anthropic" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:293:
                 #[cfg(feature = "anthropic")]
                 {
[31m-                    let api_key = std::env::var("ANTHROPIC_API_KEY")
(B[m[31m-                        .map_err(|_| AgentMemError::config_error("ANTHROPIC_API_KEY environment variable not set"))?;
(B[m[32m+                    let api_key = std::env::var("ANTHROPIC_API_KEY").map_err(|_| {
(B[m[32m+                        AgentMemError::config_error(
(B[m[32m+                            "ANTHROPIC_API_KEY environment variable not set",
(B[m[32m+                        )
(B[m[32m+                    })?;
(B[m                     Self::create_anthropic_embedder(api_key).await
                 }
                 #[cfg(not(feature = "anthropic"))]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:300:
                 {
[31m-                    Err(AgentMemError::unsupported_provider("Anthropic feature not enabled"))
(B[m[32m+                    Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Anthropic feature not enabled",
(B[m[32m+                    ))
(B[m                 }
             }
             "cohere" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:305:
                 #[cfg(feature = "cohere")]
                 {
[31m-                    let api_key = std::env::var("COHERE_API_KEY")
(B[m[31m-                        .map_err(|_| AgentMemError::config_error("COHERE_API_KEY environment variable not set"))?;
(B[m[32m+                    let api_key = std::env::var("COHERE_API_KEY").map_err(|_| {
(B[m[32m+                        AgentMemError::config_error("COHERE_API_KEY environment variable not set")
(B[m[32m+                    })?;
(B[m                     let model = std::env::var("COHERE_MODEL").ok();
                     Self::create_cohere_embedder(api_key, model.as_deref()).await
                 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:312:
                 #[cfg(not(feature = "cohere"))]
                 {
[31m-                    Err(AgentMemError::unsupported_provider("Cohere feature not enabled"))
(B[m[32m+                    Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Cohere feature not enabled",
(B[m[32m+                    ))
(B[m                 }
             }
             _ => Err(AgentMemError::unsupported_provider(&provider)),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:333:
     #[test]
     fn test_is_provider_supported() {
         assert!(EmbeddingFactory::is_provider_supported("openai"));
[31m-        assert!(!EmbeddingFactory::is_provider_supported("unsupported_provider"));
(B[m[32m+        assert!(!EmbeddingFactory::is_provider_supported(
(B[m[32m+            "unsupported_provider"
(B[m[32m+        ));
(B[m     }
 
     #[test]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/factory.rs:342:
             provider: "unsupported".to_string(),
             ..Default::default()
         };
[31m-        
(B[m[32m+
(B[m         let rt = tokio::runtime::Runtime::new().unwrap();
         let result = rt.block_on(EmbeddingFactory::create_embedder(&config));
         assert!(result.is_err());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/lib.rs:1:
 //! # Agent Memory Embeddings
[31m-//! 
(B[m[32m+//!
(B[m //! 嵌入模型模块，为AgentMem记忆平台提供多种嵌入模型支持。
[31m-//! 
(B[m[32m+//!
(B[m //! 本模块提供：
 //! - 统一的嵌入接口抽象
 //! - 多种嵌入提供商支持（OpenAI、HuggingFace、本地模型）
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/lib.rs:9:
 //! - 嵌入工厂模式
 //! - 特性门控支持
 
[32m+pub mod config;
(B[m pub mod factory;
 pub mod providers;
[31m-pub mod config;
(B[m pub mod utils;
 
[31m-pub use factory::EmbeddingFactory;
(B[m pub use config::EmbeddingConfig;
[32m+pub use factory::EmbeddingFactory;
(B[m 
 // 重新导出常用类型
[31m-pub use agent_mem_traits::{Embedder, Result, AgentMemError};
(B[m[32m+pub use agent_mem_traits::{AgentMemError, Embedder, Result};
(B[m 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/anthropic.rs:1:
 //! Anthropic嵌入模型实现（模拟）
 //! 注意：Anthropic目前主要专注于文本生成，这里提供一个模拟实现
 
[31m-use agent_mem_traits::{Embedder, Result, AgentMemError};
(B[m use crate::config::EmbeddingConfig;
[32m+use agent_mem_traits::{AgentMemError, Embedder, Result};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/anthropic.rs:47:
 impl AnthropicEmbedder {
     /// 创建新的Anthropic嵌入器实例
     pub async fn new(config: EmbeddingConfig) -> Result<Self> {
[31m-        let api_key = config.api_key.clone()
(B[m[32m+        let api_key = config
(B[m[32m+            .api_key
(B[m[32m+            .clone()
(B[m             .ok_or_else(|| AgentMemError::config_error("Anthropic API key is required"))?;
 
         let client = Client::builder()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/anthropic.rs:54:
             .timeout(Duration::from_secs(30))
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(format!("Failed to create HTTP client: {}", e)))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m 
         Ok(Self {
             config,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/anthropic.rs:76:
         // 模拟实现：返回基于文本内容的确定性向量
         // 在实际实现中，这里应该调用Anthropic的嵌入API
         let mut embedding = vec![0.0; self.dimension()];
[31m-        
(B[m[32m+
(B[m         // 基于文本内容生成确定性向量
         let bytes = text.as_bytes();
         for (i, &byte) in bytes.iter().enumerate() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/anthropic.rs:84:
                 embedding[i] = (byte as f32) / 255.0;
             }
         }
[31m-        
(B[m[32m+
(B[m         // 标准化向量
         let norm: f32 = embedding.iter().map(|x| x * x).sum::<f32>().sqrt();
         if norm > 0.0 {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/anthropic.rs:92:
                 *x /= norm;
             }
         }
[31m-        
(B[m[32m+
(B[m         Ok(embedding)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/anthropic.rs:171:
 
         let embedder = AnthropicEmbedder::new(config).await.unwrap();
         let result = embedder.embed("Hello, world!").await;
[31m-        
(B[m[32m+
(B[m         assert!(result.is_ok());
         let embedding = result.unwrap();
         assert_eq!(embedding.len(), 768);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/anthropic.rs:178:
[31m-        
(B[m[32m+
(B[m         // 检查向量是否已标准化
         let norm: f32 = embedding.iter().map(|x| x * x).sum::<f32>().sqrt();
         assert!((norm - 1.0).abs() < 1e-6);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/anthropic.rs:192:
         };
 
         let embedder = AnthropicEmbedder::new(config).await.unwrap();
[31m-        let texts = vec![
(B[m[31m-            "First text".to_string(),
(B[m[31m-            "Second text".to_string(),
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+        let texts = vec!["First text".to_string(), "Second text".to_string()];
(B[m[32m+
(B[m         let result = embedder.embed_batch(&texts).await;
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let embeddings = result.unwrap();
         assert_eq!(embeddings.len(), 2);
         assert_eq!(embeddings[0].len(), 384);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/anthropic.rs:233:
         };
 
         let embedder = AnthropicEmbedder::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         // 相同的文本应该产生相同的嵌入
         let embedding1 = embedder.embed("test text").await.unwrap();
         let embedding2 = embedder.embed("test text").await.unwrap();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/anthropic.rs:240:
[31m-        
(B[m[32m+
(B[m         assert_eq!(embedding1, embedding2);
[31m-        
(B[m[32m+
(B[m         // 不同的文本应该产生不同的嵌入
         let embedding3 = embedder.embed("different text").await.unwrap();
         assert_ne!(embedding1, embedding3);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/cohere.rs:1:
 //! Cohere嵌入模型实现
 
[31m-use agent_mem_traits::{Embedder, Result, AgentMemError};
(B[m use crate::config::EmbeddingConfig;
[32m+use agent_mem_traits::{AgentMemError, Embedder, Result};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/cohere.rs:54:
 impl CohereEmbedder {
     /// 创建新的Cohere嵌入器实例
     pub async fn new(config: EmbeddingConfig) -> Result<Self> {
[31m-        let api_key = config.api_key.clone()
(B[m[32m+        let api_key = config
(B[m[32m+            .api_key
(B[m[32m+            .clone()
(B[m             .ok_or_else(|| AgentMemError::config_error("Cohere API key is required"))?;
 
[31m-        let base_url = config.base_url.clone()
(B[m[32m+        let base_url = config
(B[m[32m+            .base_url
(B[m[32m+            .clone()
(B[m             .unwrap_or_else(|| "https://api.cohere.ai/v1".to_string());
 
         let client = Client::builder()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/cohere.rs:64:
             .timeout(Duration::from_secs(30))
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(format!("Failed to create HTTP client: {}", e)))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m 
         let embedder = Self {
             config,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/cohere.rs:94:
         };
 
         let url = format!("{}/embed", self.base_url);
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Authorization", format!("Bearer {}", self.api_key))
             .header("Content-Type", "application/json")
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/cohere.rs:105:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::network_error(format!(
[31m-                "Cohere API error {}: {}", status, error_text
(B[m[32m+                "Cohere API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/cohere.rs:115:
[31m-        let embedding_response: CohereEmbeddingResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let embedding_response: CohereEmbeddingResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         Ok(embedding_response.embeddings)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/cohere.rs:123:
 impl Embedder for CohereEmbedder {
     async fn embed(&self, text: &str) -> Result<Vec<f32>> {
         let embeddings = self.embed_internal(&[text.to_string()]).await?;
[31m-        embeddings.into_iter().next()
(B[m[32m+        embeddings
(B[m[32m+            .into_iter()
(B[m[32m+            .next()
(B[m             .ok_or_else(|| AgentMemError::parsing_error("No embedding returned"))
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/cohere.rs:130:
     async fn embed_batch(&self, texts: &[String]) -> Result<Vec<Vec<f32>>> {
         // Cohere支持批量嵌入，但有限制
         const MAX_BATCH_SIZE: usize = 96;
[31m-        
(B[m[32m+
(B[m         if texts.len() <= MAX_BATCH_SIZE {
             self.embed_internal(texts).await
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/cohere.rs:257:
     fn test_batch_size_calculation() {
         // 测试批量处理逻辑
         let texts: Vec<String> = (0..200).map(|i| format!("text {}", i)).collect();
[31m-        
(B[m[32m+
(B[m         // 模拟分批处理
         const MAX_BATCH_SIZE: usize = 96;
         let chunks: Vec<_> = texts.chunks(MAX_BATCH_SIZE).collect();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/cohere.rs:264:
[31m-        
(B[m[32m+
(B[m         assert_eq!(chunks.len(), 3); // 200 / 96 = 2.08, 所以需要3批
         assert_eq!(chunks[0].len(), 96);
         assert_eq!(chunks[1].len(), 96);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/huggingface.rs:1:
 //! HuggingFace嵌入提供商实现
 
 use crate::config::EmbeddingConfig;
[31m-use agent_mem_traits::{Embedder, Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Embedder, Result};
(B[m use async_trait::async_trait;
 
 /// HuggingFace嵌入提供商
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/huggingface.rs:15:
     pub async fn new(config: EmbeddingConfig) -> Result<Self> {
         // 验证模型名称
         if config.model.is_empty() {
[31m-            return Err(AgentMemError::config_error("HuggingFace model name is required"));
(B[m[32m+            return Err(AgentMemError::config_error(
(B[m[32m+                "HuggingFace model name is required",
(B[m[32m+            ));
(B[m         }
 
         Ok(Self { config })
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/huggingface.rs:39:
 
     async fn embed_batch(&self, texts: &[String]) -> Result<Vec<Vec<f32>>> {
         let mut embeddings = Vec::new();
[31m-        
(B[m[32m+
(B[m         // 简单的顺序处理，实际实现应该支持批量处理
         for text in texts {
             let embedding = self.embed(text).await?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/huggingface.rs:46:
             embeddings.push(embedding);
         }
[31m-        
(B[m[32m+
(B[m         Ok(embeddings)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/huggingface.rs:76:
         let config = EmbeddingConfig::huggingface("sentence-transformers/all-MiniLM-L6-v2");
         let result = HuggingFaceEmbedder::new(config).await;
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let embedder = result.unwrap();
         assert_eq!(embedder.provider_name(), "huggingface");
[31m-        assert_eq!(embedder.model_name(), "sentence-transformers/all-MiniLM-L6-v2");
(B[m[32m+        assert_eq!(
(B[m[32m+            embedder.model_name(),
(B[m[32m+            "sentence-transformers/all-MiniLM-L6-v2"
(B[m[32m+        );
(B[m         assert_eq!(embedder.dimension(), 768);
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/huggingface.rs:90:
             model: "".to_string(),
             ..Default::default()
         };
[31m-        
(B[m[32m+
(B[m         let result = HuggingFaceEmbedder::new(config).await;
         assert!(result.is_err());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/huggingface.rs:99:
     async fn test_embed_single_text() {
         let config = EmbeddingConfig::huggingface("sentence-transformers/all-MiniLM-L6-v2");
         let embedder = HuggingFaceEmbedder::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let result = embedder.embed("test text").await;
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let embedding = result.unwrap();
         assert_eq!(embedding.len(), 768);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/huggingface.rs:111:
     async fn test_embed_batch() {
         let config = EmbeddingConfig::huggingface("sentence-transformers/all-MiniLM-L6-v2");
         let embedder = HuggingFaceEmbedder::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let texts = vec![
             "first text".to_string(),
             "second text".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/huggingface.rs:118:
             "third text".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let result = embedder.embed_batch(&texts).await;
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let embeddings = result.unwrap();
         assert_eq!(embeddings.len(), 3);
         assert_eq!(embeddings[0].len(), 768);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/huggingface.rs:132:
     async fn test_health_check() {
         let config = EmbeddingConfig::huggingface("sentence-transformers/all-MiniLM-L6-v2");
         let embedder = HuggingFaceEmbedder::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let result = embedder.health_check().await;
         assert!(result.is_ok());
         assert_eq!(result.unwrap(), true);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:1:
 //! 本地嵌入提供商实现
 
 use crate::config::EmbeddingConfig;
[31m-use agent_mem_traits::{Embedder, Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Embedder, Result};
(B[m use async_trait::async_trait;
 use std::path::Path;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:15:
 impl LocalEmbedder {
     /// 创建新的本地嵌入器实例
     pub async fn new(config: EmbeddingConfig) -> Result<Self> {
[31m-        let model_path = config.get_model_path()
(B[m[32m+        let model_path = config
(B[m[32m+            .get_model_path()
(B[m             .ok_or_else(|| AgentMemError::config_error("Local model path is required"))?
             .to_string();
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:22:
         // 验证模型路径是否存在
         if !Path::new(&model_path).exists() {
             return Err(AgentMemError::config_error(format!(
[31m-                "Model path does not exist: {}", model_path
(B[m[32m+                "Model path does not exist: {}",
(B[m[32m+                model_path
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:29:
[31m-        Ok(Self {
(B[m[31m-            config,
(B[m[31m-            model_path,
(B[m[31m-        })
(B[m[32m+        Ok(Self { config, model_path })
(B[m     }
 
     /// 加载本地模型（模拟实现）
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:53:
     /// 批量处理文本（优化版本）
     async fn process_batch(&self, texts: &[String]) -> Result<Vec<Vec<f32>>> {
         let mut embeddings = Vec::new();
[31m-        
(B[m[32m+
(B[m         // 实际实现应该支持真正的批量推理以提高效率
         for text in texts {
             let embedding = self.generate_embedding_with_model(text).await?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:60:
             embeddings.push(embedding);
         }
[31m-        
(B[m[32m+
(B[m         Ok(embeddings)
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:116:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    use tempfile::tempdir;
(B[m     use std::fs::File;
[32m+    use tempfile::tempdir;
(B[m 
     #[tokio::test]
     async fn test_local_embedder_creation_missing_path() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:136:
         let config = EmbeddingConfig::local(model_path.to_str().unwrap(), 384);
         let result = LocalEmbedder::new(config).await;
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let embedder = result.unwrap();
         assert_eq!(embedder.provider_name(), "local");
         assert_eq!(embedder.model_name(), "local");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:151:
 
         let config = EmbeddingConfig::local(model_path.to_str().unwrap(), 384);
         let embedder = LocalEmbedder::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let result = embedder.embed("test text").await;
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let embedding = result.unwrap();
         assert_eq!(embedding.len(), 384);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:167:
 
         let config = EmbeddingConfig::local(model_path.to_str().unwrap(), 256);
         let embedder = LocalEmbedder::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let texts = vec![
             "first text".to_string(),
             "second text".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:174:
             "third text".to_string(),
         ];
[31m-        
(B[m[32m+
(B[m         let result = embedder.embed_batch(&texts).await;
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let embeddings = result.unwrap();
         assert_eq!(embeddings.len(), 3);
         assert_eq!(embeddings[0].len(), 256);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:192:
 
         let config = EmbeddingConfig::local(model_path.to_str().unwrap(), 128);
         let embedder = LocalEmbedder::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let result = embedder.embed_batch(&[]).await;
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let embeddings = result.unwrap();
         assert_eq!(embeddings.len(), 0);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:208:
 
         let config = EmbeddingConfig::local(model_path.to_str().unwrap(), 128);
         let embedder = LocalEmbedder::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let result = embedder.health_check().await;
         assert!(result.is_ok());
         assert_eq!(result.unwrap(), true);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/local.rs:222:
 
         let config = EmbeddingConfig::local(model_path.to_str().unwrap(), 128);
         let embedder = LocalEmbedder::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         // 删除模型文件
         std::fs::remove_file(&model_path).unwrap();
[31m-        
(B[m[32m+
(B[m         let result = embedder.health_check().await;
         assert!(result.is_ok());
         assert_eq!(result.unwrap(), false);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/mod.rs:1:
 //! 嵌入提供商实现模块
 
[31m-pub mod openai;
(B[m[31m-pub mod huggingface;
(B[m[31m-pub mod local;
(B[m pub mod anthropic;
 pub mod cohere;
[32m+pub mod huggingface;
(B[m[32m+pub mod local;
(B[m[32m+pub mod openai;
(B[m 
[31m-pub use openai::OpenAIEmbedder;
(B[m[31m-pub use huggingface::HuggingFaceEmbedder;
(B[m[31m-pub use local::LocalEmbedder;
(B[m pub use anthropic::AnthropicEmbedder;
 pub use cohere::CohereEmbedder;
[32m+pub use huggingface::HuggingFaceEmbedder;
(B[m[32m+pub use local::LocalEmbedder;
(B[m[32m+pub use openai::OpenAIEmbedder;
(B[m 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/openai.rs:1:
 //! OpenAI嵌入提供商实现
 
 use crate::config::EmbeddingConfig;
[31m-use agent_mem_traits::{Embedder, Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Embedder, Result};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/openai.rs:51:
 impl OpenAIEmbedder {
     /// 创建新的OpenAI嵌入器实例
     pub async fn new(config: EmbeddingConfig) -> Result<Self> {
[31m-        let api_key = config.api_key.clone()
(B[m[32m+        let api_key = config
(B[m[32m+            .api_key
(B[m[32m+            .clone()
(B[m             .ok_or_else(|| AgentMemError::config_error("OpenAI API key is required"))?;
 
[31m-        let base_url = config.base_url.clone()
(B[m[32m+        let base_url = config
(B[m[32m+            .base_url
(B[m[32m+            .clone()
(B[m             .unwrap_or_else(|| "https://api.openai.com/v1".to_string());
 
         let client = Client::builder()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/openai.rs:61:
             .timeout(Duration::from_secs(config.timeout_seconds))
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(format!("Failed to create HTTP client: {}", e)))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m 
         Ok(Self {
             config,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/openai.rs:84:
         };
 
         let url = format!("{}/embeddings", self.base_url);
[31m-        
(B[m[32m+
(B[m         let mut retries = 0;
         loop {
[31m-            let response = self.client
(B[m[32m+            let response = self
(B[m[32m+                .client
(B[m                 .post(&url)
                 .header("Authorization", format!("Bearer {}", self.api_key))
                 .header("Content-Type", "application/json")
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/openai.rs:98:
             match response {
                 Ok(resp) => {
                     if resp.status().is_success() {
[31m-                        let embedding_response: OpenAIEmbeddingResponse = resp.json().await
(B[m[31m-                            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+                        let embedding_response: OpenAIEmbeddingResponse =
(B[m[32m+                            resp.json().await.map_err(|e| {
(B[m[32m+                                AgentMemError::parsing_error(format!(
(B[m[32m+                                    "Failed to parse response: {}",
(B[m[32m+                                    e
(B[m[32m+                                ))
(B[m[32m+                            })?;
(B[m 
                         // 按索引排序并提取嵌入向量
[31m-                        let mut embeddings: Vec<(usize, Vec<f32>)> = embedding_response.data
(B[m[32m+                        let mut embeddings: Vec<(usize, Vec<f32>)> = embedding_response
(B[m[32m+                            .data
(B[m                             .into_iter()
                             .map(|data| (data.index, data.embedding))
                             .collect();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/openai.rs:109:
[31m-                        
(B[m[32m+
(B[m                         embeddings.sort_by_key(|(index, _)| *index);
[31m-                        
(B[m[32m+
(B[m                         let result: Vec<Vec<f32>> = embeddings
                             .into_iter()
                             .map(|(_, embedding)| embedding)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/openai.rs:117:
                         return Ok(result);
                     } else {
                         let status = resp.status();
[31m-                        let error_text = resp.text().await
(B[m[32m+                        let error_text = resp
(B[m[32m+                            .text()
(B[m[32m+                            .await
(B[m                             .unwrap_or_else(|_| "Unknown error".to_string());
[31m-                        
(B[m[31m-                        if retries < self.config.max_retries && (status.is_server_error() || status == 429) {
(B[m[32m+
(B[m[32m+                        if retries < self.config.max_retries
(B[m[32m+                            && (status.is_server_error() || status == 429)
(B[m[32m+                        {
(B[m                             retries += 1;
                             let delay = Duration::from_millis(1000 * (1 << retries)); // 指数退避
                             tokio::time::sleep(delay).await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/openai.rs:127:
                             continue;
                         }
[31m-                        
(B[m[32m+
(B[m                         return Err(AgentMemError::llm_error(format!(
[31m-                            "OpenAI API error {}: {}", status, error_text
(B[m[32m+                            "OpenAI API error {}: {}",
(B[m[32m+                            status, error_text
(B[m                         )));
                     }
                 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/openai.rs:139:
                         tokio::time::sleep(delay).await;
                         continue;
                     }
[31m-                    
(B[m[31m-                    return Err(AgentMemError::network_error(format!("Request failed: {}", e)));
(B[m[32m+
(B[m[32m+                    return Err(AgentMemError::network_error(format!(
(B[m[32m+                        "Request failed: {}",
(B[m[32m+                        e
(B[m[32m+                    )));
(B[m                 }
             }
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/openai.rs:148:
 
     /// 将文本分批处理
     fn split_into_batches(&self, texts: &[String]) -> Vec<Vec<String>> {
[31m-        texts.chunks(self.config.batch_size)
(B[m[32m+        texts
(B[m[32m+            .chunks(self.config.batch_size)
(B[m             .map(|chunk| chunk.to_vec())
             .collect()
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/openai.rs:158:
 impl Embedder for OpenAIEmbedder {
     async fn embed(&self, text: &str) -> Result<Vec<f32>> {
         let results = self.embed_batch(&[text.to_string()]).await?;
[31m-        results.into_iter().next()
(B[m[32m+        results
(B[m[32m+            .into_iter()
(B[m[32m+            .next()
(B[m             .ok_or_else(|| AgentMemError::llm_error("No embedding returned"))
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/providers/openai.rs:226:
 
         let result = OpenAIEmbedder::new(config).await;
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let embedder = result.unwrap();
         assert_eq!(embedder.provider_name(), "openai");
         assert_eq!(embedder.model_name(), "text-embedding-ada-002");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:1:
 //! 嵌入工具函数
 
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m 
 /// 嵌入工具集
 pub struct EmbeddingUtils;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:19:
     }
 
     /// 批量验证嵌入向量的维度
[31m-    pub fn validate_embeddings_dimension(embeddings: &[Vec<f32>], expected_dim: usize) -> Result<()> {
(B[m[32m+    pub fn validate_embeddings_dimension(
(B[m[32m+        embeddings: &[Vec<f32>],
(B[m[32m+        expected_dim: usize,
(B[m[32m+    ) -> Result<()> {
(B[m         for (i, embedding) in embeddings.iter().enumerate() {
             if embedding.len() != expected_dim {
                 return Err(AgentMemError::validation_error(format!(
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:37:
     pub fn normalize_embedding(embedding: &mut [f32]) -> Result<()> {
         let norm = Self::l2_norm(embedding);
         if norm == 0.0 {
[31m-            return Err(AgentMemError::validation_error("Cannot normalize zero embedding"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Cannot normalize zero embedding",
(B[m[32m+            ));
(B[m         }
[31m-        
(B[m[32m+
(B[m         for value in embedding.iter_mut() {
             *value /= norm;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:46:
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:63:
     /// 计算两个嵌入向量的余弦相似度
     pub fn cosine_similarity(a: &[f32], b: &[f32]) -> Result<f32> {
         if a.len() != b.len() {
[31m-            return Err(AgentMemError::validation_error("Embedding dimensions must match"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Embedding dimensions must match",
(B[m[32m+            ));
(B[m         }
 
         let dot_product: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:80:
     /// 计算嵌入向量的平均值
     pub fn average_embeddings(embeddings: &[Vec<f32>]) -> Result<Vec<f32>> {
         if embeddings.is_empty() {
[31m-            return Err(AgentMemError::validation_error("Cannot average empty embedding list"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Cannot average empty embedding list",
(B[m[32m+            ));
(B[m         }
 
         let dimension = embeddings[0].len();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:127:
         }
 
         let mean = sum / embedding.len() as f32;
[31m-        let variance = embedding.iter()
(B[m[31m-            .map(|&x| (x - mean).powi(2))
(B[m[31m-            .sum::<f32>() / embedding.len() as f32;
(B[m[32m+        let variance =
(B[m[32m+            embedding.iter().map(|&x| (x - mean).powi(2)).sum::<f32>() / embedding.len() as f32;
(B[m 
         EmbeddingStats {
             dimension: embedding.len(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:152:
 
         for word in words {
             let word_tokens = Self::estimate_tokens(word);
[31m-            
(B[m[32m+
(B[m             if current_tokens + word_tokens > max_tokens && !current_chunk.is_empty() {
                 chunks.push(current_chunk.join(" "));
                 current_chunk.clear();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:159:
                 current_tokens = 0;
             }
[31m-            
(B[m[32m+
(B[m             current_chunk.push(word);
             current_tokens += word_tokens;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:185:
     pub fn create_random_embedding(dimension: usize) -> Vec<f32> {
         use std::collections::hash_map::DefaultHasher;
         use std::hash::{Hash, Hasher};
[31m-        
(B[m[32m+
(B[m         let mut hasher = DefaultHasher::new();
         dimension.hash(&mut hasher);
         let seed = hasher.finish();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:192:
[31m-        
(B[m[32m+
(B[m         // 使用简单的线性同余生成器
         let mut rng = seed;
         (0..dimension)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:242:
     fn test_normalize_embedding() {
         let mut embedding = vec![3.0, 4.0];
         EmbeddingUtils::normalize_embedding(&mut embedding).unwrap();
[31m-        
(B[m[32m+
(B[m         // 3-4-5三角形，标准化后应该是[0.6, 0.8]
         assert!((embedding[0] - 0.6).abs() < 1e-6);
         assert!((embedding[1] - 0.8).abs() < 1e-6);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:249:
[31m-        
(B[m[32m+
(B[m         // 验证L2范数为1
         let norm = EmbeddingUtils::l2_norm(&embedding);
         assert!((norm - 1.0).abs() < 1e-6);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:267:
 
     #[test]
     fn test_average_embeddings() {
[31m-        let embeddings = vec![
(B[m[31m-            vec![1.0, 2.0],
(B[m[31m-            vec![3.0, 4.0],
(B[m[31m-            vec![5.0, 6.0],
(B[m[31m-        ];
(B[m[32m+        let embeddings = vec![vec![1.0, 2.0], vec![3.0, 4.0], vec![5.0, 6.0]];
(B[m         let result = EmbeddingUtils::average_embeddings(&embeddings).unwrap();
         assert_eq!(result, vec![3.0, 4.0]);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:280:
     fn test_is_zero_embedding() {
         let zero_embedding = vec![0.0, 0.0, 0.0];
         assert!(EmbeddingUtils::is_zero_embedding(&zero_embedding, 1e-6));
[31m-        
(B[m[32m+
(B[m         let non_zero_embedding = vec![0.0, 0.0, 0.1];
[31m-        assert!(!EmbeddingUtils::is_zero_embedding(&non_zero_embedding, 1e-6));
(B[m[32m+        assert!(!EmbeddingUtils::is_zero_embedding(
(B[m[32m+            &non_zero_embedding,
(B[m[32m+            1e-6
(B[m[32m+        ));
(B[m     }
 
     #[test]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:289:
     fn test_embedding_stats() {
         let embedding = vec![1.0, 2.0, 3.0, 4.0, 5.0];
         let stats = EmbeddingUtils::embedding_stats(&embedding);
[31m-        
(B[m[32m+
(B[m         assert_eq!(stats.dimension, 5);
         assert_eq!(stats.min, 1.0);
         assert_eq!(stats.max, 5.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:300:
     fn test_split_text_for_embedding() {
         let text = "This is a long text that needs to be split into smaller chunks for embedding";
         let chunks = EmbeddingUtils::split_text_for_embedding(text, 20);
[31m-        
(B[m[32m+
(B[m         assert!(!chunks.is_empty());
         for chunk in &chunks {
             let estimated_tokens = EmbeddingUtils::estimate_tokens(chunk);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:319:
     fn test_create_random_embedding() {
         let embedding = EmbeddingUtils::create_random_embedding(10);
         assert_eq!(embedding.len(), 10);
[31m-        
(B[m[32m+
(B[m         // 检查不是全零
         assert!(!embedding.iter().all(|&x| x == 0.0));
[31m-        
(B[m[32m+
(B[m         // 检查值在合理范围内
         assert!(embedding.iter().all(|&x| x >= -0.5 && x <= 0.5));
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-embeddings/src/utils.rs:331:
     fn test_dimension_mismatch_errors() {
         let a = vec![1.0, 2.0];
         let b = vec![1.0, 2.0, 3.0];
[31m-        
(B[m[32m+
(B[m         assert!(EmbeddingUtils::cosine_similarity(&a, &b).is_err());
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/dbscan.rs:1:
 //! DBSCAN聚类算法实现
 
[31m-use super::{MemoryCluster, MemoryClusterer, ClusteringConfig, ClusteringMetrics, ClusteringUtils};
(B[m[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use super::{ClusteringConfig, ClusteringMetrics, ClusteringUtils, MemoryCluster, MemoryClusterer};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m 
 /// DBSCAN聚类器
 pub struct DBSCANClusterer;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/hierarchical.rs:1:
 //! 层次聚类算法实现
 
[31m-use super::{MemoryCluster, MemoryClusterer, ClusteringConfig, ClusteringMetrics, ClusteringUtils};
(B[m[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use super::{ClusteringConfig, ClusteringMetrics, ClusteringUtils, MemoryCluster, MemoryClusterer};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m 
 /// 层次聚类器
 pub struct HierarchicalClusterer;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:1:
 //! K-means聚类算法实现
 
[31m-use super::{MemoryCluster, MemoryClusterer, ClusteringConfig, ClusteringMetrics, ClusteringUtils};
(B[m[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use super::{ClusteringConfig, ClusteringMetrics, ClusteringUtils, MemoryCluster, MemoryClusterer};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use std::collections::HashMap;
 
 /// K-means聚类器
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:24:
     /// 初始化聚类中心
     fn initialize_centroids(&self, vectors: &[Vec<f32>], k: usize) -> Result<Vec<Vec<f32>>> {
         if vectors.is_empty() {
[31m-            return Err(AgentMemError::validation_error("Cannot initialize centroids for empty vector set"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Cannot initialize centroids for empty vector set",
(B[m[32m+            ));
(B[m         }
 
         if k == 0 {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:31:
[31m-            return Err(AgentMemError::validation_error("Number of clusters must be greater than 0"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Number of clusters must be greater than 0",
(B[m[32m+            ));
(B[m         }
 
         if k > vectors.len() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:35:
[31m-            return Err(AgentMemError::validation_error("Number of clusters cannot exceed number of vectors"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Number of clusters cannot exceed number of vectors",
(B[m[32m+            ));
(B[m         }
 
         let dimension = vectors[0].len();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:85:
     }
 
     /// 将向量分配到最近的聚类中心
[31m-    fn assign_to_clusters(&self, vectors: &[Vec<f32>], centroids: &[Vec<f32>]) -> Result<Vec<usize>> {
(B[m[32m+    fn assign_to_clusters(
(B[m[32m+        &self,
(B[m[32m+        vectors: &[Vec<f32>],
(B[m[32m+        centroids: &[Vec<f32>],
(B[m[32m+    ) -> Result<Vec<usize>> {
(B[m         let mut assignments = Vec::new();
 
         for vector in vectors {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:114:
         k: usize,
     ) -> Result<Vec<Vec<f32>>> {
         if vectors.is_empty() {
[31m-            return Err(AgentMemError::validation_error("Cannot update centroids for empty vector set"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Cannot update centroids for empty vector set",
(B[m[32m+            ));
(B[m         }
 
         let dimension = vectors[0].len();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:148:
     }
 
     /// 检查收敛性
[31m-    fn has_converged(&self, old_centroids: &[Vec<f32>], new_centroids: &[Vec<f32>], threshold: f32) -> Result<bool> {
(B[m[32m+    fn has_converged(
(B[m[32m+        &self,
(B[m[32m+        old_centroids: &[Vec<f32>],
(B[m[32m+        new_centroids: &[Vec<f32>],
(B[m[32m+        threshold: f32,
(B[m[32m+    ) -> Result<bool> {
(B[m         if old_centroids.len() != new_centroids.len() {
             return Ok(false);
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:172:
         config: &ClusteringConfig,
     ) -> Result<Vec<MemoryCluster>> {
         if memory_vectors.len() != memory_ids.len() {
[31m-            return Err(AgentMemError::validation_error("Memory vectors and IDs must have the same length"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Memory vectors and IDs must have the same length",
(B[m[32m+            ));
(B[m         }
 
         if memory_vectors.is_empty() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:347:
 
         // 简化的轮廓系数计算
         let silhouette_score = if inter_cluster_distance > 0.0 && intra_cluster_distance > 0.0 {
[31m-            (inter_cluster_distance - intra_cluster_distance) / inter_cluster_distance.max(intra_cluster_distance)
(B[m[32m+            (inter_cluster_distance - intra_cluster_distance)
(B[m[32m+                / inter_cluster_distance.max(intra_cluster_distance)
(B[m         } else {
             0.0
         };
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:356:
             silhouette_score,
             intra_cluster_distance,
             inter_cluster_distance,
[31m-            davies_bouldin_index: 0.0, // 简化实现
(B[m[32m+            davies_bouldin_index: 0.0,    // 简化实现
(B[m             calinski_harabasz_index: 0.0, // 简化实现
         })
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:400:
             vec![10.0, 10.0],
             vec![11.0, 11.0],
         ];
[31m-        let centroids = vec![
(B[m[31m-            vec![1.5, 1.5],
(B[m[31m-            vec![10.5, 10.5],
(B[m[31m-        ];
(B[m[32m+        let centroids = vec![vec![1.5, 1.5], vec![10.5, 10.5]];
(B[m 
         let assignments = clusterer.assign_to_clusters(&vectors, &centroids).unwrap();
         assert_eq!(assignments.len(), 4);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:433:
         config.num_clusters = Some(2);
         config.min_cluster_size = 1;
 
[31m-        let clusters = clusterer.cluster_memories(&vectors, &memory_ids, &config).unwrap();
(B[m[32m+        let clusters = clusterer
(B[m[32m+            .cluster_memories(&vectors, &memory_ids, &config)
(B[m[32m+            .unwrap();
(B[m         assert_eq!(clusters.len(), 2);
[31m-        
(B[m[32m+
(B[m         for cluster in &clusters {
             assert!(!cluster.memory_ids.is_empty());
             assert_eq!(cluster.centroid.len(), 2);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:474:
         let memory_ids: Vec<String> = vec![];
         let config = ClusteringConfig::default();
 
[31m-        let clusters = clusterer.cluster_memories(&vectors, &memory_ids, &config).unwrap();
(B[m[32m+        let clusters = clusterer
(B[m[32m+            .cluster_memories(&vectors, &memory_ids, &config)
(B[m[32m+            .unwrap();
(B[m         assert!(clusters.is_empty());
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/kmeans.rs:487:
         config.num_clusters = Some(1);
         config.min_cluster_size = 1;
 
[31m-        let clusters = clusterer.cluster_memories(&vectors, &memory_ids, &config).unwrap();
(B[m[32m+        let clusters = clusterer
(B[m[32m+            .cluster_memories(&vectors, &memory_ids, &config)
(B[m[32m+            .unwrap();
(B[m         assert_eq!(clusters.len(), 1);
         assert_eq!(clusters[0].memory_ids.len(), 1);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/mod.rs:1:
 //! 记忆聚类分析模块
 
[31m-pub mod kmeans;
(B[m[31m-pub mod hierarchical;
(B[m pub mod dbscan;
[32m+pub mod hierarchical;
(B[m[32m+pub mod kmeans;
(B[m 
[31m-pub use kmeans::KMeansClusterer;
(B[m[31m-pub use hierarchical::HierarchicalClusterer;
(B[m pub use dbscan::DBSCANClusterer;
[32m+pub use hierarchical::HierarchicalClusterer;
(B[m[32m+pub use kmeans::KMeansClusterer;
(B[m 
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m[32m+use async_trait::async_trait;
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
[31m-use async_trait::async_trait;
(B[m 
 /// 记忆聚类结果
 #[derive(Debug, Clone, Serialize, Deserialize)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/mod.rs:167:
     /// 计算向量间的欧几里得距离
     pub fn euclidean_distance(a: &[f32], b: &[f32]) -> Result<f32> {
         if a.len() != b.len() {
[31m-            return Err(AgentMemError::validation_error("Vector dimensions must match"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Vector dimensions must match",
(B[m[32m+            ));
(B[m         }
 
[31m-        let distance = a.iter()
(B[m[32m+        let distance = a
(B[m[32m+            .iter()
(B[m             .zip(b.iter())
             .map(|(x, y)| (x - y).powi(2))
             .sum::<f32>()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/mod.rs:182:
     /// 计算向量的质心
     pub fn calculate_centroid(vectors: &[Vec<f32>]) -> Result<Vec<f32>> {
         if vectors.is_empty() {
[31m-            return Err(AgentMemError::validation_error("Cannot calculate centroid of empty vector set"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Cannot calculate centroid of empty vector set",
(B[m[32m+            ));
(B[m         }
 
         let dimension = vectors[0].len();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/mod.rs:189:
         for vector in vectors {
             if vector.len() != dimension {
[31m-                return Err(AgentMemError::validation_error("All vectors must have the same dimension"));
(B[m[32m+                return Err(AgentMemError::validation_error(
(B[m[32m+                    "All vectors must have the same dimension",
(B[m[32m+                ));
(B[m             }
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/mod.rs:213:
         cluster: &MemoryCluster,
         memory_vectors: &HashMap<String, Vec<f32>>,
     ) -> Result<f32> {
[31m-        let cluster_vectors: Vec<&Vec<f32>> = cluster.memory_ids
(B[m[32m+        let cluster_vectors: Vec<&Vec<f32>> = cluster
(B[m[32m+            .memory_ids
(B[m             .iter()
             .filter_map(|id| memory_vectors.get(id))
             .collect();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/mod.rs:247:
 
         for i in 0..clusters.len() {
             for j in (i + 1)..clusters.len() {
[31m-                let distance = Self::euclidean_distance(&clusters[i].centroid, &clusters[j].centroid)?;
(B[m[32m+                let distance =
(B[m[32m+                    Self::euclidean_distance(&clusters[i].centroid, &clusters[j].centroid)?;
(B[m                 total_distance += distance;
                 count += 1;
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/mod.rs:268:
         for k in 1..=max_k {
             let mut config = ClusteringConfig::default();
             config.num_clusters = Some(k);
[31m-            
(B[m[32m+
(B[m             let clusters = clusterer.cluster_memories(vectors, &memory_ids, &config)?;
             let wcss = Self::calculate_wcss(vectors, &clusters, &memory_ids)?;
             wcss_values.push(wcss);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/clustering/mod.rs:377:
 
     #[test]
     fn test_clustering_utils_calculate_centroid() {
[31m-        let vectors = vec![
(B[m[31m-            vec![1.0, 2.0],
(B[m[31m-            vec![3.0, 4.0],
(B[m[31m-            vec![5.0, 6.0],
(B[m[31m-        ];
(B[m[32m+        let vectors = vec![vec![1.0, 2.0], vec![3.0, 4.0], vec![5.0, 6.0]];
(B[m         let centroid = ClusteringUtils::calculate_centroid(&vectors).unwrap();
         assert_eq!(centroid, vec![3.0, 4.0]);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:1:
 //! 记忆重要性评估模块
 
[31m-use agent_mem_traits::{Result, AgentMemError, MemoryType};
(B[m[32m+use agent_mem_traits::{AgentMemError, MemoryType, Result};
(B[m[32m+use chrono::{DateTime, Utc};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
[31m-use chrono::{DateTime, Utc};
(B[m 
 /// 重要性评估结果
 #[derive(Debug, Clone, Serialize, Deserialize)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:202:
     fn calculate_content_score(&self, memory: &MemoryInfo) -> f32 {
         let content_length = memory.content.len() as f32;
         let word_count = memory.content.split_whitespace().count() as f32;
[31m-        
(B[m[32m+
(B[m         // 基于内容长度和词汇数量的综合评分
         let length_score = (content_length / 1000.0).min(1.0); // 1000字符为满分
         let word_score = (word_count / 100.0).min(1.0); // 100词为满分
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:209:
[31m-        
(B[m[32m+
(B[m         (length_score + word_score) / 2.0
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:213:
     /// 计算记忆类型分数
     fn calculate_type_score(&self, memory: &MemoryInfo) -> f32 {
         match memory.memory_type {
[31m-            MemoryType::Factual => 0.8,      // 事实记忆重要性较高
(B[m[31m-            MemoryType::Episodic => 0.7,     // 情节记忆中等重要
(B[m[31m-            MemoryType::Procedural => 0.9,   // 程序记忆非常重要
(B[m[31m-            MemoryType::Semantic => 0.8,     // 语义记忆重要性较高
(B[m[31m-            MemoryType::Working => 0.5,      // 工作记忆重要性较低
(B[m[32m+            MemoryType::Factual => 0.8,    // 事实记忆重要性较高
(B[m[32m+            MemoryType::Episodic => 0.7,   // 情节记忆中等重要
(B[m[32m+            MemoryType::Procedural => 0.9, // 程序记忆非常重要
(B[m[32m+            MemoryType::Semantic => 0.8,   // 语义记忆重要性较高
(B[m[32m+            MemoryType::Working => 0.5,    // 工作记忆重要性较低
(B[m         }
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:266:
     /// 计算余弦相似度
     fn cosine_similarity(&self, a: &[f32], b: &[f32]) -> Result<f32> {
         if a.len() != b.len() {
[31m-            return Err(AgentMemError::validation_error("Vector dimensions must match"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Vector dimensions must match",
(B[m[32m+            ));
(B[m         }
 
         let dot_product: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:281:
     }
 
     /// 批量评估重要性
[31m-    pub fn batch_evaluate(
(B[m[31m-        &self,
(B[m[31m-        memories: &[MemoryInfo],
(B[m[31m-    ) -> Result<Vec<ImportanceResult>> {
(B[m[32m+    pub fn batch_evaluate(&self, memories: &[MemoryInfo]) -> Result<Vec<ImportanceResult>> {
(B[m         let mut results = Vec::new();
[31m-        
(B[m[32m+
(B[m         for memory in memories {
             let result = self.evaluate_importance(memory, memories)?;
             results.push(result);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:293:
         }
[31m-        
(B[m[32m+
(B[m         Ok(results)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:298:
     /// 根据重要性排序记忆
[31m-    pub fn rank_memories(
(B[m[31m-        &self,
(B[m[31m-        memories: &[MemoryInfo],
(B[m[31m-    ) -> Result<Vec<(usize, ImportanceResult)>> {
(B[m[32m+    pub fn rank_memories(&self, memories: &[MemoryInfo]) -> Result<Vec<(usize, ImportanceResult)>> {
(B[m         let results = self.batch_evaluate(memories)?;
[31m-        
(B[m[31m-        let mut ranked: Vec<(usize, ImportanceResult)> = results
(B[m[31m-            .into_iter()
(B[m[31m-            .enumerate()
(B[m[31m-            .collect();
(B[m 
[32m+        let mut ranked: Vec<(usize, ImportanceResult)> = results.into_iter().enumerate().collect();
(B[m[32m+
(B[m         // 按重要性分数降序排序
         ranked.sort_by(|(_, a), (_, b)| {
[31m-            b.importance_score.partial_cmp(&a.importance_score)
(B[m[32m+            b.importance_score
(B[m[32m+                .partial_cmp(&a.importance_score)
(B[m                 .unwrap_or(std::cmp::Ordering::Equal)
         });
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:373:
     #[test]
     fn test_calculate_content_score() {
         let evaluator = ImportanceEvaluator::default();
[31m-        
(B[m[32m+
(B[m         let memory_short = create_test_memory("1", "short", 1);
         let memory_long = create_test_memory("2", &"long content ".repeat(50), 1);
[31m-        
(B[m[32m+
(B[m         let score_short = evaluator.calculate_content_score(&memory_short);
         let score_long = evaluator.calculate_content_score(&memory_long);
[31m-        
(B[m[32m+
(B[m         assert!(score_long > score_short);
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:386:
     #[test]
     fn test_calculate_type_score() {
         let evaluator = ImportanceEvaluator::default();
[31m-        
(B[m[32m+
(B[m         let mut memory = create_test_memory("1", "test", 1);
[31m-        
(B[m[32m+
(B[m         memory.memory_type = MemoryType::Procedural;
         let procedural_score = evaluator.calculate_type_score(&memory);
[31m-        
(B[m[32m+
(B[m         memory.memory_type = MemoryType::Working;
         let working_score = evaluator.calculate_type_score(&memory);
[31m-        
(B[m[32m+
(B[m         assert!(procedural_score > working_score);
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:403:
         let evaluator = ImportanceEvaluator::default();
         let memory = create_test_memory("1", "test content", 5);
         let context = vec![create_test_memory("2", "other content", 3)];
[31m-        
(B[m[32m+
(B[m         let result = evaluator.evaluate_importance(&memory, &context).unwrap();
[31m-        
(B[m[32m+
(B[m         assert!(result.importance_score >= 0.0);
         assert!(result.importance_score <= 1.0);
         assert!(!result.factor_scores.is_empty());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:420:
             create_test_memory("2", "second memory", 10),
             create_test_memory("3", "third memory", 2),
         ];
[31m-        
(B[m[32m+
(B[m         let results = evaluator.batch_evaluate(&memories).unwrap();
         assert_eq!(results.len(), 3);
[31m-        
(B[m[32m+
(B[m         for result in &results {
             assert!(result.importance_score >= 0.0);
             assert!(result.importance_score <= 1.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:438:
             create_test_memory("2", "high importance", 20),
             create_test_memory("3", "medium importance", 5),
         ];
[31m-        
(B[m[32m+
(B[m         let ranked = evaluator.rank_memories(&memories).unwrap();
         assert_eq!(ranked.len(), 3);
[31m-        
(B[m[32m+
(B[m         // 检查是否按重要性降序排列
         assert!(ranked[0].1.importance_score >= ranked[1].1.importance_score);
         assert!(ranked[1].1.importance_score >= ranked[2].1.importance_score);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:450:
     #[test]
     fn test_cosine_similarity() {
         let evaluator = ImportanceEvaluator::default();
[31m-        
(B[m[32m+
(B[m         let a = vec![1.0, 0.0, 0.0];
         let b = vec![1.0, 0.0, 0.0];
         let similarity = evaluator.cosine_similarity(&a, &b).unwrap();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/importance/mod.rs:457:
         assert!((similarity - 1.0).abs() < 1e-6);
[31m-        
(B[m[32m+
(B[m         let c = vec![0.0, 1.0, 0.0];
         let similarity2 = evaluator.cosine_similarity(&a, &c).unwrap();
         assert!((similarity2 - 0.0).abs() < 1e-6);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/lib.rs:1:
 //! # Agent Memory Intelligence
[31m-//! 
(B[m[32m+//!
(B[m //! 智能记忆处理模块，为AgentMem记忆平台提供高级智能化功能。
[31m-//! 
(B[m[32m+//!
(B[m //! 本模块提供：
 //! - 高级相似度计算和语义分析
 //! - 记忆聚类和模式识别
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/lib.rs:9:
 //! - 记忆推理和关联分析
 //! - 记忆生命周期管理
 
[31m-pub mod similarity;
(B[m pub mod clustering;
 pub mod importance;
[31m-pub mod reasoning;
(B[m pub mod processing;
[32m+pub mod reasoning;
(B[m[32m+pub mod similarity;
(B[m 
 // 重新导出常用类型
[31m-pub use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+pub use agent_mem_traits::{AgentMemError, Result};
(B[m 
 // 导出主要功能模块
[31m-pub use similarity::SemanticSimilarity;
(B[m pub use clustering::MemoryClusterer;
 pub use importance::ImportanceEvaluator;
[31m-pub use reasoning::MemoryReasoner;
(B[m pub use processing::{MemoryProcessor, ProcessingConfig, ProcessingStats};
[32m+pub use reasoning::MemoryReasoner;
(B[m[32m+pub use similarity::SemanticSimilarity;
(B[m 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:1:
 //! Adaptive memory management algorithms
[31m-//! 
(B[m[32m+//!
(B[m //! Implements intelligent memory lifecycle management including
 //! archiving, deletion, and capacity management.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:6:
 use agent_mem_core::Memory;
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use tracing::{debug, info, warn};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:40:
 pub struct ManagementThresholds {
     /// Minimum importance score to keep memory
     pub min_importance: f32,
[31m-    
(B[m[32m+
(B[m     /// Age threshold for archiving (in seconds)
     pub archive_age_threshold: i64,
[31m-    
(B[m[32m+
(B[m     /// Age threshold for deletion (in seconds)
     pub delete_age_threshold: i64,
[31m-    
(B[m[32m+
(B[m     /// Minimum access count to prevent deletion
     pub min_access_count: u32,
[31m-    
(B[m[32m+
(B[m     /// Maximum memory size before compression (in bytes)
     pub max_memory_size: usize,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:58:
     fn default() -> Self {
         Self {
             min_importance: 0.1,
[31m-            archive_age_threshold: 7 * 24 * 60 * 60,    // 7 days
(B[m[31m-            delete_age_threshold: 30 * 24 * 60 * 60,    // 30 days
(B[m[32m+            archive_age_threshold: 7 * 24 * 60 * 60, // 7 days
(B[m[32m+            delete_age_threshold: 30 * 24 * 60 * 60, // 30 days
(B[m             min_access_count: 1,
             max_memory_size: 10000, // 10KB
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:70:
 pub struct AdaptiveMemoryManager {
     /// Maximum memories per scope
     max_memories: usize,
[31m-    
(B[m[32m+
(B[m     /// Retention period in seconds
     retention_period: i64,
[31m-    
(B[m[32m+
(B[m     /// Management strategy
     strategy: AdaptiveStrategy,
[31m-    
(B[m[32m+
(B[m     /// Management thresholds
     thresholds: ManagementThresholds,
[31m-    
(B[m[32m+
(B[m     /// Statistics tracking
     stats: HashMap<String, u64>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:95:
             stats: HashMap::new(),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Set management strategy
     pub fn with_strategy(mut self, strategy: AdaptiveStrategy) -> Self {
         self.strategy = strategy;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:102:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set management thresholds
     pub fn with_thresholds(mut self, thresholds: ManagementThresholds) -> Self {
         self.thresholds = thresholds;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:108:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Update memory limits
     pub fn update_limits(&mut self, max_memories: usize, retention_period: i64) {
         self.max_memories = max_memories;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:114:
         self.retention_period = retention_period;
     }
[31m-    
(B[m[32m+
(B[m     /// Manage a batch of memories
     pub async fn manage_memories(&mut self, memories: &mut Vec<Memory>) -> Result<(usize, usize)> {
[31m-        info!("Managing {} memories with strategy {:?}", memories.len(), self.strategy);
(B[m[31m-        
(B[m[32m+        info!(
(B[m[32m+            "Managing {} memories with strategy {:?}",
(B[m[32m+            memories.len(),
(B[m[32m+            self.strategy
(B[m[32m+        );
(B[m[32m+
(B[m         let current_time = chrono::Utc::now().timestamp();
         let mut archived_count = 0;
         let mut deleted_count = 0;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:124:
[31m-        
(B[m[32m+
(B[m         // Step 1: Apply lifecycle actions based on strategy
[31m-        let actions = self.determine_lifecycle_actions(memories, current_time).await?;
(B[m[31m-        
(B[m[32m+        let actions = self
(B[m[32m+            .determine_lifecycle_actions(memories, current_time)
(B[m[32m+            .await?;
(B[m[32m+
(B[m         // Step 2: Execute actions
         for (i, action) in actions.iter().enumerate() {
             match action {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:144:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         // Step 3: Handle capacity constraints
         if memories.len() > self.max_memories {
             let excess_count = memories.len() - self.max_memories;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:151:
[31m-            let additional_deleted = self.handle_capacity_overflow(memories, excess_count).await?;
(B[m[32m+            let additional_deleted = self
(B[m[32m+                .handle_capacity_overflow(memories, excess_count)
(B[m[32m+                .await?;
(B[m             deleted_count += additional_deleted;
         }
[31m-        
(B[m[32m+
(B[m         // Update statistics
         self.update_stats(archived_count, deleted_count);
[31m-        
(B[m[31m-        info!("Memory management completed: {} archived, {} deleted", archived_count, deleted_count);
(B[m[32m+
(B[m[32m+        info!(
(B[m[32m+            "Memory management completed: {} archived, {} deleted",
(B[m[32m+            archived_count, deleted_count
(B[m[32m+        );
(B[m         Ok((archived_count, deleted_count))
     }
[31m-    
(B[m[32m+
(B[m     /// Evaluate a single memory for lifecycle actions
     pub async fn evaluate_single_memory(&mut self, memory: &mut Memory) -> Result<LifecycleAction> {
         let current_time = chrono::Utc::now().timestamp();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:165:
[31m-        let action = self.determine_single_lifecycle_action(memory, current_time).await?;
(B[m[31m-        
(B[m[32m+        let action = self
(B[m[32m+            .determine_single_lifecycle_action(memory, current_time)
(B[m[32m+            .await?;
(B[m[32m+
(B[m         match action {
             LifecycleAction::Archive => {
                 self.archive_memory(memory).await?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:173:
             }
             _ => {}
         }
[31m-        
(B[m[32m+
(B[m         Ok(action)
     }
[31m-    
(B[m[32m+
(B[m     /// Determine lifecycle actions for all memories
     async fn determine_lifecycle_actions(
         &self,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:184:
         current_time: i64,
     ) -> Result<Vec<LifecycleAction>> {
         let mut actions = Vec::with_capacity(memories.len());
[31m-        
(B[m[32m+
(B[m         for memory in memories {
[31m-            let action = self.determine_single_lifecycle_action(memory, current_time).await?;
(B[m[32m+            let action = self
(B[m[32m+                .determine_single_lifecycle_action(memory, current_time)
(B[m[32m+                .await?;
(B[m             actions.push(action);
         }
[31m-        
(B[m[32m+
(B[m         Ok(actions)
     }
[31m-    
(B[m[32m+
(B[m     /// Determine lifecycle action for a single memory
     async fn determine_single_lifecycle_action(
         &self,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:201:
     ) -> Result<LifecycleAction> {
         let age = current_time - memory.created_at;
         let time_since_access = current_time - memory.last_accessed_at;
[31m-        
(B[m[32m+
(B[m         // Check for deletion conditions
         if age > self.thresholds.delete_age_threshold
             || (memory.importance < self.thresholds.min_importance
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:209:
         {
             return Ok(LifecycleAction::Delete);
         }
[31m-        
(B[m[32m+
(B[m         // Check for archiving conditions
         if age > self.thresholds.archive_age_threshold
             || time_since_access > self.thresholds.archive_age_threshold / 2
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:216:
         {
             return Ok(LifecycleAction::Archive);
         }
[31m-        
(B[m[32m+
(B[m         // Check for compression conditions
         if memory.content.len() > self.thresholds.max_memory_size {
             return Ok(LifecycleAction::Compress);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:223:
         }
[31m-        
(B[m[32m+
(B[m         // Apply strategy-specific logic
         match self.strategy {
             AdaptiveStrategy::LRU => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:248:
             AdaptiveStrategy::Hybrid => {
                 // Combine multiple factors
                 let importance_factor = memory.importance;
[31m-                let recency_factor = 1.0 - (time_since_access as f32 / self.retention_period as f32).min(1.0);
(B[m[32m+                let recency_factor =
(B[m[32m+                    1.0 - (time_since_access as f32 / self.retention_period as f32).min(1.0);
(B[m                 let frequency_factor = (memory.access_count as f32 / 10.0).min(1.0);
[31m-                
(B[m[31m-                let combined_score = importance_factor * 0.5 + recency_factor * 0.3 + frequency_factor * 0.2;
(B[m[31m-                
(B[m[32m+
(B[m[32m+                let combined_score =
(B[m[32m+                    importance_factor * 0.5 + recency_factor * 0.3 + frequency_factor * 0.2;
(B[m[32m+
(B[m                 if combined_score < 0.3 {
                     Ok(LifecycleAction::Archive)
                 } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:261:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Archive a memory
     async fn archive_memory(&self, memory: &mut Memory) -> Result<()> {
[31m-        memory.metadata.insert("archived".to_string(), "true".to_string());
(B[m[32m+        memory
(B[m[32m+            .metadata
(B[m[32m+            .insert("archived".to_string(), "true".to_string());
(B[m         memory.metadata.insert(
             "archived_at".to_string(),
             chrono::Utc::now().timestamp().to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:271:
         );
[31m-        
(B[m[32m+
(B[m         // Reduce importance slightly for archived memories
         memory.importance *= 0.8;
         memory.version += 1;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:276:
[31m-        
(B[m[32m+
(B[m         debug!("Archived memory: {}", memory.id);
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:280:
[31m-    
(B[m[32m+
(B[m     /// Compress a memory by reducing content size
     async fn compress_memory(&self, memory: &mut Memory) -> Result<()> {
         let original_size = memory.content.len();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:284:
[31m-        
(B[m[32m+
(B[m         // Simple compression: keep first and last parts, summarize middle
         if original_size > self.thresholds.max_memory_size {
             let keep_size = self.thresholds.max_memory_size / 3;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:291:
             } else {
                 ""
             };
[31m-            
(B[m[32m+
(B[m             let compressed_content = if !end_part.is_empty() {
[31m-                format!("{}... [compressed {} chars] ...{}", start_part, original_size - keep_size * 2, end_part)
(B[m[32m+                format!(
(B[m[32m+                    "{}... [compressed {} chars] ...{}",
(B[m[32m+                    start_part,
(B[m[32m+                    original_size - keep_size * 2,
(B[m[32m+                    end_part
(B[m[32m+                )
(B[m             } else {
                 start_part.to_string()
             };
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:300:
[31m-            
(B[m[32m+
(B[m             memory.content = compressed_content;
[31m-            memory.metadata.insert("compressed".to_string(), "true".to_string());
(B[m[31m-            memory.metadata.insert("original_size".to_string(), original_size.to_string());
(B[m[32m+            memory
(B[m[32m+                .metadata
(B[m[32m+                .insert("compressed".to_string(), "true".to_string());
(B[m[32m+            memory
(B[m[32m+                .metadata
(B[m[32m+                .insert("original_size".to_string(), original_size.to_string());
(B[m             memory.version += 1;
[31m-            
(B[m[31m-            debug!("Compressed memory {} from {} to {} bytes", memory.id, original_size, memory.content.len());
(B[m[32m+
(B[m[32m+            debug!(
(B[m[32m+                "Compressed memory {} from {} to {} bytes",
(B[m[32m+                memory.id,
(B[m[32m+                original_size,
(B[m[32m+                memory.content.len()
(B[m[32m+            );
(B[m         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Handle capacity overflow by removing least important memories
[31m-    async fn handle_capacity_overflow(&self, memories: &mut [Memory], excess_count: usize) -> Result<usize> {
(B[m[32m+    async fn handle_capacity_overflow(
(B[m[32m+        &self,
(B[m[32m+        memories: &mut [Memory],
(B[m[32m+        excess_count: usize,
(B[m[32m+    ) -> Result<usize> {
(B[m         if excess_count == 0 {
             return Ok(0);
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:317:
[31m-        
(B[m[31m-        warn!("Memory capacity exceeded, removing {} memories", excess_count);
(B[m[31m-        
(B[m[32m+
(B[m[32m+        warn!(
(B[m[32m+            "Memory capacity exceeded, removing {} memories",
(B[m[32m+            excess_count
(B[m[32m+        );
(B[m[32m+
(B[m         // Create indices with scores for sorting
         let mut memory_scores: Vec<(usize, f32)> = memories
             .iter()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:340:
                 (i, score)
             })
             .collect();
[31m-        
(B[m[32m+
(B[m         // Sort by score (lowest first for removal)
         memory_scores.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());
[31m-        
(B[m[32m+
(B[m         // Mark worst memories for deletion
         let mut deleted_count = 0;
         for (i, _) in memory_scores.iter().take(excess_count) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:350:
[31m-            if !memories[*i].content.is_empty() { // Don't double-delete
(B[m[32m+            if !memories[*i].content.is_empty() {
(B[m[32m+                // Don't double-delete
(B[m                 memories[*i].content = String::new(); // Mark for deletion
                 deleted_count += 1;
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:354:
         }
[31m-        
(B[m[32m+
(B[m         Ok(deleted_count)
     }
[31m-    
(B[m[32m+
(B[m     /// Update internal statistics
     fn update_stats(&mut self, archived: usize, deleted: usize) {
         *self.stats.entry("total_archived".to_string()).or_insert(0) += archived as u64;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:362:
         *self.stats.entry("total_deleted".to_string()).or_insert(0) += deleted as u64;
         *self.stats.entry("management_runs".to_string()).or_insert(0) += 1;
     }
[31m-    
(B[m[32m+
(B[m     /// Get management statistics
     pub fn get_stats(&self) -> &HashMap<String, u64> {
         &self.stats
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:369:
     }
[31m-    
(B[m[32m+
(B[m     /// Clean up memories marked for deletion
     pub fn cleanup_deleted_memories(&self, memories: &mut Vec<Memory>) {
         memories.retain(|memory| !memory.content.is_empty());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:405:
         let manager = AdaptiveMemoryManager::new(100, 30 * 24 * 60 * 60);
         assert_eq!(manager.max_memories, 100);
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_lifecycle_action_determination() {
         let manager = AdaptiveMemoryManager::new(100, 30 * 24 * 60 * 60);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:412:
         let current_time = Utc::now().timestamp();
[31m-        
(B[m[32m+
(B[m         // Old, low importance memory should be deleted
         let old_memory = create_test_memory("old", 0.05, 1, 35);
[31m-        let action = manager.determine_single_lifecycle_action(&old_memory, current_time).await.unwrap();
(B[m[32m+        let action = manager
(B[m[32m+            .determine_single_lifecycle_action(&old_memory, current_time)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m         assert!(matches!(action, LifecycleAction::Delete));
[31m-        
(B[m[32m+
(B[m         // Recent, important memory should be kept
         let important_memory = create_test_memory("important", 0.9, 10, 1);
[31m-        let action = manager.determine_single_lifecycle_action(&important_memory, current_time).await.unwrap();
(B[m[32m+        let action = manager
(B[m[32m+            .determine_single_lifecycle_action(&important_memory, current_time)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m         assert!(matches!(action, LifecycleAction::Keep));
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_memory_archiving() {
         let manager = AdaptiveMemoryManager::new(100, 30 * 24 * 60 * 60);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:428:
         let mut memory = create_test_memory("test", 0.5, 5, 10);
[31m-        
(B[m[32m+
(B[m         manager.archive_memory(&mut memory).await.unwrap();
[31m-        
(B[m[32m+
(B[m         assert_eq!(memory.metadata.get("archived"), Some(&"true".to_string()));
         assert!(memory.importance < 0.5); // Should be reduced
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:435:
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_memory_compression() {
         let manager = AdaptiveMemoryManager::new(100, 30 * 24 * 60 * 60);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:439:
         let mut memory = create_test_memory("test", 0.5, 5, 1);
         memory.content = "A".repeat(15000); // Large content
[31m-        
(B[m[32m+
(B[m         let original_size = memory.content.len();
         manager.compress_memory(&mut memory).await.unwrap();
[31m-        
(B[m[32m+
(B[m         assert!(memory.content.len() < original_size);
         assert_eq!(memory.metadata.get("compressed"), Some(&"true".to_string()));
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:448:
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_capacity_management() {
         let mut manager = AdaptiveMemoryManager::new(3, 30 * 24 * 60 * 60); // Max 3 memories
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:452:
[31m-        
(B[m[32m+
(B[m         let mut memories = vec![
             create_test_memory("1", 0.9, 10, 1), // High importance
             create_test_memory("2", 0.5, 5, 5),  // Medium importance
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/adaptive.rs:457:
             create_test_memory("4", 0.1, 1, 15), // Very low importance
             create_test_memory("5", 0.8, 8, 2),  // High importance
         ];
[31m-        
(B[m[32m+
(B[m         let (archived, deleted) = manager.manage_memories(&mut memories).await.unwrap();
[31m-        
(B[m[32m+
(B[m         // Should have deleted some memories due to capacity constraints
         assert!(deleted > 0);
[31m-        
(B[m[32m+
(B[m         // Clean up and verify capacity is respected
         manager.cleanup_deleted_memories(&mut memories);
         assert!(memories.len() <= 3);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:1:
 //! Memory consolidation algorithms
[31m-//! 
(B[m[32m+//!
(B[m //! Implements intelligent memory consolidation to reduce redundancy
 //! and improve memory organization.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:6:
 use agent_mem_core::Memory;
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use agent_mem_utils::text::jaccard_similarity;
 use serde::{Deserialize, Serialize};
 use std::collections::{HashMap, HashSet};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:26:
 pub struct ConsolidationResult {
     /// Original memory IDs that were consolidated
     pub original_ids: Vec<String>,
[31m-    
(B[m[32m+
(B[m     /// New consolidated memory ID
     pub consolidated_id: String,
[31m-    
(B[m[32m+
(B[m     /// Consolidation strategy used
     pub strategy: ConsolidationStrategy,
[31m-    
(B[m[32m+
(B[m     /// Similarity score that triggered consolidation
     pub similarity_score: f32,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:41:
 pub struct MemoryConsolidator {
     /// Similarity threshold for consolidation
     threshold: f32,
[31m-    
(B[m[32m+
(B[m     /// Consolidation strategy
     strategy: ConsolidationStrategy,
[31m-    
(B[m[32m+
(B[m     /// Cache for similarity calculations
     similarity_cache: HashMap<(String, String), f32>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:58:
             similarity_cache: HashMap::new(),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Set consolidation strategy
     pub fn with_strategy(mut self, strategy: ConsolidationStrategy) -> Self {
         self.strategy = strategy;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:65:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Update similarity threshold
     pub fn update_threshold(&mut self, threshold: f32) {
         self.threshold = threshold;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:71:
         // Clear cache when threshold changes
         self.similarity_cache.clear();
     }
[31m-    
(B[m[32m+
(B[m     /// Consolidate a batch of memories
     pub async fn consolidate_memories(&mut self, memories: &mut Vec<Memory>) -> Result<usize> {
         if memories.len() < 2 {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:78:
             return Ok(0);
         }
[31m-        
(B[m[31m-        info!("Starting memory consolidation for {} memories", memories.len());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        info!(
(B[m[32m+            "Starting memory consolidation for {} memories",
(B[m[32m+            memories.len()
(B[m[32m+        );
(B[m[32m+
(B[m         let mut consolidated_count = 0;
         let mut consolidation_groups = self.find_consolidation_groups(memories).await?;
[31m-        
(B[m[32m+
(B[m         // Sort groups by size (largest first) to prioritize major consolidations
         consolidation_groups.sort_by(|a, b| b.len().cmp(&a.len()));
[31m-        
(B[m[32m+
(B[m         for group in consolidation_groups {
             if group.len() < 2 {
                 continue;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:92:
             }
[31m-            
(B[m[32m+
(B[m             match self.strategy {
                 ConsolidationStrategy::Merge => {
                     if self.merge_memory_group(memories, &group).await? {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:109:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         info!("Consolidated {} memories", consolidated_count);
         Ok(consolidated_count)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:116:
[31m-    
(B[m[32m+
(B[m     /// Find groups of similar memories that should be consolidated
     async fn find_consolidation_groups(&mut self, memories: &[Memory]) -> Result<Vec<Vec<usize>>> {
         let mut groups = Vec::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:120:
         let mut processed = HashSet::new();
[31m-        
(B[m[32m+
(B[m         for i in 0..memories.len() {
             if processed.contains(&i) {
                 continue;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:125:
             }
[31m-            
(B[m[32m+
(B[m             let mut group = vec![i];
             processed.insert(i);
[31m-            
(B[m[32m+
(B[m             for j in (i + 1)..memories.len() {
                 if processed.contains(&j) {
                     continue;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:133:
                 }
[31m-                
(B[m[31m-                let similarity = self.calculate_similarity(&memories[i], &memories[j]).await?;
(B[m[31m-                
(B[m[32m+
(B[m[32m+                let similarity = self
(B[m[32m+                    .calculate_similarity(&memories[i], &memories[j])
(B[m[32m+                    .await?;
(B[m[32m+
(B[m                 if similarity >= self.threshold {
                     group.push(j);
                     processed.insert(j);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:140:
                 }
             }
[31m-            
(B[m[32m+
(B[m             if group.len() > 1 {
                 groups.push(group);
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:146:
         }
[31m-        
(B[m[32m+
(B[m         debug!("Found {} consolidation groups", groups.len());
         Ok(groups)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:151:
[31m-    
(B[m[32m+
(B[m     /// Calculate similarity between two memories
     async fn calculate_similarity(&mut self, memory1: &Memory, memory2: &Memory) -> Result<f32> {
         let key = if memory1.id < memory2.id {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:156:
         } else {
             (memory2.id.clone(), memory1.id.clone())
         };
[31m-        
(B[m[32m+
(B[m         if let Some(&cached_similarity) = self.similarity_cache.get(&key) {
             return Ok(cached_similarity);
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:163:
[31m-        
(B[m[32m+
(B[m         // Calculate text similarity
         let text_similarity = jaccard_similarity(&memory1.content, &memory2.content);
[31m-        
(B[m[32m+
(B[m         // Consider memory type similarity
[31m-        let type_similarity = if memory1.memory_type == memory2.memory_type { 1.0 } else { 0.5 };
(B[m[31m-        
(B[m[32m+        let type_similarity = if memory1.memory_type == memory2.memory_type {
(B[m[32m+            1.0
(B[m[32m+        } else {
(B[m[32m+            0.5
(B[m[32m+        };
(B[m[32m+
(B[m         // Consider temporal proximity (memories created close in time are more likely to be related)
         let time_diff = (memory1.created_at - memory2.created_at).abs() as f32;
         let max_time_diff = 24.0 * 60.0 * 60.0; // 24 hours in seconds
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:173:
         let temporal_similarity = (max_time_diff - time_diff.min(max_time_diff)) / max_time_diff;
[31m-        
(B[m[32m+
(B[m         // Weighted combination
         let similarity = text_similarity * 0.7 + type_similarity * 0.2 + temporal_similarity * 0.1;
[31m-        
(B[m[32m+
(B[m         self.similarity_cache.insert(key, similarity);
         Ok(similarity)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:181:
[31m-    
(B[m[32m+
(B[m     /// Merge a group of similar memories into one
[31m-    async fn merge_memory_group(&self, memories: &mut Vec<Memory>, group: &[usize]) -> Result<bool> {
(B[m[32m+    async fn merge_memory_group(
(B[m[32m+        &self,
(B[m[32m+        memories: &mut Vec<Memory>,
(B[m[32m+        group: &[usize],
(B[m[32m+    ) -> Result<bool> {
(B[m         if group.len() < 2 {
             return Ok(false);
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:187:
[31m-        
(B[m[32m+
(B[m         // Find the memory with highest importance to be the base
[31m-        let base_idx = group.iter()
(B[m[31m-            .max_by(|&&a, &&b| memories[a].importance.partial_cmp(&memories[b].importance).unwrap())
(B[m[32m+        let base_idx = group
(B[m[32m+            .iter()
(B[m[32m+            .max_by(|&&a, &&b| {
(B[m[32m+                memories[a]
(B[m[32m+                    .importance
(B[m[32m+                    .partial_cmp(&memories[b].importance)
(B[m[32m+                    .unwrap()
(B[m[32m+            })
(B[m             .copied()
             .unwrap();
[31m-        
(B[m[32m+
(B[m         let mut merged_content = memories[base_idx].content.clone();
         let mut merged_importance = memories[base_idx].importance;
         let mut merged_access_count = memories[base_idx].access_count;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:197:
[31m-        
(B[m[32m+
(B[m         // Merge content and aggregate statistics
         for &idx in group {
             if idx == base_idx {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:201:
                 continue;
             }
[31m-            
(B[m[32m+
(B[m             let memory = &memories[idx];
[31m-            
(B[m[32m+
(B[m             // Append unique content
             if !merged_content.contains(&memory.content) {
                 merged_content.push_str("\n\n");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:209:
                 merged_content.push_str(&memory.content);
             }
[31m-            
(B[m[32m+
(B[m             // Aggregate importance (weighted average)
             merged_importance = (merged_importance + memory.importance) / 2.0;
[31m-            
(B[m[32m+
(B[m             // Sum access counts
             merged_access_count += memory.access_count;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:218:
[31m-        
(B[m[32m+
(B[m         // Update the base memory
         memories[base_idx].content = merged_content;
         memories[base_idx].importance = merged_importance;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:222:
         memories[base_idx].access_count = merged_access_count;
         memories[base_idx].version += 1;
[31m-        
(B[m[32m+
(B[m         // Mark other memories for removal (set empty content as marker)
         for &idx in group {
             if idx != base_idx {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:228:
                 memories[idx].content = String::new(); // Mark for removal
             }
         }
[31m-        
(B[m[31m-        debug!("Merged {} memories into memory {}", group.len(), memories[base_idx].id);
(B[m[32m+
(B[m[32m+        debug!(
(B[m[32m+            "Merged {} memories into memory {}",
(B[m[32m+            group.len(),
(B[m[32m+            memories[base_idx].id
(B[m[32m+        );
(B[m         Ok(true)
     }
[31m-    
(B[m[32m+
(B[m     /// Create references between similar memories
[31m-    async fn create_memory_references(&self, memories: &mut Vec<Memory>, group: &[usize]) -> Result<bool> {
(B[m[32m+    async fn create_memory_references(
(B[m[32m+        &self,
(B[m[32m+        memories: &mut Vec<Memory>,
(B[m[32m+        group: &[usize],
(B[m[32m+    ) -> Result<bool> {
(B[m         if group.len() < 2 {
             return Ok(false);
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:241:
[31m-        
(B[m[32m+
(B[m         // Find the primary memory (highest importance)
[31m-        let primary_idx = group.iter()
(B[m[31m-            .max_by(|&&a, &&b| memories[a].importance.partial_cmp(&memories[b].importance).unwrap())
(B[m[32m+        let primary_idx = group
(B[m[32m+            .iter()
(B[m[32m+            .max_by(|&&a, &&b| {
(B[m[32m+                memories[a]
(B[m[32m+                    .importance
(B[m[32m+                    .partial_cmp(&memories[b].importance)
(B[m[32m+                    .unwrap()
(B[m[32m+            })
(B[m             .copied()
             .unwrap();
[31m-        
(B[m[32m+
(B[m         let primary_id = memories[primary_idx].id.clone();
[31m-        
(B[m[32m+
(B[m         // Add references to other memories
         for &idx in group {
             if idx == primary_idx {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:253:
                 continue;
             }
[31m-            
(B[m[31m-            memories[idx].metadata.insert(
(B[m[31m-                "consolidated_with".to_string(),
(B[m[31m-                primary_id.clone(),
(B[m[31m-            );
(B[m[31m-            memories[idx].metadata.insert(
(B[m[31m-                "consolidation_type".to_string(),
(B[m[31m-                "reference".to_string(),
(B[m[31m-            );
(B[m[32m+
(B[m[32m+            memories[idx]
(B[m[32m+                .metadata
(B[m[32m+                .insert("consolidated_with".to_string(), primary_id.clone());
(B[m[32m+            memories[idx]
(B[m[32m+                .metadata
(B[m[32m+                .insert("consolidation_type".to_string(), "reference".to_string());
(B[m         }
[31m-        
(B[m[32m+
(B[m         // Add reference list to primary memory
[31m-        let reference_ids: Vec<String> = group.iter()
(B[m[32m+        let reference_ids: Vec<String> = group
(B[m[32m+            .iter()
(B[m             .filter(|&&idx| idx != primary_idx)
             .map(|&idx| memories[idx].id.clone())
             .collect();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:271:
[31m-        
(B[m[31m-        memories[primary_idx].metadata.insert(
(B[m[31m-            "references".to_string(),
(B[m[31m-            reference_ids.join(","),
(B[m[31m-        );
(B[m[31m-        
(B[m[32m+
(B[m[32m+        memories[primary_idx]
(B[m[32m+            .metadata
(B[m[32m+            .insert("references".to_string(), reference_ids.join(","));
(B[m[32m+
(B[m         debug!("Created references for {} memories", group.len());
         Ok(true)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:280:
[31m-    
(B[m[32m+
(B[m     /// Group similar memories without merging
     async fn group_memories(&self, memories: &mut Vec<Memory>, group: &[usize]) -> Result<bool> {
         if group.len() < 2 {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:284:
             return Ok(false);
         }
[31m-        
(B[m[32m+
(B[m         let group_id = uuid::Uuid::new_v4().to_string();
[31m-        
(B[m[32m+
(B[m         // Add group metadata to all memories in the group
         for &idx in group {
[31m-            memories[idx].metadata.insert(
(B[m[31m-                "memory_group".to_string(),
(B[m[31m-                group_id.clone(),
(B[m[31m-            );
(B[m[31m-            memories[idx].metadata.insert(
(B[m[31m-                "group_size".to_string(),
(B[m[31m-                group.len().to_string(),
(B[m[31m-            );
(B[m[32m+            memories[idx]
(B[m[32m+                .metadata
(B[m[32m+                .insert("memory_group".to_string(), group_id.clone());
(B[m[32m+            memories[idx]
(B[m[32m+                .metadata
(B[m[32m+                .insert("group_size".to_string(), group.len().to_string());
(B[m         }
[31m-        
(B[m[31m-        debug!("Grouped {} memories with group ID {}", group.len(), group_id);
(B[m[32m+
(B[m[32m+        debug!(
(B[m[32m+            "Grouped {} memories with group ID {}",
(B[m[32m+            group.len(),
(B[m[32m+            group_id
(B[m[32m+        );
(B[m         Ok(true)
     }
[31m-    
(B[m[32m+
(B[m     /// Clean up memories marked for removal
     pub fn cleanup_removed_memories(&self, memories: &mut Vec<Memory>) {
         memories.retain(|memory| !memory.content.is_empty());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:338:
         let consolidator = MemoryConsolidator::new(0.8);
         assert_eq!(consolidator.threshold, 0.8);
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_similarity_calculation() {
         let mut consolidator = MemoryConsolidator::new(0.8);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:345:
[31m-        
(B[m[32m+
(B[m         let memory1 = create_test_memory("1", "I love programming", 0.8);
         let memory2 = create_test_memory("2", "Programming is great", 0.7);
         let memory3 = create_test_memory("3", "The weather is nice", 0.6);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:349:
[31m-        
(B[m[31m-        let sim1_2 = consolidator.calculate_similarity(&memory1, &memory2).await.unwrap();
(B[m[31m-        let sim1_3 = consolidator.calculate_similarity(&memory1, &memory3).await.unwrap();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let sim1_2 = consolidator
(B[m[32m+            .calculate_similarity(&memory1, &memory2)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+        let sim1_3 = consolidator
(B[m[32m+            .calculate_similarity(&memory1, &memory3)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Programming-related memories should be more similar, but jaccard similarity might not always reflect this
         // Just check that similarities are valid values
         assert!(sim1_2 >= 0.0 && sim1_2 <= 1.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:356:
         assert!(sim1_3 >= 0.0 && sim1_3 <= 1.0);
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_consolidation_groups() {
         let mut consolidator = MemoryConsolidator::new(0.5);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:362:
[31m-        
(B[m[32m+
(B[m         let memories = vec![
             create_test_memory("1", "I love programming", 0.8),
             create_test_memory("2", "Programming is great", 0.7),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:366:
             create_test_memory("3", "The weather is nice", 0.6),
             create_test_memory("4", "Nice weather today", 0.5),
         ];
[31m-        
(B[m[31m-        let groups = consolidator.find_consolidation_groups(&memories).await.unwrap();
(B[m[32m+
(B[m[32m+        let groups = consolidator
(B[m[32m+            .find_consolidation_groups(&memories)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m         // Groups might be empty if no memories are similar enough
         assert!(groups.len() >= 0);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:374:
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_memory_consolidation() {
         let mut consolidator = MemoryConsolidator::new(0.5);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:378:
[31m-        
(B[m[32m+
(B[m         let mut memories = vec![
             create_test_memory("1", "I love programming", 0.8),
             create_test_memory("2", "Programming is great", 0.7),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/consolidation.rs:382:
             create_test_memory("3", "The weather is nice", 0.6),
         ];
[31m-        
(B[m[32m+
(B[m         let original_count = memories.len();
[31m-        let consolidated = consolidator.consolidate_memories(&mut memories).await.unwrap();
(B[m[31m-        
(B[m[32m+        let consolidated = consolidator
(B[m[32m+            .consolidate_memories(&mut memories)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         // Should have found some consolidations (or none, which is also valid)
         assert!(consolidated == 0 || consolidated > 0);
[31m-        
(B[m[32m+
(B[m         // Clean up removed memories
         consolidator.cleanup_removed_memories(&mut memories);
[31m-        
(B[m[32m+
(B[m         // Should have fewer or equal memories after consolidation
         assert!(memories.len() <= original_count);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:1:
 //! Memory importance scoring algorithms
[31m-//! 
(B[m[32m+//!
(B[m //! Implements intelligent importance scoring based on multiple factors
 //! including recency, frequency, relevance, and context.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:6:
 use agent_mem_core::Memory;
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use tracing::{debug, info};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:14:
 pub struct ImportanceFactors {
     /// Recency weight (how recent the memory is)
     pub recency_weight: f32,
[31m-    
(B[m[32m+
(B[m     /// Frequency weight (how often the memory is accessed)
     pub frequency_weight: f32,
[31m-    
(B[m[32m+
(B[m     /// Content relevance weight
     pub relevance_weight: f32,
[31m-    
(B[m[32m+
(B[m     /// Emotional significance weight
     pub emotional_weight: f32,
[31m-    
(B[m[32m+
(B[m     /// Context importance weight
     pub context_weight: f32,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:55:
 pub struct ImportanceScorer {
     /// Decay rate for importance over time
     decay_rate: f32,
[31m-    
(B[m[32m+
(B[m     /// Scoring factors
     factors: ImportanceFactors,
[31m-    
(B[m[32m+
(B[m     /// Scoring strategy
     strategy: ScoringStrategy,
[31m-    
(B[m[32m+
(B[m     /// Context keywords for relevance scoring
     context_keywords: HashMap<String, f32>,
[31m-    
(B[m[32m+
(B[m     /// Emotional keywords for emotional scoring
     emotional_keywords: HashMap<String, f32>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:80:
             emotional_keywords: Self::default_emotional_keywords(),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Set scoring factors
     pub fn with_factors(mut self, factors: ImportanceFactors) -> Self {
         self.factors = factors;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:87:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set scoring strategy
     pub fn with_strategy(mut self, strategy: ScoringStrategy) -> Self {
         self.strategy = strategy;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:93:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Update decay rate
     pub fn update_decay_rate(&mut self, decay_rate: f32) {
         self.decay_rate = decay_rate;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:99:
     }
[31m-    
(B[m[32m+
(B[m     /// Update importance scores for a batch of memories
     pub async fn update_importance_scores(&mut self, memories: &mut [Memory]) -> Result<usize> {
         info!("Updating importance scores for {} memories", memories.len());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:104:
[31m-        
(B[m[32m+
(B[m         let mut updated_count = 0;
         let current_time = chrono::Utc::now().timestamp();
[31m-        
(B[m[32m+
(B[m         for memory in memories.iter_mut() {
             let old_importance = memory.importance;
[31m-            let new_importance = self.calculate_importance_score(memory, current_time).await?;
(B[m[31m-            
(B[m[32m+            let new_importance = self
(B[m[32m+                .calculate_importance_score(memory, current_time)
(B[m[32m+                .await?;
(B[m[32m+
(B[m             if (new_importance - old_importance).abs() > 0.01 {
                 memory.importance = new_importance;
                 memory.version += 1;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:115:
                 updated_count += 1;
             }
         }
[31m-        
(B[m[32m+
(B[m         info!("Updated importance scores for {} memories", updated_count);
         Ok(updated_count)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:122:
[31m-    
(B[m[32m+
(B[m     /// Score a single memory
     pub async fn score_single_memory(&mut self, memory: &mut Memory) -> Result<()> {
         let current_time = chrono::Utc::now().timestamp();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:126:
[31m-        let new_importance = self.calculate_importance_score(memory, current_time).await?;
(B[m[31m-        
(B[m[32m+        let new_importance = self
(B[m[32m+            .calculate_importance_score(memory, current_time)
(B[m[32m+            .await?;
(B[m[32m+
(B[m         if (new_importance - memory.importance).abs() > 0.01 {
             memory.importance = new_importance;
             memory.version += 1;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:131:
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Calculate importance score for a memory
     async fn calculate_importance_score(&self, memory: &Memory, current_time: i64) -> Result<f32> {
         let recency_score = self.calculate_recency_score(memory, current_time);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:140:
         let relevance_score = self.calculate_relevance_score(memory);
         let emotional_score = self.calculate_emotional_score(memory);
         let context_score = self.calculate_context_score(memory);
[31m-        
(B[m[32m+
(B[m         let importance = match self.strategy {
             ScoringStrategy::Weighted => {
                 recency_score * self.factors.recency_weight
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:149:
                     + emotional_score * self.factors.emotional_weight
                     + context_score * self.factors.context_weight
             }
[31m-            ScoringStrategy::Maximum => {
(B[m[31m-                [recency_score, frequency_score, relevance_score, emotional_score, context_score]
(B[m[31m-                    .iter()
(B[m[31m-                    .fold(0.0f32, |acc, &x| acc.max(x))
(B[m[31m-            }
(B[m[31m-            ScoringStrategy::Adaptive => {
(B[m[31m-                self.calculate_adaptive_score(
(B[m[31m-                    memory,
(B[m[31m-                    recency_score,
(B[m[31m-                    frequency_score,
(B[m[31m-                    relevance_score,
(B[m[31m-                    emotional_score,
(B[m[31m-                    context_score,
(B[m[31m-                )
(B[m[31m-            }
(B[m[32m+            ScoringStrategy::Maximum => [
(B[m[32m+                recency_score,
(B[m[32m+                frequency_score,
(B[m[32m+                relevance_score,
(B[m[32m+                emotional_score,
(B[m[32m+                context_score,
(B[m[32m+            ]
(B[m[32m+            .iter()
(B[m[32m+            .fold(0.0f32, |acc, &x| acc.max(x)),
(B[m[32m+            ScoringStrategy::Adaptive => self.calculate_adaptive_score(
(B[m[32m+                memory,
(B[m[32m+                recency_score,
(B[m[32m+                frequency_score,
(B[m[32m+                relevance_score,
(B[m[32m+                emotional_score,
(B[m[32m+                context_score,
(B[m[32m+            ),
(B[m         };
[31m-        
(B[m[32m+
(B[m         // Apply decay based on time since last access
         let time_since_access = current_time - memory.last_accessed_at;
[31m-        let decay_factor = self.decay_rate.powf(time_since_access as f32 / (24.0 * 60.0 * 60.0)); // Daily decay
(B[m[31m-        
(B[m[32m+        let decay_factor = self
(B[m[32m+            .decay_rate
(B[m[32m+            .powf(time_since_access as f32 / (24.0 * 60.0 * 60.0)); // Daily decay
(B[m[32m+
(B[m         Ok((importance * decay_factor).clamp(0.0, 1.0))
     }
[31m-    
(B[m[32m+
(B[m     /// Calculate recency score (newer memories are more important)
     fn calculate_recency_score(&self, memory: &Memory, current_time: i64) -> f32 {
         let age_seconds = current_time - memory.created_at;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:179:
         let max_age = 30.0 * 24.0 * 60.0 * 60.0; // 30 days in seconds
[31m-        
(B[m[32m+
(B[m         if age_seconds <= 0 {
             return 1.0;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:184:
[31m-        
(B[m[32m+
(B[m         let age_factor = (max_age - age_seconds as f32).max(0.0) / max_age;
         age_factor.clamp(0.0, 1.0)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:188:
[31m-    
(B[m[32m+
(B[m     /// Calculate frequency score (more accessed memories are more important)
     fn calculate_frequency_score(&self, memory: &Memory) -> f32 {
         let max_access_count = 100.0; // Normalize to this maximum
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:192:
         (memory.access_count as f32 / max_access_count).clamp(0.0, 1.0)
     }
[31m-    
(B[m[32m+
(B[m     /// Calculate relevance score based on content length and complexity
     fn calculate_relevance_score(&self, memory: &Memory) -> f32 {
         let content_length = memory.content.len() as f32;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:198:
         let word_count = memory.content.split_whitespace().count() as f32;
[31m-        
(B[m[32m+
(B[m         // Longer, more detailed memories are generally more important
         let length_score = (content_length / 1000.0).clamp(0.0, 1.0);
         let complexity_score = (word_count / 100.0).clamp(0.0, 1.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:203:
[31m-        
(B[m[32m+
(B[m         (length_score + complexity_score) / 2.0
     }
[31m-    
(B[m[32m+
(B[m     /// Calculate emotional score based on emotional keywords
     fn calculate_emotional_score(&self, memory: &Memory) -> f32 {
         let content_lower = memory.content.to_lowercase();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:210:
         let mut emotional_score = 0.0;
         let mut keyword_count = 0;
[31m-        
(B[m[32m+
(B[m         for (keyword, weight) in &self.emotional_keywords {
             if content_lower.contains(keyword) {
                 emotional_score += weight;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:216:
                 keyword_count += 1;
             }
         }
[31m-        
(B[m[32m+
(B[m         if keyword_count > 0 {
             (emotional_score / keyword_count as f32).clamp(0.0, 1.0)
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:223:
             0.0
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Calculate context score based on context keywords
     fn calculate_context_score(&self, memory: &Memory) -> f32 {
         let content_lower = memory.content.to_lowercase();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:230:
         let mut context_score = 0.0;
         let mut keyword_count = 0;
[31m-        
(B[m[32m+
(B[m         for (keyword, weight) in &self.context_keywords {
             if content_lower.contains(keyword) {
                 context_score += weight;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:236:
                 keyword_count += 1;
             }
         }
[31m-        
(B[m[32m+
(B[m         if keyword_count > 0 {
             (context_score / keyword_count as f32).clamp(0.0, 1.0)
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:243:
             0.0
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Calculate adaptive score based on memory type
     fn calculate_adaptive_score(
         &self,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:255:
         context: f32,
     ) -> f32 {
         use agent_mem_core::MemoryType;
[31m-        
(B[m[32m+
(B[m         match memory.memory_type {
             MemoryType::Episodic => {
                 // Episodic memories: prioritize recency and emotional content
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:275:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Default context keywords with weights
     fn default_context_keywords() -> HashMap<String, f32> {
         let mut keywords = HashMap::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:291:
         keywords.insert("goal".to_string(), 0.8);
         keywords
     }
[31m-    
(B[m[32m+
(B[m     /// Default emotional keywords with weights
     fn default_emotional_keywords() -> HashMap<String, f32> {
         let mut keywords = HashMap::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:341:
         let scorer = ImportanceScorer::new(0.95);
         assert_eq!(scorer.decay_rate, 0.95);
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_recency_scoring() {
         let scorer = ImportanceScorer::new(0.95);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:348:
         let current_time = Utc::now().timestamp();
[31m-        
(B[m[32m+
(B[m         let recent_memory = create_test_memory("1", "Recent memory", 1);
         let old_memory = Memory {
             created_at: current_time - 7 * 24 * 60 * 60, // 7 days ago
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:353:
             ..create_test_memory("2", "Old memory", 1)
         };
[31m-        
(B[m[32m+
(B[m         let recent_score = scorer.calculate_recency_score(&recent_memory, current_time);
         let old_score = scorer.calculate_recency_score(&old_memory, current_time);
[31m-        
(B[m[32m+
(B[m         assert!(recent_score > old_score);
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_frequency_scoring() {
         let scorer = ImportanceScorer::new(0.95);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:365:
[31m-        
(B[m[32m+
(B[m         let frequent_memory = create_test_memory("1", "Frequent memory", 50);
         let rare_memory = create_test_memory("2", "Rare memory", 1);
[31m-        
(B[m[32m+
(B[m         let frequent_score = scorer.calculate_frequency_score(&frequent_memory);
         let rare_score = scorer.calculate_frequency_score(&rare_memory);
[31m-        
(B[m[32m+
(B[m         assert!(frequent_score > rare_score);
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_emotional_scoring() {
         let scorer = ImportanceScorer::new(0.95);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:378:
[31m-        
(B[m[32m+
(B[m         let emotional_memory = create_test_memory("1", "I love this amazing project!", 1);
         let neutral_memory = create_test_memory("2", "The weather is okay today.", 1);
[31m-        
(B[m[32m+
(B[m         let emotional_score = scorer.calculate_emotional_score(&emotional_memory);
         let neutral_score = scorer.calculate_emotional_score(&neutral_memory);
[31m-        
(B[m[32m+
(B[m         assert!(emotional_score > neutral_score);
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_importance_calculation() {
         let mut scorer = ImportanceScorer::new(0.95);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:391:
         let current_time = Utc::now().timestamp();
[31m-        
(B[m[32m+
(B[m         let memory = create_test_memory("1", "This is an important memory to remember!", 10);
[31m-        let importance = scorer.calculate_importance_score(&memory, current_time).await.unwrap();
(B[m[31m-        
(B[m[32m+        let importance = scorer
(B[m[32m+            .calculate_importance_score(&memory, current_time)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m         assert!(importance > 0.0);
         assert!(importance <= 1.0);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:399:
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_batch_scoring() {
         let mut scorer = ImportanceScorer::new(0.95);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:403:
[31m-        
(B[m[32m+
(B[m         let mut memories = vec![
             create_test_memory("1", "Important memory", 10),
             create_test_memory("2", "Less important memory", 1),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/importance.rs:407:
             create_test_memory("3", "Critical deadline tomorrow!", 5),
         ];
[31m-        
(B[m[31m-        let updated_count = scorer.update_importance_scores(&mut memories).await.unwrap();
(B[m[32m+
(B[m[32m+        let updated_count = scorer
(B[m[32m+            .update_importance_scores(&mut memories)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m         // Updated count should be valid (0 or positive)
         assert!(updated_count == 0 || updated_count > 0);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:1:
 //! Intelligent memory processing algorithms
[31m-//! 
(B[m[32m+//!
(B[m //! Advanced algorithms for memory consolidation, importance scoring,
 //! and adaptive memory management.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:6:
[32m+pub mod adaptive;
(B[m pub mod consolidation;
 pub mod importance;
[31m-pub mod adaptive;
(B[m 
[32m+pub use adaptive::*;
(B[m pub use consolidation::*;
 pub use importance::*;
[31m-pub use adaptive::*;
(B[m 
 use agent_mem_core::{Memory, MemoryType};
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:21:
 pub struct ProcessingConfig {
     /// Enable automatic consolidation
     pub enable_consolidation: bool,
[31m-    
(B[m[32m+
(B[m     /// Consolidation threshold (similarity score)
     pub consolidation_threshold: f32,
[31m-    
(B[m[32m+
(B[m     /// Enable importance scoring
     pub enable_importance_scoring: bool,
[31m-    
(B[m[32m+
(B[m     /// Importance decay rate over time
     pub importance_decay_rate: f32,
[31m-    
(B[m[32m+
(B[m     /// Enable adaptive memory management
     pub enable_adaptive_management: bool,
[31m-    
(B[m[32m+
(B[m     /// Maximum memories per scope
     pub max_memories_per_scope: usize,
[31m-    
(B[m[32m+
(B[m     /// Memory retention period (in seconds)
     pub retention_period: i64,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:60:
 pub struct ProcessingStats {
     /// Number of memories processed
     pub processed_count: usize,
[31m-    
(B[m[32m+
(B[m     /// Number of memories consolidated
     pub consolidated_count: usize,
[31m-    
(B[m[32m+
(B[m     /// Number of memories with updated importance
     pub importance_updated_count: usize,
[31m-    
(B[m[32m+
(B[m     /// Number of memories archived
     pub archived_count: usize,
[31m-    
(B[m[32m+
(B[m     /// Number of memories deleted
     pub deleted_count: usize,
[31m-    
(B[m[32m+
(B[m     /// Processing time in milliseconds
     pub processing_time_ms: u64,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:103:
     pub fn new(config: ProcessingConfig) -> Self {
         let consolidator = MemoryConsolidator::new(config.consolidation_threshold);
         let importance_scorer = ImportanceScorer::new(config.importance_decay_rate);
[31m-        let adaptive_manager = AdaptiveMemoryManager::new(
(B[m[31m-            config.max_memories_per_scope,
(B[m[31m-            config.retention_period,
(B[m[31m-        );
(B[m[31m-        
(B[m[32m+        let adaptive_manager =
(B[m[32m+            AdaptiveMemoryManager::new(config.max_memories_per_scope, config.retention_period);
(B[m[32m+
(B[m         Self {
             config,
             consolidator,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:115:
             adaptive_manager,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Process a batch of memories
[31m-    pub async fn process_memories(&mut self, memories: &mut Vec<Memory>) -> Result<ProcessingStats> {
(B[m[32m+    pub async fn process_memories(
(B[m[32m+        &mut self,
(B[m[32m+        memories: &mut Vec<Memory>,
(B[m[32m+    ) -> Result<ProcessingStats> {
(B[m         let start_time = std::time::Instant::now();
         let mut stats = ProcessingStats::default();
         stats.processed_count = memories.len();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:124:
[31m-        
(B[m[32m+
(B[m         // Step 1: Consolidation
         if self.config.enable_consolidation {
             let consolidated = self.consolidator.consolidate_memories(memories).await?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:128:
             stats.consolidated_count = consolidated;
         }
[31m-        
(B[m[32m+
(B[m         // Step 2: Importance scoring
         if self.config.enable_importance_scoring {
[31m-            let updated = self.importance_scorer.update_importance_scores(memories).await?;
(B[m[32m+            let updated = self
(B[m[32m+                .importance_scorer
(B[m[32m+                .update_importance_scores(memories)
(B[m[32m+                .await?;
(B[m             stats.importance_updated_count = updated;
         }
[31m-        
(B[m[32m+
(B[m         // Step 3: Adaptive management
         if self.config.enable_adaptive_management {
             let (archived, deleted) = self.adaptive_manager.manage_memories(memories).await?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:140:
             stats.archived_count = archived;
             stats.deleted_count = deleted;
         }
[31m-        
(B[m[32m+
(B[m         stats.processing_time_ms = start_time.elapsed().as_millis() as u64;
         Ok(stats)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:147:
[31m-    
(B[m[32m+
(B[m     /// Process a single memory
     pub async fn process_single_memory(&mut self, memory: &mut Memory) -> Result<()> {
         // Update importance score
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:151:
         if self.config.enable_importance_scoring {
             self.importance_scorer.score_single_memory(memory).await?;
         }
[31m-        
(B[m[32m+
(B[m         // Check if memory should be archived or deleted
         if self.config.enable_adaptive_management {
             self.adaptive_manager.evaluate_single_memory(memory).await?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:158:
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Get processing configuration
     pub fn config(&self) -> &ProcessingConfig {
         &self.config
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:166:
     }
[31m-    
(B[m[32m+
(B[m     /// Update processing configuration
     pub fn update_config(&mut self, config: ProcessingConfig) {
         self.config = config.clone();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:171:
[31m-        self.consolidator.update_threshold(config.consolidation_threshold);
(B[m[31m-        self.importance_scorer.update_decay_rate(config.importance_decay_rate);
(B[m[31m-        self.adaptive_manager.update_limits(
(B[m[31m-            config.max_memories_per_scope,
(B[m[31m-            config.retention_period,
(B[m[31m-        );
(B[m[32m+        self.consolidator
(B[m[32m+            .update_threshold(config.consolidation_threshold);
(B[m[32m+        self.importance_scorer
(B[m[32m+            .update_decay_rate(config.importance_decay_rate);
(B[m[32m+        self.adaptive_manager
(B[m[32m+            .update_limits(config.max_memories_per_scope, config.retention_period);
(B[m     }
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:208:
         assert!(processor.config().enable_importance_scoring);
         assert!(processor.config().enable_adaptive_management);
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_process_memories() {
         let config = ProcessingConfig::default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:215:
         let mut processor = MemoryProcessor::new(config);
[31m-        
(B[m[32m+
(B[m         let mut memories = vec![
             create_test_memory("mem1", "First memory", 0.8),
             create_test_memory("mem2", "Second memory", 0.6),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:220:
             create_test_memory("mem3", "Third memory", 0.9),
         ];
[31m-        
(B[m[32m+
(B[m         let stats = processor.process_memories(&mut memories).await.unwrap();
         assert_eq!(stats.processed_count, 3);
         // Processing time might be 0 in fast tests, so just check it's valid
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:226:
         assert!(stats.processing_time_ms >= 0);
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_process_single_memory() {
         let config = ProcessingConfig::default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:232:
         let mut processor = MemoryProcessor::new(config);
[31m-        
(B[m[32m+
(B[m         let mut memory = create_test_memory("mem1", "Test memory", 0.7);
         let result = processor.process_single_memory(&mut memory).await;
         assert!(result.is_ok());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:237:
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_config_update() {
         let mut config = ProcessingConfig::default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:242:
         let mut processor = MemoryProcessor::new(config.clone());
[31m-        
(B[m[32m+
(B[m         config.consolidation_threshold = 0.9;
         config.importance_decay_rate = 0.8;
         processor.update_config(config.clone());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/processing/mod.rs:247:
[31m-        
(B[m[32m+
(B[m         assert_eq!(processor.config().consolidation_threshold, 0.9);
         assert_eq!(processor.config().importance_decay_rate, 0.8);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:1:
 //! 记忆推理和关联分析模块
 
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m[32m+use chrono::{DateTime, Utc};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::{HashMap, HashSet};
[31m-use chrono::{DateTime, Utc};
(B[m 
 /// 推理结果
 #[derive(Debug, Clone, Serialize, Deserialize)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:97:
                 }
 
                 if let Some(ref candidate_embedding) = candidate.embedding {
[31m-                    let similarity = self.cosine_similarity(query_embedding, candidate_embedding)?;
(B[m[31m-                    
(B[m[32m+                    let similarity =
(B[m[32m+                        self.cosine_similarity(query_embedding, candidate_embedding)?;
(B[m[32m+
(B[m                     if similarity >= self.config.similarity_threshold {
                         let confidence = similarity;
                         let conclusion = format!(
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:105:
                             "Memory '{}' is highly similar to memory '{}'",
                             query_memory.id, candidate.id
                         );
[31m-                        
(B[m[32m+
(B[m                         let evidence = vec![
                             format!("Cosine similarity: {:.3}", similarity),
                             format!("Content overlap detected"),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:125:
         }
 
         // 按置信度排序
[31m-        results.sort_by(|a, b| b.confidence.partial_cmp(&a.confidence).unwrap_or(std::cmp::Ordering::Equal));
(B[m[32m+        results.sort_by(|a, b| {
(B[m[32m+            b.confidence
(B[m[32m+                .partial_cmp(&a.confidence)
(B[m[32m+                .unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+        });
(B[m         results.truncate(self.config.max_associations);
 
         Ok(results)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:147:
         for window_size in 2..=3 {
             for i in 0..=sorted_memories.len().saturating_sub(window_size) {
                 let window = &sorted_memories[i..i + window_size];
[31m-                
(B[m[32m+
(B[m                 if let Some(pattern) = self.detect_temporal_pattern(window) {
                     let confidence = self.calculate_temporal_confidence(&pattern);
[31m-                    
(B[m[32m+
(B[m                     if confidence >= self.config.min_confidence {
                         let memory_ids: Vec<String> = window.iter().map(|m| m.id.clone()).collect();
[31m-                        
(B[m[32m+
(B[m                         results.push(ReasoningResult {
                             reasoning_type: "temporal".to_string(),
                             confidence,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:194:
                     memory_keywords.get(&memory2.id),
                 ) {
                     let overlap = self.calculate_keyword_overlap(keywords1, keywords2);
[31m-                    
(B[m[32m+
(B[m                     if overlap >= self.config.similarity_threshold {
                         let confidence = overlap;
[31m-                        let shared_keywords: Vec<String> = keywords1
(B[m[31m-                            .intersection(keywords2)
(B[m[31m-                            .cloned()
(B[m[31m-                            .collect();
(B[m[32m+                        let shared_keywords: Vec<String> =
(B[m[32m+                            keywords1.intersection(keywords2).cloned().collect();
(B[m 
                         let conclusion = format!(
                             "Memories '{}' and '{}' share common themes",
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:229:
     }
 
     /// 发现记忆关联
[31m-    pub fn discover_associations(
(B[m[31m-        &self,
(B[m[31m-        memories: &[MemoryData],
(B[m[31m-    ) -> Result<Vec<MemoryAssociation>> {
(B[m[32m+    pub fn discover_associations(&self, memories: &[MemoryData]) -> Result<Vec<MemoryAssociation>> {
(B[m         let mut associations = Vec::new();
 
         // 基于相似度的关联
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:289:
         // 计算时间间隔
         let mut intervals = Vec::new();
         for i in 1..window.len() {
[31m-            let interval = window[i].created_at.signed_duration_since(window[i - 1].created_at);
(B[m[32m+            let interval = window[i]
(B[m[32m+                .created_at
(B[m[32m+                .signed_duration_since(window[i - 1].created_at);
(B[m             intervals.push(interval.num_hours());
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:296:
         // 检查是否有规律性
         let avg_interval = intervals.iter().sum::<i64>() as f64 / intervals.len() as f64;
[31m-        let variance = intervals.iter()
(B[m[32m+        let variance = intervals
(B[m[32m+            .iter()
(B[m             .map(|&x| (x as f64 - avg_interval).powi(2))
[31m-            .sum::<f64>() / intervals.len() as f64;
(B[m[32m+            .sum::<f64>()
(B[m[32m+            / intervals.len() as f64;
(B[m 
[31m-        if variance < 100.0 { // 低方差表示规律性
(B[m[32m+        if variance < 100.0 {
(B[m[32m+            // 低方差表示规律性
(B[m             Some(TemporalPattern {
[31m-                description: format!("Regular pattern with average interval of {:.1} hours", avg_interval),
(B[m[32m+                description: format!(
(B[m[32m+                    "Regular pattern with average interval of {:.1} hours",
(B[m[32m+                    avg_interval
(B[m[32m+                ),
(B[m                 evidence: vec![
                     format!("Average interval: {:.1} hours", avg_interval),
                     format!("Variance: {:.2}", variance),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:328:
             .to_lowercase()
             .split_whitespace()
             .filter(|word| word.len() > 3) // 过滤短词
[31m-            .map(|word| word.trim_matches(|c: char| !c.is_alphanumeric()).to_string())
(B[m[32m+            .map(|word| {
(B[m[32m+                word.trim_matches(|c: char| !c.is_alphanumeric())
(B[m[32m+                    .to_string()
(B[m[32m+            })
(B[m             .filter(|word| !word.is_empty())
             .collect()
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:335:
 
     /// 计算关键词重叠度
[31m-    fn calculate_keyword_overlap(&self, keywords1: &HashSet<String>, keywords2: &HashSet<String>) -> f32 {
(B[m[32m+    fn calculate_keyword_overlap(
(B[m[32m+        &self,
(B[m[32m+        keywords1: &HashSet<String>,
(B[m[32m+        keywords2: &HashSet<String>,
(B[m[32m+    ) -> f32 {
(B[m         let intersection_size = keywords1.intersection(keywords2).count();
         let union_size = keywords1.union(keywords2).count();
[31m-        
(B[m[32m+
(B[m         if union_size == 0 {
             0.0
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:348:
     /// 计算余弦相似度
     fn cosine_similarity(&self, a: &[f32], b: &[f32]) -> Result<f32> {
         if a.len() != b.len() {
[31m-            return Err(AgentMemError::validation_error("Vector dimensions must match"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Vector dimensions must match",
(B[m[32m+            ));
(B[m         }
 
         let dot_product: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:412:
     #[test]
     fn test_reason_by_similarity() {
         let reasoner = MemoryReasoner::default();
[31m-        
(B[m[32m+
(B[m         let query_memory = create_test_memory("1", "test content", vec![1.0, 0.0, 0.0]);
         let candidates = vec![
             create_test_memory("2", "similar content", vec![0.9, 0.1, 0.0]),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:419:
             create_test_memory("3", "different content", vec![0.0, 0.0, 1.0]),
         ];
 
[31m-        let results = reasoner.reason_by_similarity(&query_memory, &candidates).unwrap();
(B[m[32m+        let results = reasoner
(B[m[32m+            .reason_by_similarity(&query_memory, &candidates)
(B[m[32m+            .unwrap();
(B[m         assert!(!results.is_empty());
[31m-        
(B[m[32m+
(B[m         for result in &results {
             assert_eq!(result.reasoning_type, "similarity");
             assert!(result.confidence >= reasoner.config.similarity_threshold);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:433:
         let reasoner = MemoryReasoner::default();
         let content = "This is a test content with some important keywords";
         let keywords = reasoner.extract_keywords(content);
[31m-        
(B[m[32m+
(B[m         assert!(keywords.contains("test"));
         assert!(keywords.contains("content"));
         assert!(keywords.contains("important"));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:444:
     #[test]
     fn test_calculate_keyword_overlap() {
         let reasoner = MemoryReasoner::default();
[31m-        
(B[m[31m-        let keywords1: HashSet<String> = ["hello", "world", "test"].iter().map(|s| s.to_string()).collect();
(B[m[31m-        let keywords2: HashSet<String> = ["hello", "world", "example"].iter().map(|s| s.to_string()).collect();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let keywords1: HashSet<String> = ["hello", "world", "test"]
(B[m[32m+            .iter()
(B[m[32m+            .map(|s| s.to_string())
(B[m[32m+            .collect();
(B[m[32m+        let keywords2: HashSet<String> = ["hello", "world", "example"]
(B[m[32m+            .iter()
(B[m[32m+            .map(|s| s.to_string())
(B[m[32m+            .collect();
(B[m[32m+
(B[m         let overlap = reasoner.calculate_keyword_overlap(&keywords1, &keywords2);
         assert!(overlap > 0.0);
         assert!(overlap < 1.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:456:
     #[test]
     fn test_reason_by_content_analysis() {
         let reasoner = MemoryReasoner::default();
[31m-        
(B[m[32m+
(B[m         let memories = vec![
             create_test_memory("1", "machine learning algorithms", vec![1.0, 0.0]),
             create_test_memory("2", "deep learning neural networks", vec![0.0, 1.0]),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:464:
         ];
 
         let results = reasoner.reason_by_content_analysis(&memories).unwrap();
[31m-        
(B[m[32m+
(B[m         for result in &results {
             assert_eq!(result.reasoning_type, "content");
             assert!(result.confidence >= 0.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:475:
     #[test]
     fn test_discover_associations() {
         let reasoner = MemoryReasoner::default();
[31m-        
(B[m[32m+
(B[m         let memories = vec![
[31m-            create_test_memory("1", "artificial intelligence machine learning", vec![1.0, 0.0]),
(B[m[32m+            create_test_memory(
(B[m[32m+                "1",
(B[m[32m+                "artificial intelligence machine learning",
(B[m[32m+                vec![1.0, 0.0],
(B[m[32m+            ),
(B[m             create_test_memory("2", "machine learning deep learning", vec![0.9, 0.1]),
         ];
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:484:
         let associations = reasoner.discover_associations(&memories).unwrap();
[31m-        
(B[m[32m+
(B[m         for association in &associations {
             assert!(!association.source_memory_id.is_empty());
             assert!(!association.target_memory_id.is_empty());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:494:
     #[test]
     fn test_cosine_similarity() {
         let reasoner = MemoryReasoner::default();
[31m-        
(B[m[32m+
(B[m         let a = vec![1.0, 0.0, 0.0];
         let b = vec![1.0, 0.0, 0.0];
         let similarity = reasoner.cosine_similarity(&a, &b).unwrap();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/reasoning/mod.rs:501:
         assert!((similarity - 1.0).abs() < 1e-6);
[31m-        
(B[m[32m+
(B[m         let c = vec![0.0, 1.0, 0.0];
         let similarity2 = reasoner.cosine_similarity(&a, &c).unwrap();
         assert!((similarity2 - 0.0).abs() < 1e-6);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:1:
 //! 混合相似度计算实现
 
 use super::{SemanticSimilarity, TextualSimilarity};
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:85:
         vector2: &[f32],
     ) -> Result<HybridSimilarityResult> {
         // 计算语义相似度
[31m-        let semantic_result = self.semantic_similarity.detect_similarity(vector1, vector2)?;
(B[m[31m-        
(B[m[32m+        let semantic_result = self
(B[m[32m+            .semantic_similarity
(B[m[32m+            .detect_similarity(vector1, vector2)?;
(B[m[32m+
(B[m         // 计算文本相似度
         let textual_result = self.textual_similarity.calculate_similarity(text1, text2)?;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:98:
         };
 
         // 计算加权平均相似度
[31m-        let final_similarity = semantic_result.similarity * semantic_weight + 
(B[m[31m-                              textual_result.similarity * textual_weight;
(B[m[32m+        let final_similarity = semantic_result.similarity * semantic_weight
(B[m[32m+            + textual_result.similarity * textual_weight;
(B[m 
         // 构建权重映射
         let mut weights = HashMap::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:121:
         // 基于相似度分数的置信度调整权重
         let semantic_confidence = self.calculate_confidence(*semantic_sim);
         let textual_confidence = self.calculate_confidence(*textual_sim);
[31m-        
(B[m[32m+
(B[m         let total_confidence = semantic_confidence + textual_confidence;
[31m-        
(B[m[32m+
(B[m         if total_confidence == 0.0 {
             return (self.config.semantic_weight, self.config.textual_weight);
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:130:
[31m-        
(B[m[32m+
(B[m         let semantic_weight = semantic_confidence / total_confidence;
         let textual_weight = textual_confidence / total_confidence;
[31m-        
(B[m[32m+
(B[m         (semantic_weight, textual_weight)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:150:
         vectors: &[Vec<f32>],
     ) -> Result<Vec<HybridSimilarityResult>> {
         if texts.len() != vectors.len() {
[31m-            return Err(AgentMemError::validation_error("Texts and vectors must have the same length"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Texts and vectors must have the same length",
(B[m[32m+            ));
(B[m         }
 
         let mut results = Vec::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:157:
[31m-        
(B[m[32m+
(B[m         for (text, vector) in texts.iter().zip(vectors.iter()) {
             let result = self.calculate_similarity(query_text, text, query_vector, vector)?;
             results.push(result);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:161:
         }
[31m-        
(B[m[32m+
(B[m         Ok(results)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:176:
         }
 
         let results = self.batch_similarity(query_text, query_vector, texts, vectors)?;
[31m-        
(B[m[31m-        let max_result = results
(B[m[31m-            .iter()
(B[m[31m-            .enumerate()
(B[m[31m-            .max_by(|(_, a), (_, b)| a.similarity.partial_cmp(&b.similarity).unwrap_or(std::cmp::Ordering::Equal));
(B[m 
[32m+        let max_result = results.iter().enumerate().max_by(|(_, a), (_, b)| {
(B[m[32m+            a.similarity
(B[m[32m+                .partial_cmp(&b.similarity)
(B[m[32m+                .unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+        });
(B[m[32m+
(B[m         if let Some((index, result)) = max_result {
             Ok(Some((index, result.clone())))
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:203:
         }
 
         let results = self.batch_similarity(query_text, query_vector, texts, vectors)?;
[31m-        
(B[m[31m-        let mut indexed_results: Vec<(usize, HybridSimilarityResult)> = results
(B[m[31m-            .into_iter()
(B[m[31m-            .enumerate()
(B[m[31m-            .collect();
(B[m 
[32m+        let mut indexed_results: Vec<(usize, HybridSimilarityResult)> =
(B[m[32m+            results.into_iter().enumerate().collect();
(B[m[32m+
(B[m         // 按相似度降序排序
[31m-        indexed_results.sort_by(|(_, a), (_, b)| b.similarity.partial_cmp(&a.similarity).unwrap_or(std::cmp::Ordering::Equal));
(B[m[31m-        
(B[m[32m+        indexed_results.sort_by(|(_, a), (_, b)| {
(B[m[32m+            b.similarity
(B[m[32m+                .partial_cmp(&a.similarity)
(B[m[32m+                .unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+        });
(B[m[32m+
(B[m         // 取前K个
         indexed_results.truncate(k);
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:227:
         vector2: &[f32],
     ) -> Result<SimilarityAnalysis> {
         let result = self.calculate_similarity(text1, text2, vector1, vector2)?;
[31m-        
(B[m[32m+
(B[m         let semantic_contribution = result.semantic_similarity * result.weights["semantic"];
         let textual_contribution = result.textual_similarity * result.weights["textual"];
[31m-        
(B[m[32m+
(B[m         Ok(SimilarityAnalysis {
             final_similarity: result.similarity,
             semantic_similarity: result.semantic_similarity,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:286:
     #[test]
     fn test_calculate_similarity() {
         let hybrid = HybridSimilarity::default();
[31m-        
(B[m[32m+
(B[m         let text1 = "hello world";
         let text2 = "hello world";
         let vector1 = vec![1.0, 0.0, 0.0];
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:293:
         let vector2 = vec![1.0, 0.0, 0.0];
[31m-        
(B[m[31m-        let result = hybrid.calculate_similarity(text1, text2, &vector1, &vector2).unwrap();
(B[m[32m+
(B[m[32m+        let result = hybrid
(B[m[32m+            .calculate_similarity(text1, text2, &vector1, &vector2)
(B[m[32m+            .unwrap();
(B[m         assert!(result.similarity > 0.8);
         assert!(result.is_similar);
         assert_eq!(result.weights.len(), 2);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:302:
     fn test_adaptive_weights() {
         let mut config = HybridSimilarityConfig::default();
         config.adaptive_weights = true;
[31m-        
(B[m[32m+
(B[m         let hybrid = HybridSimilarity::new(
             config,
             SemanticSimilarity::default(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:309:
             TextualSimilarity::default(),
         );
[31m-        
(B[m[32m+
(B[m         let text1 = "hello world";
         let text2 = "hello world";
         let vector1 = vec![1.0, 0.0, 0.0];
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:315:
         let vector2 = vec![1.0, 0.0, 0.0];
[31m-        
(B[m[31m-        let result = hybrid.calculate_similarity(text1, text2, &vector1, &vector2).unwrap();
(B[m[32m+
(B[m[32m+        let result = hybrid
(B[m[32m+            .calculate_similarity(text1, text2, &vector1, &vector2)
(B[m[32m+            .unwrap();
(B[m         assert!(result.similarity > 0.0);
[31m-        
(B[m[32m+
(B[m         // 权重应该根据置信度调整
         let semantic_weight = result.weights["semantic"];
         let textual_weight = result.weights["textual"];
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:326:
     #[test]
     fn test_calculate_confidence() {
         let hybrid = HybridSimilarity::default();
[31m-        
(B[m[32m+
(B[m         let high_sim_confidence = hybrid.calculate_confidence(0.9);
         let low_sim_confidence = hybrid.calculate_confidence(0.1);
[31m-        
(B[m[32m+
(B[m         assert!(high_sim_confidence > low_sim_confidence);
         assert!(high_sim_confidence > 0.5);
         assert!(low_sim_confidence < 0.5);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:338:
     #[test]
     fn test_batch_similarity() {
         let hybrid = HybridSimilarity::default();
[31m-        
(B[m[32m+
(B[m         let query_text = "hello world";
         let query_vector = vec![1.0, 0.0];
[31m-        let texts = vec![
(B[m[31m-            "hello world".to_string(),
(B[m[31m-            "goodbye world".to_string(),
(B[m[31m-        ];
(B[m[31m-        let vectors = vec![
(B[m[31m-            vec![1.0, 0.0],
(B[m[31m-            vec![0.0, 1.0],
(B[m[31m-        ];
(B[m[31m-        
(B[m[31m-        let results = hybrid.batch_similarity(query_text, &query_vector, &texts, &vectors).unwrap();
(B[m[32m+        let texts = vec!["hello world".to_string(), "goodbye world".to_string()];
(B[m[32m+        let vectors = vec![vec![1.0, 0.0], vec![0.0, 1.0]];
(B[m[32m+
(B[m[32m+        let results = hybrid
(B[m[32m+            .batch_similarity(query_text, &query_vector, &texts, &vectors)
(B[m[32m+            .unwrap();
(B[m         assert_eq!(results.len(), 2);
         assert!(results[0].similarity > results[1].similarity);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:358:
     #[test]
     fn test_find_most_similar() {
         let hybrid = HybridSimilarity::default();
[31m-        
(B[m[32m+
(B[m         let query_text = "hello world";
         let query_vector = vec![1.0, 0.0];
[31m-        let texts = vec![
(B[m[31m-            "goodbye world".to_string(),
(B[m[31m-            "hello world".to_string(),
(B[m[31m-        ];
(B[m[31m-        let vectors = vec![
(B[m[31m-            vec![0.0, 1.0],
(B[m[31m-            vec![1.0, 0.0],
(B[m[31m-        ];
(B[m[31m-        
(B[m[31m-        let result = hybrid.find_most_similar(query_text, &query_vector, &texts, &vectors).unwrap();
(B[m[32m+        let texts = vec!["goodbye world".to_string(), "hello world".to_string()];
(B[m[32m+        let vectors = vec![vec![0.0, 1.0], vec![1.0, 0.0]];
(B[m[32m+
(B[m[32m+        let result = hybrid
(B[m[32m+            .find_most_similar(query_text, &query_vector, &texts, &vectors)
(B[m[32m+            .unwrap();
(B[m         assert!(result.is_some());
         let (index, _) = result.unwrap();
         assert_eq!(index, 1);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:379:
     #[test]
     fn test_analyze_similarity_components() {
         let hybrid = HybridSimilarity::default();
[31m-        
(B[m[32m+
(B[m         let text1 = "hello world";
         let text2 = "hello world";
         let vector1 = vec![1.0, 0.0, 0.0];
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:386:
         let vector2 = vec![1.0, 0.0, 0.0];
[31m-        
(B[m[31m-        let analysis = hybrid.analyze_similarity_components(text1, text2, &vector1, &vector2).unwrap();
(B[m[32m+
(B[m[32m+        let analysis = hybrid
(B[m[32m+            .analyze_similarity_components(text1, text2, &vector1, &vector2)
(B[m[32m+            .unwrap();
(B[m         assert!(analysis.final_similarity > 0.8);
         assert!(analysis.semantic_contribution > 0.0);
         assert!(analysis.textual_contribution > 0.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:395:
     #[test]
     fn test_dimension_mismatch() {
         let hybrid = HybridSimilarity::default();
[31m-        
(B[m[32m+
(B[m         let text1 = "hello";
         let text2 = "world";
         let vector1 = vec![1.0, 0.0];
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/hybrid.rs:402:
         let vectors = vec![vec![1.0, 0.0, 0.0]]; // 不同维度
         let texts = vec!["world".to_string()];
[31m-        
(B[m[32m+
(B[m         let result = hybrid.batch_similarity(text1, &vector1, &texts, &vectors);
         assert!(result.is_err());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/mod.rs:1:
 //! 语义相似度计算模块
 
[32m+pub mod hybrid;
(B[m pub mod semantic;
 pub mod textual;
[31m-pub mod hybrid;
(B[m 
[32m+pub use hybrid::HybridSimilarity;
(B[m pub use semantic::SemanticSimilarity;
 pub use textual::TextualSimilarity;
[31m-pub use hybrid::HybridSimilarity;
(B[m 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:1:
 //! 语义相似度计算实现
 
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:49:
         let mut hybrid_weights = HashMap::new();
         hybrid_weights.insert("cosine".to_string(), 0.7);
         hybrid_weights.insert("euclidean".to_string(), 0.3);
[31m-        
(B[m[32m+
(B[m         Self {
             algorithm: "cosine".to_string(),
             cosine_threshold: 0.8,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:78:
     /// 检测两个向量的相似性
     pub fn detect_similarity(&self, vector1: &[f32], vector2: &[f32]) -> Result<SimilarityResult> {
         if vector1.len() != vector2.len() {
[31m-            return Err(AgentMemError::validation_error("Vector dimensions must match"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Vector dimensions must match",
(B[m[32m+            ));
(B[m         }
 
         match self.config.algorithm.as_str() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:90:
     }
 
     /// 余弦相似度检测
[31m-    fn detect_cosine_similarity(&self, vector1: &[f32], vector2: &[f32]) -> Result<SimilarityResult> {
(B[m[32m+    fn detect_cosine_similarity(
(B[m[32m+        &self,
(B[m[32m+        vector1: &[f32],
(B[m[32m+        vector2: &[f32],
(B[m[32m+    ) -> Result<SimilarityResult> {
(B[m         let similarity = self.cosine_similarity(vector1, vector2)?;
         let distance = 1.0 - similarity;
[31m-        
(B[m[32m+
(B[m         Ok(SimilarityResult::new(
             similarity,
             distance,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:103:
     }
 
     /// 欧几里得相似度检测
[31m-    fn detect_euclidean_similarity(&self, vector1: &[f32], vector2: &[f32]) -> Result<SimilarityResult> {
(B[m[32m+    fn detect_euclidean_similarity(
(B[m[32m+        &self,
(B[m[32m+        vector1: &[f32],
(B[m[32m+        vector2: &[f32],
(B[m[32m+    ) -> Result<SimilarityResult> {
(B[m         let distance = self.euclidean_distance(vector1, vector2)?;
         let similarity = 1.0 / (1.0 + distance);
[31m-        
(B[m[32m+
(B[m         Ok(SimilarityResult::new(
             similarity,
             distance,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:116:
     }
 
     /// 混合相似度检测
[31m-    fn detect_hybrid_similarity(&self, vector1: &[f32], vector2: &[f32]) -> Result<SimilarityResult> {
(B[m[32m+    fn detect_hybrid_similarity(
(B[m[32m+        &self,
(B[m[32m+        vector1: &[f32],
(B[m[32m+        vector2: &[f32],
(B[m[32m+    ) -> Result<SimilarityResult> {
(B[m         let cosine_result = self.detect_cosine_similarity(vector1, vector2)?;
         let euclidean_result = self.detect_euclidean_similarity(vector1, vector2)?;
[31m-        
(B[m[32m+
(B[m         let cosine_weight = self.config.hybrid_weights.get("cosine").unwrap_or(&0.7);
         let euclidean_weight = self.config.hybrid_weights.get("euclidean").unwrap_or(&0.3);
[31m-        
(B[m[31m-        let hybrid_similarity = cosine_result.similarity * cosine_weight + 
(B[m[31m-                               euclidean_result.similarity * euclidean_weight;
(B[m[31m-        
(B[m[31m-        let hybrid_distance = cosine_result.distance * cosine_weight + 
(B[m[31m-                             euclidean_result.distance * euclidean_weight;
(B[m[31m-        
(B[m[31m-        let hybrid_threshold = self.config.cosine_threshold * cosine_weight + 
(B[m[31m-                              self.config.euclidean_threshold * euclidean_weight;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let hybrid_similarity = cosine_result.similarity * cosine_weight
(B[m[32m+            + euclidean_result.similarity * euclidean_weight;
(B[m[32m+
(B[m[32m+        let hybrid_distance =
(B[m[32m+            cosine_result.distance * cosine_weight + euclidean_result.distance * euclidean_weight;
(B[m[32m+
(B[m[32m+        let hybrid_threshold = self.config.cosine_threshold * cosine_weight
(B[m[32m+            + self.config.euclidean_threshold * euclidean_weight;
(B[m[32m+
(B[m         Ok(SimilarityResult::new(
             hybrid_similarity,
             hybrid_distance,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:155:
 
     /// 计算欧几里得距离
     fn euclidean_distance(&self, a: &[f32], b: &[f32]) -> Result<f32> {
[31m-        let distance = a.iter()
(B[m[32m+        let distance = a
(B[m[32m+            .iter()
(B[m             .zip(b.iter())
             .map(|(x, y)| (x - y).powi(2))
             .sum::<f32>()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:165:
     }
 
     /// 批量相似度计算
[31m-    pub fn batch_similarity(&self, query: &[f32], vectors: &[Vec<f32>]) -> Result<Vec<SimilarityResult>> {
(B[m[32m+    pub fn batch_similarity(
(B[m[32m+        &self,
(B[m[32m+        query: &[f32],
(B[m[32m+        vectors: &[Vec<f32>],
(B[m[32m+    ) -> Result<Vec<SimilarityResult>> {
(B[m         let mut results = Vec::new();
[31m-        
(B[m[32m+
(B[m         for vector in vectors {
             let result = self.detect_similarity(query, vector)?;
             results.push(result);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:174:
         }
[31m-        
(B[m[32m+
(B[m         Ok(results)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:179:
     /// 找到最相似的向量
[31m-    pub fn find_most_similar(&self, query: &[f32], vectors: &[Vec<f32>]) -> Result<Option<(usize, SimilarityResult)>> {
(B[m[32m+    pub fn find_most_similar(
(B[m[32m+        &self,
(B[m[32m+        query: &[f32],
(B[m[32m+        vectors: &[Vec<f32>],
(B[m[32m+    ) -> Result<Option<(usize, SimilarityResult)>> {
(B[m         if vectors.is_empty() {
             return Ok(None);
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:184:
 
         let results = self.batch_similarity(query, vectors)?;
[31m-        
(B[m[31m-        let max_result = results
(B[m[31m-            .iter()
(B[m[31m-            .enumerate()
(B[m[31m-            .max_by(|(_, a), (_, b)| a.similarity.partial_cmp(&b.similarity).unwrap_or(std::cmp::Ordering::Equal));
(B[m 
[32m+        let max_result = results.iter().enumerate().max_by(|(_, a), (_, b)| {
(B[m[32m+            a.similarity
(B[m[32m+                .partial_cmp(&b.similarity)
(B[m[32m+                .unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+        });
(B[m[32m+
(B[m         if let Some((index, result)) = max_result {
             Ok(Some((index, result.clone())))
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:197:
     }
 
     /// 找到前K个最相似的向量
[31m-    pub fn find_top_k_similar(&self, query: &[f32], vectors: &[Vec<f32>], k: usize) -> Result<Vec<(usize, SimilarityResult)>> {
(B[m[32m+    pub fn find_top_k_similar(
(B[m[32m+        &self,
(B[m[32m+        query: &[f32],
(B[m[32m+        vectors: &[Vec<f32>],
(B[m[32m+        k: usize,
(B[m[32m+    ) -> Result<Vec<(usize, SimilarityResult)>> {
(B[m         if vectors.is_empty() {
             return Ok(Vec::new());
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:204:
 
         let results = self.batch_similarity(query, vectors)?;
[31m-        
(B[m[31m-        let mut indexed_results: Vec<(usize, SimilarityResult)> = results
(B[m[31m-            .into_iter()
(B[m[31m-            .enumerate()
(B[m[31m-            .collect();
(B[m 
[32m+        let mut indexed_results: Vec<(usize, SimilarityResult)> =
(B[m[32m+            results.into_iter().enumerate().collect();
(B[m[32m+
(B[m         // 按相似度降序排序
[31m-        indexed_results.sort_by(|(_, a), (_, b)| b.similarity.partial_cmp(&a.similarity).unwrap_or(std::cmp::Ordering::Equal));
(B[m[31m-        
(B[m[32m+        indexed_results.sort_by(|(_, a), (_, b)| {
(B[m[32m+            b.similarity
(B[m[32m+                .partial_cmp(&a.similarity)
(B[m[32m+                .unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+        });
(B[m[32m+
(B[m         // 取前K个
         indexed_results.truncate(k);
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:263:
     #[test]
     fn test_cosine_similarity() {
         let similarity = SemanticSimilarity::default();
[31m-        
(B[m[32m+
(B[m         // 测试相同向量
         let a = vec![1.0, 0.0, 0.0];
         let b = vec![1.0, 0.0, 0.0];
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:283:
         let mut config = SemanticSimilarityConfig::default();
         config.algorithm = "euclidean".to_string();
         let similarity = SemanticSimilarity::new(config);
[31m-        
(B[m[32m+
(B[m         let a = vec![0.0, 0.0];
         let b = vec![3.0, 4.0];
         let result = similarity.detect_similarity(&a, &b).unwrap();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:296:
         let mut config = SemanticSimilarityConfig::default();
         config.algorithm = "hybrid".to_string();
         let similarity = SemanticSimilarity::new(config);
[31m-        
(B[m[32m+
(B[m         let a = vec![1.0, 0.0, 0.0];
         let b = vec![1.0, 0.0, 0.0];
         let result = similarity.detect_similarity(&a, &b).unwrap();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:308:
     fn test_batch_similarity() {
         let similarity = SemanticSimilarity::default();
         let query = vec![1.0, 0.0];
[31m-        let vectors = vec![
(B[m[31m-            vec![1.0, 0.0],
(B[m[31m-            vec![0.0, 1.0],
(B[m[31m-            vec![-1.0, 0.0],
(B[m[31m-        ];
(B[m[32m+        let vectors = vec![vec![1.0, 0.0], vec![0.0, 1.0], vec![-1.0, 0.0]];
(B[m 
         let results = similarity.batch_similarity(&query, &vectors).unwrap();
         assert_eq!(results.len(), 3);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:326:
         let similarity = SemanticSimilarity::default();
         let query = vec![1.0, 0.0];
         let vectors = vec![
[31m-            vec![0.0, 1.0],    // 正交
(B[m[31m-            vec![1.0, 0.0],    // 相同
(B[m[31m-            vec![-1.0, 0.0],   // 相反
(B[m[32m+            vec![0.0, 1.0],  // 正交
(B[m[32m+            vec![1.0, 0.0],  // 相同
(B[m[32m+            vec![-1.0, 0.0], // 相反
(B[m         ];
 
         let result = similarity.find_most_similar(&query, &vectors).unwrap();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/semantic.rs:343:
         let similarity = SemanticSimilarity::default();
         let query = vec![1.0, 0.0];
         let vectors = vec![
[31m-            vec![0.0, 1.0],    // 正交，相似度0
(B[m[31m-            vec![1.0, 0.0],    // 相同，相似度1
(B[m[31m-            vec![-1.0, 0.0],   // 相反，相似度-1
(B[m[31m-            vec![0.5, 0.0],    // 部分相似
(B[m[32m+            vec![0.0, 1.0],  // 正交，相似度0
(B[m[32m+            vec![1.0, 0.0],  // 相同，相似度1
(B[m[32m+            vec![-1.0, 0.0], // 相反，相似度-1
(B[m[32m+            vec![0.5, 0.0],  // 部分相似
(B[m         ];
 
         let results = similarity.find_top_k_similar(&query, &vectors, 2).unwrap();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:1:
 //! 文本相似度计算实现
 
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use agent_mem_utils::text::{extract_keywords, jaccard_similarity};
 use serde::{Deserialize, Serialize};
 use std::collections::{HashMap, HashSet};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:74:
         let similarity = self.calculate_jaccard_similarity(&keywords1, &keywords2);
 
         // 找到匹配的关键词
[31m-        let matched_keywords: Vec<String> = keywords1
(B[m[31m-            .intersection(&keywords2)
(B[m[31m-            .cloned()
(B[m[31m-            .collect();
(B[m[32m+        let matched_keywords: Vec<String> = keywords1.intersection(&keywords2).cloned().collect();
(B[m 
         let total_keywords = keywords1.union(&keywords2).count();
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:91:
     }
 
     /// 计算编辑距离相似度
[31m-    pub fn calculate_edit_distance_similarity(&self, text1: &str, text2: &str) -> Result<TextSimilarityResult> {
(B[m[32m+    pub fn calculate_edit_distance_similarity(
(B[m[32m+        &self,
(B[m[32m+        text1: &str,
(B[m[32m+        text2: &str,
(B[m[32m+    ) -> Result<TextSimilarityResult> {
(B[m         let distance = self.levenshtein_distance(text1, text2);
         let max_len = text1.len().max(text2.len());
[31m-        
(B[m[32m+
(B[m         let similarity = if max_len == 0 {
             1.0
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:111:
     }
 
     /// 计算N-gram相似度
[31m-    pub fn calculate_ngram_similarity(&self, text1: &str, text2: &str, n: usize) -> Result<TextSimilarityResult> {
(B[m[32m+    pub fn calculate_ngram_similarity(
(B[m[32m+        &self,
(B[m[32m+        text1: &str,
(B[m[32m+        text2: &str,
(B[m[32m+        n: usize,
(B[m[32m+    ) -> Result<TextSimilarityResult> {
(B[m         let ngrams1 = self.extract_ngrams(text1, n);
         let ngrams2 = self.extract_ngrams(text2, n);
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:118:
         let similarity = self.calculate_jaccard_similarity(&ngrams1, &ngrams2);
 
[31m-        let matched_ngrams: Vec<String> = ngrams1
(B[m[31m-            .intersection(&ngrams2)
(B[m[31m-            .cloned()
(B[m[31m-            .collect();
(B[m[32m+        let matched_ngrams: Vec<String> = ngrams1.intersection(&ngrams2).cloned().collect();
(B[m 
         let total_ngrams = ngrams1.union(&ngrams2).count();
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:136:
     /// 预处理文本
     fn preprocess_text(&self, text: &str) -> String {
         let mut processed = text.to_string();
[31m-        
(B[m[32m+
(B[m         if self.config.ignore_case {
             processed = processed.to_lowercase();
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:144:
         // 移除标点符号和多余空格
         processed = processed
             .chars()
[31m-            .map(|c| if c.is_alphanumeric() || c.is_whitespace() { c } else { ' ' })
(B[m[32m+            .map(|c| {
(B[m[32m+                if c.is_alphanumeric() || c.is_whitespace() {
(B[m[32m+                    c
(B[m[32m+                } else {
(B[m[32m+                    ' '
(B[m[32m+                }
(B[m[32m+            })
(B[m             .collect::<String>()
             .split_whitespace()
             .collect::<Vec<&str>>()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:163:
     fn levenshtein_distance(&self, s1: &str, s2: &str) -> usize {
         let len1 = s1.chars().count();
         let len2 = s2.chars().count();
[31m-        
(B[m[32m+
(B[m         if len1 == 0 {
             return len2;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:216:
     }
 
     /// 批量文本相似度计算
[31m-    pub fn batch_similarity(&self, query: &str, texts: &[String]) -> Result<Vec<TextSimilarityResult>> {
(B[m[32m+    pub fn batch_similarity(
(B[m[32m+        &self,
(B[m[32m+        query: &str,
(B[m[32m+        texts: &[String],
(B[m[32m+    ) -> Result<Vec<TextSimilarityResult>> {
(B[m         let mut results = Vec::new();
[31m-        
(B[m[32m+
(B[m         for text in texts {
             let result = self.calculate_similarity(query, text)?;
             results.push(result);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:225:
         }
[31m-        
(B[m[32m+
(B[m         Ok(results)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:230:
     /// 找到最相似的文本
[31m-    pub fn find_most_similar(&self, query: &str, texts: &[String]) -> Result<Option<(usize, TextSimilarityResult)>> {
(B[m[32m+    pub fn find_most_similar(
(B[m[32m+        &self,
(B[m[32m+        query: &str,
(B[m[32m+        texts: &[String],
(B[m[32m+    ) -> Result<Option<(usize, TextSimilarityResult)>> {
(B[m         if texts.is_empty() {
             return Ok(None);
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:235:
 
         let results = self.batch_similarity(query, texts)?;
[31m-        
(B[m[31m-        let max_result = results
(B[m[31m-            .iter()
(B[m[31m-            .enumerate()
(B[m[31m-            .max_by(|(_, a), (_, b)| a.similarity.partial_cmp(&b.similarity).unwrap_or(std::cmp::Ordering::Equal));
(B[m 
[32m+        let max_result = results.iter().enumerate().max_by(|(_, a), (_, b)| {
(B[m[32m+            a.similarity
(B[m[32m+                .partial_cmp(&b.similarity)
(B[m[32m+                .unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+        });
(B[m[32m+
(B[m         if let Some((index, result)) = max_result {
             Ok(Some((index, result.clone())))
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:284:
     #[test]
     fn test_jaccard_similarity() {
         let similarity = TextualSimilarity::default();
[31m-        
(B[m[32m+
(B[m         let text1 = "The quick brown fox jumps over the lazy dog";
         let text2 = "A quick brown fox leaps over a lazy dog";
[31m-        
(B[m[32m+
(B[m         let result = similarity.calculate_similarity(text1, text2).unwrap();
         assert!(result.similarity > 0.5);
         assert_eq!(result.similarity_type, "jaccard");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:297:
     #[test]
     fn test_edit_distance_similarity() {
         let similarity = TextualSimilarity::default();
[31m-        
(B[m[32m+
(B[m         let text1 = "hello world";
         let text2 = "hello word";
[31m-        
(B[m[31m-        let result = similarity.calculate_edit_distance_similarity(text1, text2).unwrap();
(B[m[32m+
(B[m[32m+        let result = similarity
(B[m[32m+            .calculate_edit_distance_similarity(text1, text2)
(B[m[32m+            .unwrap();
(B[m         assert!(result.similarity > 0.8);
         assert_eq!(result.similarity_type, "edit_distance");
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:309:
     #[test]
     fn test_ngram_similarity() {
         let similarity = TextualSimilarity::default();
[31m-        
(B[m[32m+
(B[m         let text1 = "hello world";
         let text2 = "hello word";
[31m-        
(B[m[31m-        let result = similarity.calculate_ngram_similarity(text1, text2, 3).unwrap();
(B[m[32m+
(B[m[32m+        let result = similarity
(B[m[32m+            .calculate_ngram_similarity(text1, text2, 3)
(B[m[32m+            .unwrap();
(B[m         assert!(result.similarity > 0.0);
         assert_eq!(result.similarity_type, "3-gram");
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:321:
     #[test]
     fn test_preprocess_text() {
         let similarity = TextualSimilarity::default();
[31m-        
(B[m[32m+
(B[m         let text = "Hello, World! This is a TEST.";
         let processed = similarity.preprocess_text(text);
         assert_eq!(processed, "hello world this is a test");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:330:
     #[test]
     fn test_levenshtein_distance() {
         let similarity = TextualSimilarity::default();
[31m-        
(B[m[32m+
(B[m         assert_eq!(similarity.levenshtein_distance("", ""), 0);
         assert_eq!(similarity.levenshtein_distance("hello", ""), 5);
         assert_eq!(similarity.levenshtein_distance("", "world"), 5);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-intelligence/src/similarity/textual.rs:342:
     #[test]
     fn test_extract_ngrams() {
         let similarity = TextualSimilarity::default();
[31m-        
(B[m[32m+
(B[m         let ngrams = similarity.extract_ngrams("hello", 2);
         assert!(ngrams.contains("he"));
         assert!(ngrams.contains("el"));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:1:
 //! LLM客户端实现
 
[31m-use crate::{LLMFactory, prompts::PromptManager};
(B[m[31m-use agent_mem_traits::{LLMProvider, LLMConfig, Message, Result, ModelInfo};
(B[m[32m+use crate::{prompts::PromptManager, LLMFactory};
(B[m[32m+use agent_mem_traits::{LLMConfig, LLMProvider, Message, ModelInfo, Result};
(B[m use std::sync::Arc;
 use std::time::Duration;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:63:
     }
 
     /// 使用自定义提示词管理器创建LLM客户端
[31m-    pub fn with_prompt_manager(llm_config: &LLMConfig, prompt_manager: PromptManager) -> Result<Self> {
(B[m[32m+    pub fn with_prompt_manager(
(B[m[32m+        llm_config: &LLMConfig,
(B[m[32m+        prompt_manager: PromptManager,
(B[m[32m+    ) -> Result<Self> {
(B[m         let provider = LLMFactory::create_provider(llm_config)?;
         let config = LLMClientConfig::default();
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:76:
 
     /// 生成文本响应
     pub async fn generate(&self, messages: &[Message]) -> Result<String> {
[31m-        self.generate_with_retry(messages, self.config.max_retries).await
(B[m[32m+        self.generate_with_retry(messages, self.config.max_retries)
(B[m[32m+            .await
(B[m     }
 
     /// 带重试的生成文本响应
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:83:
[31m-    fn generate_with_retry<'a>(&'a self, messages: &'a [Message], retries_left: u32) -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<String>> + Send + 'a>> {
(B[m[32m+    fn generate_with_retry<'a>(
(B[m[32m+        &'a self,
(B[m[32m+        messages: &'a [Message],
(B[m[32m+        retries_left: u32,
(B[m[32m+    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<String>> + Send + 'a>> {
(B[m         Box::pin(async move {
             match self.provider.generate(messages).await {
                 Ok(response) => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:92:
                 Err(e) => {
                     if retries_left > 0 {
                         if self.config.enable_logging {
[31m-                            println!("LLM request failed, retrying... ({} retries left): {}", retries_left, e);
(B[m[32m+                            println!(
(B[m[32m+                                "LLM request failed, retrying... ({} retries left): {}",
(B[m[32m+                                retries_left, e
(B[m[32m+                            );
(B[m                         }
 
                         // 等待重试间隔
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:99:
[31m-                        tokio::time::sleep(Duration::from_secs(self.config.retry_delay_seconds)).await;
(B[m[32m+                        tokio::time::sleep(Duration::from_secs(self.config.retry_delay_seconds))
(B[m[32m+                            .await;
(B[m 
                         self.generate_with_retry(messages, retries_left - 1).await
                     } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:109:
 
     /// 提取记忆
     pub async fn extract_memories(&self, conversation: &str) -> Result<String> {
[31m-        let messages = self.prompt_manager.build_memory_extraction_prompt(conversation)?;
(B[m[32m+        let messages = self
(B[m[32m+            .prompt_manager
(B[m[32m+            .build_memory_extraction_prompt(conversation)?;
(B[m         self.generate(&messages).await
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:116:
     /// 摘要记忆
     pub async fn summarize_memories(&self, memories: &str) -> Result<String> {
[31m-        let messages = self.prompt_manager.build_memory_summarization_prompt(memories)?;
(B[m[32m+        let messages = self
(B[m[32m+            .prompt_manager
(B[m[32m+            .build_memory_summarization_prompt(memories)?;
(B[m         self.generate(&messages).await
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:122:
     /// 检测记忆冲突
     pub async fn detect_memory_conflicts(&self, memory_a: &str, memory_b: &str) -> Result<String> {
[31m-        let messages = self.prompt_manager.build_memory_conflict_detection_prompt(memory_a, memory_b)?;
(B[m[32m+        let messages = self
(B[m[32m+            .prompt_manager
(B[m[32m+            .build_memory_conflict_detection_prompt(memory_a, memory_b)?;
(B[m         self.generate(&messages).await
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:128:
     /// 评估记忆重要性
[31m-    pub async fn score_memory_importance(&self, memory_content: &str, user_context: &str) -> Result<String> {
(B[m[31m-        let messages = self.prompt_manager.build_memory_importance_scoring_prompt(memory_content, user_context)?;
(B[m[32m+    pub async fn score_memory_importance(
(B[m[32m+        &self,
(B[m[32m+        memory_content: &str,
(B[m[32m+        user_context: &str,
(B[m[32m+    ) -> Result<String> {
(B[m[32m+        let messages = self
(B[m[32m+            .prompt_manager
(B[m[32m+            .build_memory_importance_scoring_prompt(memory_content, user_context)?;
(B[m         self.generate(&messages).await
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:134:
     /// 增强查询
     pub async fn enhance_query(&self, user_query: &str) -> Result<String> {
[31m-        let messages = self.prompt_manager.build_memory_query_enhancement_prompt(user_query)?;
(B[m[32m+        let messages = self
(B[m[32m+            .prompt_manager
(B[m[32m+            .build_memory_query_enhancement_prompt(user_query)?;
(B[m         self.generate(&messages).await
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:140:
     /// 自定义提示词生成
[31m-    pub async fn generate_with_template(&self, template_name: &str, variables: std::collections::HashMap<String, String>) -> Result<String> {
(B[m[31m-        let messages = self.prompt_manager.build_custom_prompt(template_name, variables)?;
(B[m[32m+    pub async fn generate_with_template(
(B[m[32m+        &self,
(B[m[32m+        template_name: &str,
(B[m[32m+        variables: std::collections::HashMap<String, String>,
(B[m[32m+    ) -> Result<String> {
(B[m[32m+        let messages = self
(B[m[32m+            .prompt_manager
(B[m[32m+            .build_custom_prompt(template_name, variables)?;
(B[m         self.generate(&messages).await
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:154:
     }
 
     /// 带系统提示的文本生成
[31m-    pub async fn generate_with_system(&self, system_prompt: &str, user_prompt: &str) -> Result<String> {
(B[m[31m-        let messages = self.prompt_manager.build_system_prompt(system_prompt, user_prompt);
(B[m[32m+    pub async fn generate_with_system(
(B[m[32m+        &self,
(B[m[32m+        system_prompt: &str,
(B[m[32m+        user_prompt: &str,
(B[m[32m+    ) -> Result<String> {
(B[m[32m+        let messages = self
(B[m[32m+            .prompt_manager
(B[m[32m+            .build_system_prompt(system_prompt, user_prompt);
(B[m         self.generate(&messages).await
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:220:
             timeout_seconds: 60,
             enable_logging: true,
         };
[31m-        
(B[m[32m+
(B[m         let client = LLMClient::with_config(&llm_config, client_config);
         assert!(client.is_ok());
[31m-        
(B[m[32m+
(B[m         let client = client.unwrap();
         assert_eq!(client.config.max_retries, 5);
         assert_eq!(client.config.retry_delay_seconds, 2);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:233:
     fn test_get_model_info() {
         let config = create_test_config();
         let client = LLMClient::new(&config).unwrap();
[31m-        
(B[m[32m+
(B[m         let model_info = client.get_model_info();
         assert_eq!(model_info.provider, "openai");
         assert_eq!(model_info.model, "gpt-3.5-turbo");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:243:
     fn test_validate_config() {
         let config = create_test_config();
         let client = LLMClient::new(&config).unwrap();
[31m-        
(B[m[32m+
(B[m         let result = client.validate_config();
         assert!(result.is_ok());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:252:
     fn test_prompt_manager_access() {
         let config = create_test_config();
         let mut client = LLMClient::new(&config).unwrap();
[31m-        
(B[m[32m+
(B[m         // 测试只读访问
         let templates = client.prompt_manager().get_available_templates();
         assert!(!templates.is_empty());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:259:
[31m-        
(B[m[32m+
(B[m         // 测试可变访问
[31m-        client.prompt_manager_mut().add_template(
(B[m[31m-            "test".to_string(), 
(B[m[31m-            "Test template: {variable}".to_string()
(B[m[31m-        );
(B[m[31m-        
(B[m[32m+        client
(B[m[32m+            .prompt_manager_mut()
(B[m[32m+            .add_template("test".to_string(), "Test template: {variable}".to_string());
(B[m[32m+
(B[m         let templates = client.prompt_manager().get_available_templates();
         assert!(templates.contains(&&"test".to_string()));
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/client.rs:271:
     async fn test_extract_memories_prompt_building() {
         let config = create_test_config();
         let client = LLMClient::new(&config).unwrap();
[31m-        
(B[m[32m+
(B[m         // 这个测试只验证提示词构建，不实际调用LLM
[31m-        let messages = client.prompt_manager.build_memory_extraction_prompt("Hello, I love tennis!");
(B[m[32m+        let messages = client
(B[m[32m+            .prompt_manager
(B[m[32m+            .build_memory_extraction_prompt("Hello, I love tennis!");
(B[m         assert!(messages.is_ok());
[31m-        
(B[m[32m+
(B[m         let messages = messages.unwrap();
         assert_eq!(messages.len(), 1);
         assert!(messages[0].content.contains("Hello, I love tennis!"));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:1:
 //! LLM工厂模式实现
 
[31m-use crate::providers::{OpenAIProvider, AnthropicProvider};
(B[m #[cfg(feature = "azure")]
 use crate::providers::AzureProvider;
 #[cfg(feature = "gemini")]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:7:
 use crate::providers::GeminiProvider;
 #[cfg(feature = "ollama")]
 use crate::providers::OllamaProvider;
[32m+use crate::providers::{AnthropicProvider, OpenAIProvider};
(B[m use crate::providers::{ClaudeProvider, CohereProvider, MistralProvider, PerplexityProvider};
 
[31m-use agent_mem_traits::{LLMProvider, LLMConfig, Result, AgentMemError, ModelInfo, Message};
(B[m[32m+use agent_mem_traits::{AgentMemError, LLMConfig, LLMProvider, Message, ModelInfo, Result};
(B[m use async_trait::async_trait;
 use std::sync::Arc;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:52:
         }
     }
 
[31m-    async fn generate_stream(&self, messages: &[Message]) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m[32m+    async fn generate_stream(
(B[m[32m+        &self,
(B[m[32m+        messages: &[Message],
(B[m[32m+    ) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m         match self {
             #[cfg(feature = "openai")]
             LLMProviderEnum::OpenAI(provider) => provider.generate_stream(messages).await,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:125:
                 }
                 #[cfg(not(feature = "openai"))]
                 {
[31m-                    return Err(AgentMemError::unsupported_provider("OpenAI feature not enabled"));
(B[m[32m+                    return Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "OpenAI feature not enabled",
(B[m[32m+                    ));
(B[m                 }
             }
             "anthropic" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:136:
                 }
                 #[cfg(not(feature = "anthropic"))]
                 {
[31m-                    return Err(AgentMemError::unsupported_provider("Anthropic feature not enabled"));
(B[m[32m+                    return Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Anthropic feature not enabled",
(B[m[32m+                    ));
(B[m                 }
             }
             "azure" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:147:
                 }
                 #[cfg(not(feature = "azure"))]
                 {
[31m-                    return Err(AgentMemError::unsupported_provider("Azure feature not enabled"));
(B[m[32m+                    return Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Azure feature not enabled",
(B[m[32m+                    ));
(B[m                 }
             }
             "gemini" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:158:
                 }
                 #[cfg(not(feature = "gemini"))]
                 {
[31m-                    return Err(AgentMemError::unsupported_provider("Gemini feature not enabled"));
(B[m[32m+                    return Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Gemini feature not enabled",
(B[m[32m+                    ));
(B[m                 }
             }
             "ollama" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:169:
                 }
                 #[cfg(not(feature = "ollama"))]
                 {
[31m-                    return Err(AgentMemError::unsupported_provider("Ollama feature not enabled"));
(B[m[32m+                    return Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Ollama feature not enabled",
(B[m[32m+                    ));
(B[m                 }
             }
             "claude" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:253:
 
     /// 创建本地Ollama提供商（如果启用）
     #[cfg(feature = "ollama")]
[31m-    pub fn create_ollama_provider(base_url: Option<&str>, model: &str) -> Result<Arc<dyn LLMProvider + Send + Sync>> {
(B[m[32m+    pub fn create_ollama_provider(
(B[m[32m+        base_url: Option<&str>,
(B[m[32m+        model: &str,
(B[m[32m+    ) -> Result<Arc<dyn LLMProvider + Send + Sync>> {
(B[m         let config = LLMConfig {
             provider: "ollama".to_string(),
             model: model.to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:264:
     }
 
     /// 创建Claude提供商
[31m-    pub fn create_claude_provider(api_key: &str, model: Option<&str>) -> Result<Arc<dyn LLMProvider + Send + Sync>> {
(B[m[32m+    pub fn create_claude_provider(
(B[m[32m+        api_key: &str,
(B[m[32m+        model: Option<&str>,
(B[m[32m+    ) -> Result<Arc<dyn LLMProvider + Send + Sync>> {
(B[m         let config = LLMConfig {
             provider: "claude".to_string(),
             model: model.unwrap_or("claude-3-haiku-20240307").to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:275:
     }
 
     /// 创建Cohere提供商
[31m-    pub fn create_cohere_provider(api_key: &str, model: Option<&str>) -> Result<Arc<dyn LLMProvider + Send + Sync>> {
(B[m[32m+    pub fn create_cohere_provider(
(B[m[32m+        api_key: &str,
(B[m[32m+        model: Option<&str>,
(B[m[32m+    ) -> Result<Arc<dyn LLMProvider + Send + Sync>> {
(B[m         let config = LLMConfig {
             provider: "cohere".to_string(),
             model: model.unwrap_or("command-r").to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:286:
     }
 
     /// 创建Mistral提供商
[31m-    pub fn create_mistral_provider(api_key: &str, model: Option<&str>) -> Result<Arc<dyn LLMProvider + Send + Sync>> {
(B[m[32m+    pub fn create_mistral_provider(
(B[m[32m+        api_key: &str,
(B[m[32m+        model: Option<&str>,
(B[m[32m+    ) -> Result<Arc<dyn LLMProvider + Send + Sync>> {
(B[m         let config = LLMConfig {
             provider: "mistral".to_string(),
             model: model.unwrap_or("mistral-small-latest").to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:297:
     }
 
     /// 创建Perplexity提供商
[31m-    pub fn create_perplexity_provider(api_key: &str, model: Option<&str>) -> Result<Arc<dyn LLMProvider + Send + Sync>> {
(B[m[32m+    pub fn create_perplexity_provider(
(B[m[32m+        api_key: &str,
(B[m[32m+        model: Option<&str>,
(B[m[32m+    ) -> Result<Arc<dyn LLMProvider + Send + Sync>> {
(B[m         let config = LLMConfig {
             provider: "perplexity".to_string(),
[31m-            model: model.unwrap_or("llama-3.1-sonar-small-128k-chat").to_string(),
(B[m[32m+            model: model
(B[m[32m+                .unwrap_or("llama-3.1-sonar-small-128k-chat")
(B[m[32m+                .to_string(),
(B[m             api_key: Some(api_key.to_string()),
             ..Default::default()
         };
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:316:
     fn test_supported_providers() {
         let providers = LLMFactory::supported_providers();
         assert!(!providers.is_empty());
[31m-        
(B[m[32m+
(B[m         // 检查默认启用的提供商
         #[cfg(feature = "openai")]
         assert!(providers.contains(&"openai"));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:323:
[31m-        
(B[m[32m+
(B[m         #[cfg(feature = "anthropic")]
         assert!(providers.contains(&"anthropic"));
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:329:
     fn test_is_provider_supported() {
         #[cfg(feature = "openai")]
         assert!(LLMFactory::is_provider_supported("openai"));
[31m-        
(B[m[32m+
(B[m         #[cfg(feature = "anthropic")]
         assert!(LLMFactory::is_provider_supported("anthropic"));
[31m-        
(B[m[32m+
(B[m         assert!(!LLMFactory::is_provider_supported("unsupported_provider"));
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/factory.rs:342:
             provider: "unsupported".to_string(),
             ..Default::default()
         };
[31m-        
(B[m[32m+
(B[m         let result = LLMFactory::create_provider(&config);
         assert!(result.is_err());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/lib.rs:1:
 //! # Agent Memory LLM Integration
[31m-//! 
(B[m[32m+//!
(B[m //! LLM集成模块，为AgentMem记忆平台提供多种LLM提供商支持。
[31m-//! 
(B[m[32m+//!
(B[m //! 本模块提供：
 //! - LLM工厂模式，支持多种提供商
 //! - 统一的LLM接口抽象
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/lib.rs:9:
 //! - 错误处理和重试机制
 //! - 特性门控支持
 
[32m+pub mod client;
(B[m pub mod factory;
[31m-pub mod providers;
(B[m pub mod prompts;
[31m-pub mod client;
(B[m[32m+pub mod providers;
(B[m 
[31m-pub use factory::LLMFactory;
(B[m pub use client::LLMClient;
[32m+pub use factory::LLMFactory;
(B[m 
 // 重新导出常用类型
[31m-pub use agent_mem_traits::{LLMProvider, LLMConfig, Message, Result, AgentMemError, ModelInfo};
(B[m[32m+pub use agent_mem_traits::{AgentMemError, LLMConfig, LLMProvider, Message, ModelInfo, Result};
(B[m 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:1:
 //! 提示词管理器
 
 use crate::prompts::templates::PromptTemplates;
[31m-use agent_mem_traits::{Result, AgentMemError, Message, MessageRole};
(B[m[32m+use agent_mem_traits::{AgentMemError, Message, MessageRole, Result};
(B[m use std::collections::HashMap;
 
 /// 提示词管理器
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:27:
         let mut variables = HashMap::new();
         variables.insert("conversation".to_string(), conversation.to_string());
 
[31m-        let prompt = self.templates.render_template("memory_extraction", &variables)
(B[m[31m-            .ok_or_else(|| AgentMemError::llm_error("Failed to render memory extraction template"))?;
(B[m[32m+        let prompt = self
(B[m[32m+            .templates
(B[m[32m+            .render_template("memory_extraction", &variables)
(B[m[32m+            .ok_or_else(|| {
(B[m[32m+                AgentMemError::llm_error("Failed to render memory extraction template")
(B[m[32m+            })?;
(B[m 
         Ok(vec![Message {
             role: MessageRole::User,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:42:
         let mut variables = HashMap::new();
         variables.insert("memories".to_string(), memories.to_string());
 
[31m-        let prompt = self.templates.render_template("memory_summarization", &variables)
(B[m[31m-            .ok_or_else(|| AgentMemError::llm_error("Failed to render memory summarization template"))?;
(B[m[32m+        let prompt = self
(B[m[32m+            .templates
(B[m[32m+            .render_template("memory_summarization", &variables)
(B[m[32m+            .ok_or_else(|| {
(B[m[32m+                AgentMemError::llm_error("Failed to render memory summarization template")
(B[m[32m+            })?;
(B[m 
         Ok(vec![Message {
             role: MessageRole::User,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:53:
     }
 
     /// 构建记忆冲突检测提示词
[31m-    pub fn build_memory_conflict_detection_prompt(&self, memory_a: &str, memory_b: &str) -> Result<Vec<Message>> {
(B[m[32m+    pub fn build_memory_conflict_detection_prompt(
(B[m[32m+        &self,
(B[m[32m+        memory_a: &str,
(B[m[32m+        memory_b: &str,
(B[m[32m+    ) -> Result<Vec<Message>> {
(B[m         let mut variables = HashMap::new();
         variables.insert("memory_a".to_string(), memory_a.to_string());
         variables.insert("memory_b".to_string(), memory_b.to_string());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:60:
 
[31m-        let prompt = self.templates.render_template("memory_conflict_detection", &variables)
(B[m[31m-            .ok_or_else(|| AgentMemError::llm_error("Failed to render memory conflict detection template"))?;
(B[m[32m+        let prompt = self
(B[m[32m+            .templates
(B[m[32m+            .render_template("memory_conflict_detection", &variables)
(B[m[32m+            .ok_or_else(|| {
(B[m[32m+                AgentMemError::llm_error("Failed to render memory conflict detection template")
(B[m[32m+            })?;
(B[m 
         Ok(vec![Message {
             role: MessageRole::User,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:69:
     }
 
     /// 构建记忆重要性评分提示词
[31m-    pub fn build_memory_importance_scoring_prompt(&self, memory_content: &str, user_context: &str) -> Result<Vec<Message>> {
(B[m[32m+    pub fn build_memory_importance_scoring_prompt(
(B[m[32m+        &self,
(B[m[32m+        memory_content: &str,
(B[m[32m+        user_context: &str,
(B[m[32m+    ) -> Result<Vec<Message>> {
(B[m         let mut variables = HashMap::new();
         variables.insert("memory_content".to_string(), memory_content.to_string());
         variables.insert("user_context".to_string(), user_context.to_string());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:76:
 
[31m-        let prompt = self.templates.render_template("memory_importance_scoring", &variables)
(B[m[31m-            .ok_or_else(|| AgentMemError::llm_error("Failed to render memory importance scoring template"))?;
(B[m[32m+        let prompt = self
(B[m[32m+            .templates
(B[m[32m+            .render_template("memory_importance_scoring", &variables)
(B[m[32m+            .ok_or_else(|| {
(B[m[32m+                AgentMemError::llm_error("Failed to render memory importance scoring template")
(B[m[32m+            })?;
(B[m 
         Ok(vec![Message {
             role: MessageRole::User,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:89:
         let mut variables = HashMap::new();
         variables.insert("user_query".to_string(), user_query.to_string());
 
[31m-        let prompt = self.templates.render_template("memory_query_enhancement", &variables)
(B[m[31m-            .ok_or_else(|| AgentMemError::llm_error("Failed to render memory query enhancement template"))?;
(B[m[32m+        let prompt = self
(B[m[32m+            .templates
(B[m[32m+            .render_template("memory_query_enhancement", &variables)
(B[m[32m+            .ok_or_else(|| {
(B[m[32m+                AgentMemError::llm_error("Failed to render memory query enhancement template")
(B[m[32m+            })?;
(B[m 
         Ok(vec![Message {
             role: MessageRole::User,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:100:
     }
 
     /// 构建自定义提示词
[31m-    pub fn build_custom_prompt(&self, template_name: &str, variables: HashMap<String, String>) -> Result<Vec<Message>> {
(B[m[31m-        let prompt = self.templates.render_template(template_name, &variables)
(B[m[31m-            .ok_or_else(|| AgentMemError::llm_error(&format!("Failed to render template: {}", template_name)))?;
(B[m[32m+    pub fn build_custom_prompt(
(B[m[32m+        &self,
(B[m[32m+        template_name: &str,
(B[m[32m+        variables: HashMap<String, String>,
(B[m[32m+    ) -> Result<Vec<Message>> {
(B[m[32m+        let prompt = self
(B[m[32m+            .templates
(B[m[32m+            .render_template(template_name, &variables)
(B[m[32m+            .ok_or_else(|| {
(B[m[32m+                AgentMemError::llm_error(&format!("Failed to render template: {}", template_name))
(B[m[32m+            })?;
(B[m 
         Ok(vec![Message {
             role: MessageRole::User,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:129:
 
     /// 构建对话式提示词
     pub fn build_conversation_prompt(&self, messages: Vec<(MessageRole, String)>) -> Vec<Message> {
[31m-        messages.into_iter().map(|(role, content)| Message { role, content, timestamp: None }).collect()
(B[m[32m+        messages
(B[m[32m+            .into_iter()
(B[m[32m+            .map(|(role, content)| Message {
(B[m[32m+                role,
(B[m[32m+                content,
(B[m[32m+                timestamp: None,
(B[m[32m+            })
(B[m[32m+            .collect()
(B[m     }
 
     /// 添加自定义模板
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:143:
     }
 
     /// 验证模板变量
[31m-    pub fn validate_template_variables(&self, template_name: &str, variables: &HashMap<String, String>) -> Result<()> {
(B[m[31m-        let template = self.templates.get_template(template_name)
(B[m[31m-            .ok_or_else(|| AgentMemError::llm_error(&format!("Template not found: {}", template_name)))?;
(B[m[32m+    pub fn validate_template_variables(
(B[m[32m+        &self,
(B[m[32m+        template_name: &str,
(B[m[32m+        variables: &HashMap<String, String>,
(B[m[32m+    ) -> Result<()> {
(B[m[32m+        let template = self.templates.get_template(template_name).ok_or_else(|| {
(B[m[32m+            AgentMemError::llm_error(&format!("Template not found: {}", template_name))
(B[m[32m+        })?;
(B[m 
         // 简单的变量验证：检查模板中的占位符是否都有对应的变量
         let mut missing_variables = Vec::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:220:
         if !missing_variables.is_empty() {
             return Err(AgentMemError::llm_error(&format!(
                 "Missing variables for template {}: {:?}",
[31m-                template_name,
(B[m[31m-                missing_variables
(B[m[32m+                template_name, missing_variables
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:249:
     fn test_build_memory_extraction_prompt() {
         let manager = PromptManager::new();
         let result = manager.build_memory_extraction_prompt("Hello, I love tennis!");
[31m-        
(B[m[32m+
(B[m         assert!(result.is_ok());
         let messages = result.unwrap();
         assert_eq!(messages.len(), 1);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:259:
     #[test]
     fn test_build_system_prompt() {
         let manager = PromptManager::new();
[31m-        let messages = manager.build_system_prompt(
(B[m[31m-            "You are a helpful assistant",
(B[m[31m-            "Hello, how are you?"
(B[m[31m-        );
(B[m[31m-        
(B[m[32m+        let messages =
(B[m[32m+            manager.build_system_prompt("You are a helpful assistant", "Hello, how are you?");
(B[m[32m+
(B[m         assert_eq!(messages.len(), 2);
         assert_eq!(messages[0].role, MessageRole::System);
         assert_eq!(messages[1].role, MessageRole::User);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:277:
             (MessageRole::User, "Hello".to_string()),
             (MessageRole::Assistant, "Hi there!".to_string()),
         ];
[31m-        
(B[m[32m+
(B[m         let messages = manager.build_conversation_prompt(conversation);
         assert_eq!(messages.len(), 3);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/manager.rs:304:
     fn test_add_custom_template() {
         let mut manager = PromptManager::new();
         manager.add_template("test".to_string(), "Hello {name}!".to_string());
[31m-        
(B[m[32m+
(B[m         let mut variables = HashMap::new();
         variables.insert("name".to_string(), "World".to_string());
[31m-        
(B[m[32m+
(B[m         let result = manager.build_custom_prompt("test", variables);
         assert!(result.is_ok());
         assert!(result.unwrap()[0].content.contains("Hello World!"));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/mod.rs:1:
 //! 提示词管理系统
 
[31m-pub mod templates;
(B[m pub mod manager;
[32m+pub mod templates;
(B[m 
[31m-pub use templates::*;
(B[m pub use manager::PromptManager;
[32m+pub use templates::*;
(B[m 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/templates.rs:139:
     /// 创建新的提示词模板管理器
     pub fn new() -> Self {
         let mut templates = HashMap::new();
[31m-        
(B[m[31m-        templates.insert("memory_extraction".to_string(), MEMORY_EXTRACTION_PROMPT.to_string());
(B[m[31m-        templates.insert("memory_summarization".to_string(), MEMORY_SUMMARIZATION_PROMPT.to_string());
(B[m[31m-        templates.insert("memory_conflict_detection".to_string(), MEMORY_CONFLICT_DETECTION_PROMPT.to_string());
(B[m[31m-        templates.insert("memory_importance_scoring".to_string(), MEMORY_IMPORTANCE_SCORING_PROMPT.to_string());
(B[m[31m-        templates.insert("memory_query_enhancement".to_string(), MEMORY_QUERY_ENHANCEMENT_PROMPT.to_string());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        templates.insert(
(B[m[32m+            "memory_extraction".to_string(),
(B[m[32m+            MEMORY_EXTRACTION_PROMPT.to_string(),
(B[m[32m+        );
(B[m[32m+        templates.insert(
(B[m[32m+            "memory_summarization".to_string(),
(B[m[32m+            MEMORY_SUMMARIZATION_PROMPT.to_string(),
(B[m[32m+        );
(B[m[32m+        templates.insert(
(B[m[32m+            "memory_conflict_detection".to_string(),
(B[m[32m+            MEMORY_CONFLICT_DETECTION_PROMPT.to_string(),
(B[m[32m+        );
(B[m[32m+        templates.insert(
(B[m[32m+            "memory_importance_scoring".to_string(),
(B[m[32m+            MEMORY_IMPORTANCE_SCORING_PROMPT.to_string(),
(B[m[32m+        );
(B[m[32m+        templates.insert(
(B[m[32m+            "memory_query_enhancement".to_string(),
(B[m[32m+            MEMORY_QUERY_ENHANCEMENT_PROMPT.to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         Self { templates }
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/templates.rs:170:
     }
 
     /// 渲染模板（简单的字符串替换）
[31m-    pub fn render_template(&self, name: &str, variables: &HashMap<String, String>) -> Option<String> {
(B[m[32m+    pub fn render_template(
(B[m[32m+        &self,
(B[m[32m+        name: &str,
(B[m[32m+        variables: &HashMap<String, String>,
(B[m[32m+    ) -> Option<String> {
(B[m         if let Some(template) = self.get_template(name) {
             let mut rendered = template.clone();
[31m-            
(B[m[32m+
(B[m             for (key, value) in variables {
                 let placeholder = format!("{{{}}}", key);
                 rendered = rendered.replace(&placeholder, value);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/templates.rs:180:
             }
[31m-            
(B[m[32m+
(B[m             Some(rendered)
         } else {
             None
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/templates.rs:207:
     #[test]
     fn test_add_custom_template() {
         let mut templates = PromptTemplates::new();
[31m-        templates.add_template("custom".to_string(), "Custom template: {variable}".to_string());
(B[m[31m-        
(B[m[32m+        templates.add_template(
(B[m[32m+            "custom".to_string(),
(B[m[32m+            "Custom template: {variable}".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         assert!(templates.get_template("custom").is_some());
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/prompts/templates.rs:216:
     fn test_render_template() {
         let templates = PromptTemplates::new();
         let mut variables = HashMap::new();
[31m-        variables.insert("conversation".to_string(), "Hello, how are you?".to_string());
(B[m[31m-        
(B[m[32m+        variables.insert(
(B[m[32m+            "conversation".to_string(),
(B[m[32m+            "Hello, how are you?".to_string(),
(B[m[32m+        );
(B[m[32m+
(B[m         let rendered = templates.render_template("memory_extraction", &variables);
         assert!(rendered.is_some());
         assert!(rendered.unwrap().contains("Hello, how are you?"));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/anthropic.rs:1:
 //! Anthropic Claude LLM提供商实现
 
[31m-use agent_mem_traits::{LLMProvider, LLMConfig, Message, Result, AgentMemError, ModelInfo};
(B[m[32m+use agent_mem_traits::{AgentMemError, LLMConfig, LLMProvider, Message, ModelInfo, Result};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/anthropic.rs:74:
         let client = Client::builder()
             .timeout(Duration::from_secs(60)) // Anthropic可能需要更长时间
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(format!("Failed to create HTTP client: {}", e)))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m 
[31m-        let base_url = config.base_url.clone()
(B[m[32m+        let base_url = config
(B[m[32m+            .base_url
(B[m[32m+            .clone()
(B[m             .unwrap_or_else(|| "https://api.anthropic.com".to_string());
 
         Ok(Self {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/anthropic.rs:118:
     /// 构建API请求
     fn build_request(&self, messages: &[Message]) -> AnthropicRequest {
         let (system, anthropic_messages) = self.convert_messages(messages);
[31m-        
(B[m[32m+
(B[m         AnthropicRequest {
             model: self.config.model.clone(),
             max_tokens: self.config.max_tokens.unwrap_or(4096),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/anthropic.rs:133:
 #[async_trait]
 impl LLMProvider for AnthropicProvider {
     async fn generate(&self, messages: &[Message]) -> Result<String> {
[31m-        let api_key = self.config.api_key.as_ref()
(B[m[32m+        let api_key = self
(B[m[32m+            .config
(B[m[32m+            .api_key
(B[m[32m+            .as_ref()
(B[m             .ok_or_else(|| AgentMemError::config_error("Anthropic API key not configured"))?;
 
         let request = self.build_request(messages);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/anthropic.rs:140:
         let url = format!("{}/v1/messages", self.base_url);
 
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("x-api-key", api_key)
             .header("Content-Type", "application/json")
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/anthropic.rs:151:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::llm_error(format!(
[31m-                "Anthropic API error {}: {}", status, error_text
(B[m[32m+                "Anthropic API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/anthropic.rs:161:
[31m-        let anthropic_response: AnthropicResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let anthropic_response: AnthropicResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         if anthropic_response.content.is_empty() {
             return Err(AgentMemError::llm_error("No content in Anthropic response"));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/anthropic.rs:166:
         }
 
         // 合并所有文本内容
[31m-        let content = anthropic_response.content
(B[m[32m+        let content = anthropic_response
(B[m[32m+            .content
(B[m             .iter()
             .filter(|c| c.content_type == "text")
             .map(|c| c.text.clone())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/anthropic.rs:174:
             .join("");
 
         if content.is_empty() {
[31m-            return Err(AgentMemError::llm_error("No text content in Anthropic response"));
(B[m[32m+            return Err(AgentMemError::llm_error(
(B[m[32m+                "No text content in Anthropic response",
(B[m[32m+            ));
(B[m         }
 
         Ok(content)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/anthropic.rs:181:
     }
 
[31m-    async fn generate_stream(&self, _messages: &[Message]) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m[32m+    async fn generate_stream(
(B[m[32m+        &self,
(B[m[32m+        _messages: &[Message],
(B[m[32m+    ) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m         // 流式生成的实现（简化版本）
[31m-        Err(AgentMemError::llm_error("Streaming not implemented for Anthropic provider"))
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "Streaming not implemented for Anthropic provider",
(B[m[32m+        ))
(B[m     }
 
     fn get_model_info(&self) -> ModelInfo {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/anthropic.rs:207:
         // 验证模型名称是否为已知的Anthropic模型
         let known_models = [
             "claude-3-opus-20240229",
[31m-            "claude-3-sonnet-20240229", 
(B[m[32m+            "claude-3-sonnet-20240229",
(B[m             "claude-3-haiku-20240307",
             "claude-2.1",
             "claude-2.0",
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/anthropic.rs:214:
[31m-            "claude-instant-1.2"
(B[m[32m+            "claude-instant-1.2",
(B[m         ];
 
         if !known_models.contains(&self.config.model.as_str()) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/anthropic.rs:264:
         };
 
         let provider = AnthropicProvider::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let messages = vec![
             Message {
                 role: MessageRole::System,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/azure.rs:1:
 //! Azure OpenAI LLM提供商实现
 
[31m-use agent_mem_traits::{LLMProvider, LLMConfig, Message, Result, AgentMemError, ModelInfo};
(B[m[32m+use agent_mem_traits::{AgentMemError, LLMConfig, LLMProvider, Message, ModelInfo, Result};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use std::time::Duration;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/azure.rs:18:
     pub fn new(config: LLMConfig) -> Result<Self> {
         // 验证必需的配置
         if config.api_key.is_none() {
[31m-            return Err(AgentMemError::config_error("Azure OpenAI API key is required"));
(B[m[32m+            return Err(AgentMemError::config_error(
(B[m[32m+                "Azure OpenAI API key is required",
(B[m[32m+            ));
(B[m         }
 
         if config.base_url.is_none() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/azure.rs:25:
[31m-            return Err(AgentMemError::config_error("Azure OpenAI endpoint URL is required"));
(B[m[32m+            return Err(AgentMemError::config_error(
(B[m[32m+                "Azure OpenAI endpoint URL is required",
(B[m[32m+            ));
(B[m         }
 
         let client = Client::builder()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/azure.rs:29:
             .timeout(Duration::from_secs(30))
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(format!("Failed to create HTTP client: {}", e)))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m 
         let base_url = config.base_url.clone().unwrap();
         let api_version = "2023-12-01-preview".to_string(); // 默认API版本
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/azure.rs:53:
     async fn generate(&self, _messages: &[Message]) -> Result<String> {
         // Azure OpenAI的实现与OpenAI类似，但使用不同的认证和端点
         // 这里提供一个基础框架，实际实现需要根据Azure OpenAI的API规范
[31m-        Err(AgentMemError::llm_error("Azure OpenAI provider not fully implemented yet"))
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "Azure OpenAI provider not fully implemented yet",
(B[m[32m+        ))
(B[m     }
 
[31m-    async fn generate_stream(&self, _messages: &[Message]) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m[31m-        Err(AgentMemError::llm_error("Streaming not implemented for Azure provider"))
(B[m[32m+    async fn generate_stream(
(B[m[32m+        &self,
(B[m[32m+        _messages: &[Message],
(B[m[32m+    ) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "Streaming not implemented for Azure provider",
(B[m[32m+        ))
(B[m     }
 
     fn get_model_info(&self) -> ModelInfo {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/azure.rs:72:
 
     fn validate_config(&self) -> Result<()> {
         if self.config.api_key.is_none() {
[31m-            return Err(AgentMemError::config_error("Azure OpenAI API key is required"));
(B[m[32m+            return Err(AgentMemError::config_error(
(B[m[32m+                "Azure OpenAI API key is required",
(B[m[32m+            ));
(B[m         }
 
         if self.config.base_url.is_none() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/azure.rs:79:
[31m-            return Err(AgentMemError::config_error("Azure OpenAI endpoint URL is required"));
(B[m[32m+            return Err(AgentMemError::config_error(
(B[m[32m+                "Azure OpenAI endpoint URL is required",
(B[m[32m+            ));
(B[m         }
 
         if self.config.model.is_empty() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:1:
 //! Claude (Anthropic) LLM provider implementation
[31m-//! 
(B[m[32m+//!
(B[m //! Provides integration with Anthropic's Claude models including
 //! Claude-3, Claude-3.5, and Claude-2 series.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:6:
 use agent_mem_traits::LLMConfig;
[31m-use agent_mem_traits::{Result, AgentMemError, Message, MessageRole};
(B[m[32m+use agent_mem_traits::{AgentMemError, Message, MessageRole, Result};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:84:
 impl ClaudeProvider {
     /// Create a new Claude provider
     pub fn new(config: LLMConfig) -> Result<Self> {
[31m-        let api_key = config.api_key.clone()
(B[m[32m+        let api_key = config
(B[m[32m+            .api_key
(B[m[32m+            .clone()
(B[m             .ok_or_else(|| AgentMemError::config_error("Claude API key is required"))?;
[31m-        
(B[m[32m+
(B[m         let client = Client::builder()
             .timeout(std::time::Duration::from_secs(30)) // Default timeout
             .build()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:93:
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e)))?;
(B[m[31m-        
(B[m[31m-        let base_url = config.base_url.clone()
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m[32m+        let base_url = config
(B[m[32m+            .base_url
(B[m[32m+            .clone()
(B[m             .unwrap_or_else(|| "https://api.anthropic.com".to_string());
[31m-        
(B[m[32m+
(B[m         Ok(Self {
             config,
             client,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:102:
             base_url,
         })
     }
[31m-    
(B[m[32m+
(B[m     /// Get available Claude models
     pub fn available_models() -> Vec<&'static str> {
         vec![
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:116:
             "claude-instant-1.2",
         ]
     }
[31m-    
(B[m[32m+
(B[m     /// Convert AgentMem message to Claude message
     fn convert_message(&self, message: &Message) -> ClaudeMessage {
         let role = match message.role {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:124:
             MessageRole::User => "user",
             MessageRole::Assistant => "assistant",
         };
[31m-        
(B[m[32m+
(B[m         ClaudeMessage {
             role: role.to_string(),
             content: message.content.clone(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:131:
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Build Claude API request
     fn build_request(&self, messages: &[Message]) -> Result<ClaudeRequest> {
         let mut claude_messages = Vec::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:137:
         let mut system_message = None;
[31m-        
(B[m[32m+
(B[m         // Separate system message from conversation messages
         for message in messages {
             match message.role {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:147:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         let request = ClaudeRequest {
             model: self.config.model.clone(),
             max_tokens: self.config.max_tokens.unwrap_or(4096),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:155:
             system: system_message,
             temperature: self.config.temperature,
             top_p: self.config.top_p,
[31m-            top_k: None, // Not available in LLMConfig
(B[m[32m+            top_k: None,          // Not available in LLMConfig
(B[m             stop_sequences: None, // Not available in LLMConfig
         };
[31m-        
(B[m[32m+
(B[m         Ok(request)
     }
[31m-    
(B[m[32m+
(B[m     /// Make API request to Claude
     async fn make_request(&self, request: &ClaudeRequest) -> Result<ClaudeResponse> {
         debug!("Making Claude API request to model: {}", request.model);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:168:
[31m-        
(B[m[31m-        let response = self.client
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&format!("{}/v1/messages", self.base_url))
             .header("Content-Type", "application/json")
             .header("x-api-key", &self.api_key)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:174:
             .json(request)
             .send()
             .await
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Claude API request failed: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Claude API request failed: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         let status = response.status();
[31m-        let response_text = response.text().await
(B[m[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to read response: {}", e)))?;
(B[m[31m-        
(B[m[32m+        let response_text = response.text().await.map_err(|e| {
(B[m[32m+            AgentMemError::network_error(&format!("Failed to read response: {}", e))
(B[m[32m+        })?;
(B[m[32m+
(B[m         if status.is_success() {
[31m-            serde_json::from_str(&response_text)
(B[m[31m-                .map_err(|e| AgentMemError::parsing_error(&format!("Failed to parse Claude response: {}", e)))
(B[m[32m+            serde_json::from_str(&response_text).map_err(|e| {
(B[m[32m+                AgentMemError::parsing_error(&format!("Failed to parse Claude response: {}", e))
(B[m[32m+            })
(B[m         } else {
             // Try to parse error response
             if let Ok(error) = serde_json::from_str::<ClaudeError>(&response_text) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:189:
                 error!("Claude API error: {} - {}", error.error_type, error.message);
[31m-                Err(AgentMemError::llm_error(&format!("Claude API error: {}", error.message)))
(B[m[32m+                Err(AgentMemError::llm_error(&format!(
(B[m[32m+                    "Claude API error: {}",
(B[m[32m+                    error.message
(B[m[32m+                )))
(B[m             } else {
                 error!("Claude API error (status {}): {}", status, response_text);
[31m-                Err(AgentMemError::llm_error(&format!("Claude API error: HTTP {}", status)))
(B[m[32m+                Err(AgentMemError::llm_error(&format!(
(B[m[32m+                    "Claude API error: HTTP {}",
(B[m[32m+                    status
(B[m[32m+                )))
(B[m             }
         }
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:199:
 #[async_trait]
 impl crate::LLMProvider for ClaudeProvider {
     async fn generate(&self, messages: &[Message]) -> Result<String> {
[31m-        info!("Generating response using Claude model: {}", self.config.model);
(B[m[31m-        
(B[m[32m+        info!(
(B[m[32m+            "Generating response using Claude model: {}",
(B[m[32m+            self.config.model
(B[m[32m+        );
(B[m[32m+
(B[m         let request = self.build_request(messages)?;
         let response = self.make_request(&request).await?;
[31m-        
(B[m[32m+
(B[m         // Extract text from response content
[31m-        let text = response.content
(B[m[32m+        let text = response
(B[m[32m+            .content
(B[m             .into_iter()
             .filter(|content| content.content_type == "text")
             .map(|content| content.text)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:212:
             .collect::<Vec<_>>()
             .join("\n");
[31m-        
(B[m[32m+
(B[m         if text.is_empty() {
             return Err(AgentMemError::llm_error("Claude returned empty response"));
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:218:
[31m-        
(B[m[31m-        info!("Claude response generated successfully (tokens: input={}, output={})", 
(B[m[31m-              response.usage.input_tokens, response.usage.output_tokens);
(B[m[31m-        
(B[m[32m+
(B[m[32m+        info!(
(B[m[32m+            "Claude response generated successfully (tokens: input={}, output={})",
(B[m[32m+            response.usage.input_tokens, response.usage.output_tokens
(B[m[32m+        );
(B[m[32m+
(B[m         Ok(text)
     }
[31m-    
(B[m[31m-    async fn generate_stream(&self, messages: &[Message]) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m[32m+
(B[m[32m+    async fn generate_stream(
(B[m[32m+        &self,
(B[m[32m+        messages: &[Message],
(B[m[32m+    ) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m         // For now, fall back to non-streaming
         let response = self.generate(messages).await?;
         let stream = futures::stream::once(async move { Ok(response) });
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:229:
         Ok(Box::new(Box::pin(stream)))
     }
[31m-    
(B[m[32m+
(B[m     fn get_model_info(&self) -> agent_mem_traits::ModelInfo {
         agent_mem_traits::ModelInfo {
             provider: "anthropic".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:245:
         }
         Ok(())
     }
[31m-
(B[m[31m-
(B[m }
 
 #[cfg(test)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:253:
 mod tests {
     use super::*;
[31m-    use agent_mem_traits::{MessageRole, LLMProvider};
(B[m[32m+    use agent_mem_traits::{LLMProvider, MessageRole};
(B[m 
     fn create_test_config() -> LLMConfig {
         LLMConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:275:
         let provider = ClaudeProvider::new(config);
         assert!(provider.is_ok());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_available_models() {
         let models = ClaudeProvider::available_models();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:283:
         assert!(models.contains(&"claude-3-5-sonnet-20241022"));
         assert!(models.contains(&"claude-3-opus-20240229"));
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_message_conversion() {
         let config = create_test_config();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:290:
         let provider = ClaudeProvider::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let message = Message {
             role: MessageRole::User,
             content: "Hello, Claude!".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:295:
             timestamp: None, // No timestamp for testing
         };
[31m-        
(B[m[32m+
(B[m         let claude_message = provider.convert_message(&message);
         assert_eq!(claude_message.role, "user");
         assert_eq!(claude_message.content, "Hello, Claude!");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:301:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_request_building() {
         let config = create_test_config();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:306:
         let provider = ClaudeProvider::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let messages = vec![
             Message {
                 role: MessageRole::System,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:317:
                 timestamp: None,
             },
         ];
[31m-        
(B[m[32m+
(B[m         let request = provider.build_request(&messages).unwrap();
         assert_eq!(request.model, "claude-3-haiku-20240307");
[31m-        assert_eq!(request.system, Some("You are a helpful assistant.".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            request.system,
(B[m[32m+            Some("You are a helpful assistant.".to_string())
(B[m[32m+        );
(B[m         assert_eq!(request.messages.len(), 1);
         assert_eq!(request.messages[0].role, "user");
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:327:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_model_info() {
         let config = create_test_config();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/claude.rs:331:
         let provider = ClaudeProvider::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let info = provider.get_model_info();
         assert_eq!(info.provider, "anthropic");
         assert_eq!(info.model, "claude-3-haiku-20240307");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:1:
 //! Cohere LLM provider implementation
[31m-//! 
(B[m[32m+//!
(B[m //! Provides integration with Cohere's Command models including
 //! Command R, Command R+, and Command Light.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:6:
 use agent_mem_traits::LLMConfig;
[31m-use agent_mem_traits::{Result, AgentMemError, Message, MessageRole};
(B[m[32m+use agent_mem_traits::{AgentMemError, Message, MessageRole, Result};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:97:
 impl CohereProvider {
     /// Create a new Cohere provider
     pub fn new(config: LLMConfig) -> Result<Self> {
[31m-        let api_key = config.api_key.clone()
(B[m[32m+        let api_key = config
(B[m[32m+            .api_key
(B[m[32m+            .clone()
(B[m             .ok_or_else(|| AgentMemError::config_error("Cohere API key is required"))?;
[31m-        
(B[m[32m+
(B[m         let client = Client::builder()
             .timeout(std::time::Duration::from_secs(30)) // Default timeout
             .build()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:106:
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e)))?;
(B[m[31m-        
(B[m[31m-        let base_url = config.base_url.clone()
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m[32m+        let base_url = config
(B[m[32m+            .base_url
(B[m[32m+            .clone()
(B[m             .unwrap_or_else(|| "https://api.cohere.ai".to_string());
[31m-        
(B[m[32m+
(B[m         Ok(Self {
             config,
             client,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:115:
             base_url,
         })
     }
[31m-    
(B[m[32m+
(B[m     /// Get available Cohere models
     pub fn available_models() -> Vec<&'static str> {
         vec![
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:127:
             "command-light-nightly",
         ]
     }
[31m-    
(B[m[32m+
(B[m     /// Convert AgentMem messages to Cohere format
[31m-    fn convert_messages(&self, messages: &[Message]) -> (Option<String>, Option<String>, Option<Vec<CohereChatMessage>>) {
(B[m[32m+    fn convert_messages(
(B[m[32m+        &self,
(B[m[32m+        messages: &[Message],
(B[m[32m+    ) -> (
(B[m[32m+        Option<String>,
(B[m[32m+        Option<String>,
(B[m[32m+        Option<Vec<CohereChatMessage>>,
(B[m[32m+    ) {
(B[m         let mut preamble = None;
         let mut current_message = None;
         let mut chat_history = Vec::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:136:
[31m-        
(B[m[32m+
(B[m         for (i, message) in messages.iter().enumerate() {
             match message.role {
                 MessageRole::System => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:159:
                 }
             }
         }
[31m-        
(B[m[31m-        let history = if chat_history.is_empty() { None } else { Some(chat_history) };
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let history = if chat_history.is_empty() {
(B[m[32m+            None
(B[m[32m+        } else {
(B[m[32m+            Some(chat_history)
(B[m[32m+        };
(B[m[32m+
(B[m         (preamble, current_message, history)
     }
[31m-    
(B[m[32m+
(B[m     /// Build Cohere API request
     fn build_request(&self, messages: &[Message]) -> Result<CohereRequest> {
         let (preamble, current_message, chat_history) = self.convert_messages(messages);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:171:
[31m-        
(B[m[32m+
(B[m         let message = current_message
             .ok_or_else(|| AgentMemError::validation_error("No user message found"))?;
[31m-        
(B[m[32m+
(B[m         let request = CohereRequest {
             model: self.config.model.clone(),
             message,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:180:
             temperature: self.config.temperature,
             max_tokens: self.config.max_tokens,
             p: self.config.top_p,
[31m-            k: None, // Not available in LLMConfig
(B[m[32m+            k: None,              // Not available in LLMConfig
(B[m             stop_sequences: None, // Not available in LLMConfig
         };
[31m-        
(B[m[32m+
(B[m         Ok(request)
     }
[31m-    
(B[m[32m+
(B[m     /// Make API request to Cohere
     async fn make_request(&self, request: &CohereRequest) -> Result<CohereResponse> {
         debug!("Making Cohere API request to model: {}", request.model);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:193:
[31m-        
(B[m[31m-        let response = self.client
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&format!("{}/v1/chat", self.base_url))
             .header("Content-Type", "application/json")
             .header("Authorization", &format!("Bearer {}", self.api_key))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:198:
             .json(request)
             .send()
             .await
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Cohere API request failed: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Cohere API request failed: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         let status = response.status();
[31m-        let response_text = response.text().await
(B[m[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to read response: {}", e)))?;
(B[m[31m-        
(B[m[32m+        let response_text = response.text().await.map_err(|e| {
(B[m[32m+            AgentMemError::network_error(&format!("Failed to read response: {}", e))
(B[m[32m+        })?;
(B[m[32m+
(B[m         if status.is_success() {
[31m-            serde_json::from_str(&response_text)
(B[m[31m-                .map_err(|e| AgentMemError::parsing_error(&format!("Failed to parse Cohere response: {}", e)))
(B[m[32m+            serde_json::from_str(&response_text).map_err(|e| {
(B[m[32m+                AgentMemError::parsing_error(&format!("Failed to parse Cohere response: {}", e))
(B[m[32m+            })
(B[m         } else {
             // Try to parse error response
             if let Ok(error) = serde_json::from_str::<CohereError>(&response_text) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:213:
                 error!("Cohere API error: {}", error.message);
[31m-                Err(AgentMemError::llm_error(&format!("Cohere API error: {}", error.message)))
(B[m[32m+                Err(AgentMemError::llm_error(&format!(
(B[m[32m+                    "Cohere API error: {}",
(B[m[32m+                    error.message
(B[m[32m+                )))
(B[m             } else {
                 error!("Cohere API error (status {}): {}", status, response_text);
[31m-                Err(AgentMemError::llm_error(&format!("Cohere API error: HTTP {}", status)))
(B[m[32m+                Err(AgentMemError::llm_error(&format!(
(B[m[32m+                    "Cohere API error: HTTP {}",
(B[m[32m+                    status
(B[m[32m+                )))
(B[m             }
         }
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:223:
 #[async_trait]
 impl crate::LLMProvider for CohereProvider {
     async fn generate(&self, messages: &[Message]) -> Result<String> {
[31m-        info!("Generating response using Cohere model: {}", self.config.model);
(B[m[31m-        
(B[m[32m+        info!(
(B[m[32m+            "Generating response using Cohere model: {}",
(B[m[32m+            self.config.model
(B[m[32m+        );
(B[m[32m+
(B[m         let request = self.build_request(messages)?;
         let response = self.make_request(&request).await?;
[31m-        
(B[m[32m+
(B[m         if response.text.is_empty() {
             return Err(AgentMemError::llm_error("Cohere returned empty response"));
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:234:
[31m-        
(B[m[32m+
(B[m         if let Some(token_count) = &response.token_count {
[31m-            info!("Cohere response generated successfully (tokens: prompt={}, response={}, total={})", 
(B[m[31m-                  token_count.prompt_tokens, token_count.response_tokens, token_count.total_tokens);
(B[m[32m+            info!(
(B[m[32m+                "Cohere response generated successfully (tokens: prompt={}, response={}, total={})",
(B[m[32m+                token_count.prompt_tokens, token_count.response_tokens, token_count.total_tokens
(B[m[32m+            );
(B[m         }
[31m-        
(B[m[32m+
(B[m         Ok(response.text)
     }
[31m-    
(B[m[31m-    async fn generate_stream(&self, messages: &[Message]) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m[32m+
(B[m[32m+    async fn generate_stream(
(B[m[32m+        &self,
(B[m[32m+        messages: &[Message],
(B[m[32m+    ) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m         // For now, fall back to non-streaming
         let response = self.generate(messages).await?;
         let stream = futures::stream::once(async move { Ok(response) });
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:247:
         Ok(Box::new(Box::pin(stream)))
     }
[31m-    
(B[m[32m+
(B[m     fn get_model_info(&self) -> agent_mem_traits::ModelInfo {
         agent_mem_traits::ModelInfo {
             provider: "cohere".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:263:
         }
         Ok(())
     }
[31m-
(B[m[31m-
(B[m }
 
 #[cfg(test)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:271:
 mod tests {
     use super::*;
[31m-    use agent_mem_traits::{MessageRole, LLMProvider};
(B[m[32m+    use agent_mem_traits::{LLMProvider, MessageRole};
(B[m 
     fn create_test_config() -> LLMConfig {
         LLMConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:293:
         let provider = CohereProvider::new(config);
         assert!(provider.is_ok());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_available_models() {
         let models = CohereProvider::available_models();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:301:
         assert!(models.contains(&"command-r-plus"));
         assert!(models.contains(&"command-r"));
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_message_conversion() {
         let config = create_test_config();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:308:
         let provider = CohereProvider::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let messages = vec![
             Message {
                 role: MessageRole::System,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:329:
                 timestamp: None,
             },
         ];
[31m-        
(B[m[32m+
(B[m         let (preamble, current_message, chat_history) = provider.convert_messages(&messages);
[31m-        
(B[m[32m+
(B[m         assert_eq!(preamble, Some("You are a helpful assistant.".to_string()));
         assert_eq!(current_message, Some("How are you?".to_string()));
         assert!(chat_history.is_some());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:338:
[31m-        
(B[m[32m+
(B[m         let history = chat_history.unwrap();
         assert_eq!(history.len(), 2);
         assert_eq!(history[0].role, "USER");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:343:
         assert_eq!(history[1].role, "CHATBOT");
         assert_eq!(history[1].message, "Hi there!");
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_model_info() {
         let config = create_test_config();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/cohere.rs:350:
         let provider = CohereProvider::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let info = provider.get_model_info();
         assert_eq!(info.provider, "cohere");
         assert_eq!(info.model, "command-r");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/gemini.rs:1:
 //! Google Gemini LLM提供商实现
 
[31m-use agent_mem_traits::{LLMProvider, LLMConfig, Message, Result, AgentMemError, ModelInfo};
(B[m[32m+use agent_mem_traits::{AgentMemError, LLMConfig, LLMProvider, Message, ModelInfo, Result};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use std::time::Duration;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/gemini.rs:23:
         let client = Client::builder()
             .timeout(Duration::from_secs(30))
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(format!("Failed to create HTTP client: {}", e)))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m 
[31m-        let base_url = config.base_url.clone()
(B[m[32m+        let base_url = config
(B[m[32m+            .base_url
(B[m[32m+            .clone()
(B[m             .unwrap_or_else(|| "https://generativelanguage.googleapis.com/v1beta".to_string());
 
         Ok(Self {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/gemini.rs:41:
     async fn generate(&self, _messages: &[Message]) -> Result<String> {
         // Google Gemini的实现
         // 这里提供一个基础框架，实际实现需要根据Gemini API的规范
[31m-        Err(AgentMemError::llm_error("Gemini provider not fully implemented yet"))
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "Gemini provider not fully implemented yet",
(B[m[32m+        ))
(B[m     }
 
[31m-    async fn generate_stream(&self, _messages: &[Message]) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m[31m-        Err(AgentMemError::llm_error("Streaming not implemented for Gemini provider"))
(B[m[32m+    async fn generate_stream(
(B[m[32m+        &self,
(B[m[32m+        _messages: &[Message],
(B[m[32m+    ) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "Streaming not implemented for Gemini provider",
(B[m[32m+        ))
(B[m     }
 
     fn get_model_info(&self) -> ModelInfo {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/gemini.rs:72:
             "gemini-pro",
             "gemini-pro-vision",
             "gemini-1.5-pro",
[31m-            "gemini-1.5-flash"
(B[m[32m+            "gemini-1.5-flash",
(B[m         ];
 
         if !known_models.contains(&self.config.model.as_str()) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:1:
 //! Mistral AI LLM provider implementation
[31m-//! 
(B[m[32m+//!
(B[m //! Provides integration with Mistral AI models including
 //! Mistral Large, Mistral Medium, and Mistral Small.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:6:
 use agent_mem_traits::LLMConfig;
[31m-use agent_mem_traits::{Result, AgentMemError, Message, MessageRole};
(B[m[32m+use agent_mem_traits::{AgentMemError, Message, MessageRole, Result};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:91:
 impl MistralProvider {
     /// Create a new Mistral provider
     pub fn new(config: LLMConfig) -> Result<Self> {
[31m-        let api_key = config.api_key.clone()
(B[m[32m+        let api_key = config
(B[m[32m+            .api_key
(B[m[32m+            .clone()
(B[m             .ok_or_else(|| AgentMemError::config_error("Mistral API key is required"))?;
[31m-        
(B[m[32m+
(B[m         let client = Client::builder()
             .timeout(std::time::Duration::from_secs(30)) // Default timeout
             .build()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:100:
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e)))?;
(B[m[31m-        
(B[m[31m-        let base_url = config.base_url.clone()
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m[32m+        let base_url = config
(B[m[32m+            .base_url
(B[m[32m+            .clone()
(B[m             .unwrap_or_else(|| "https://api.mistral.ai".to_string());
[31m-        
(B[m[32m+
(B[m         Ok(Self {
             config,
             client,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:109:
             base_url,
         })
     }
[31m-    
(B[m[32m+
(B[m     /// Get available Mistral models
     pub fn available_models() -> Vec<&'static str> {
         vec![
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:125:
             "open-mixtral-8x22b",
         ]
     }
[31m-    
(B[m[32m+
(B[m     /// Convert AgentMem message to Mistral message
     fn convert_message(&self, message: &Message) -> MistralMessage {
         let role = match message.role {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:133:
             MessageRole::User => "user",
             MessageRole::Assistant => "assistant",
         };
[31m-        
(B[m[32m+
(B[m         MistralMessage {
             role: role.to_string(),
             content: message.content.clone(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:140:
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Build Mistral API request
     fn build_request(&self, messages: &[Message]) -> Result<MistralRequest> {
         let mistral_messages: Vec<MistralMessage> = messages
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:146:
             .iter()
             .map(|msg| self.convert_message(msg))
             .collect();
[31m-        
(B[m[32m+
(B[m         if mistral_messages.is_empty() {
             return Err(AgentMemError::validation_error("No messages provided"));
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:153:
[31m-        
(B[m[32m+
(B[m         let request = MistralRequest {
             model: self.config.model.clone(),
             messages: mistral_messages,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:161:
             safe_prompt: Some(false),
             random_seed: None,
         };
[31m-        
(B[m[32m+
(B[m         Ok(request)
     }
[31m-    
(B[m[32m+
(B[m     /// Make API request to Mistral
     async fn make_request(&self, request: &MistralRequest) -> Result<MistralResponse> {
         debug!("Making Mistral API request to model: {}", request.model);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:171:
[31m-        
(B[m[31m-        let response = self.client
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&format!("{}/v1/chat/completions", self.base_url))
             .header("Content-Type", "application/json")
             .header("Authorization", &format!("Bearer {}", self.api_key))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:176:
             .json(request)
             .send()
             .await
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Mistral API request failed: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Mistral API request failed: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         let status = response.status();
[31m-        let response_text = response.text().await
(B[m[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to read response: {}", e)))?;
(B[m[31m-        
(B[m[32m+        let response_text = response.text().await.map_err(|e| {
(B[m[32m+            AgentMemError::network_error(&format!("Failed to read response: {}", e))
(B[m[32m+        })?;
(B[m[32m+
(B[m         if status.is_success() {
[31m-            serde_json::from_str(&response_text)
(B[m[31m-                .map_err(|e| AgentMemError::parsing_error(&format!("Failed to parse Mistral response: {}", e)))
(B[m[32m+            serde_json::from_str(&response_text).map_err(|e| {
(B[m[32m+                AgentMemError::parsing_error(&format!("Failed to parse Mistral response: {}", e))
(B[m[32m+            })
(B[m         } else {
             // Try to parse error response
             if let Ok(error) = serde_json::from_str::<MistralError>(&response_text) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:191:
[31m-                error!("Mistral API error: {} - {}", error.error.error_type, error.error.message);
(B[m[31m-                Err(AgentMemError::llm_error(&format!("Mistral API error: {}", error.error.message)))
(B[m[32m+                error!(
(B[m[32m+                    "Mistral API error: {} - {}",
(B[m[32m+                    error.error.error_type, error.error.message
(B[m[32m+                );
(B[m[32m+                Err(AgentMemError::llm_error(&format!(
(B[m[32m+                    "Mistral API error: {}",
(B[m[32m+                    error.error.message
(B[m[32m+                )))
(B[m             } else {
                 error!("Mistral API error (status {}): {}", status, response_text);
[31m-                Err(AgentMemError::llm_error(&format!("Mistral API error: HTTP {}", status)))
(B[m[32m+                Err(AgentMemError::llm_error(&format!(
(B[m[32m+                    "Mistral API error: HTTP {}",
(B[m[32m+                    status
(B[m[32m+                )))
(B[m             }
         }
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:201:
 #[async_trait]
 impl crate::LLMProvider for MistralProvider {
     async fn generate(&self, messages: &[Message]) -> Result<String> {
[31m-        info!("Generating response using Mistral model: {}", self.config.model);
(B[m[31m-        
(B[m[32m+        info!(
(B[m[32m+            "Generating response using Mistral model: {}",
(B[m[32m+            self.config.model
(B[m[32m+        );
(B[m[32m+
(B[m         let request = self.build_request(messages)?;
         let response = self.make_request(&request).await?;
[31m-        
(B[m[32m+
(B[m         if response.choices.is_empty() {
             return Err(AgentMemError::llm_error("Mistral returned no choices"));
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:212:
[31m-        
(B[m[32m+
(B[m         let text = response.choices[0].message.content.clone();
[31m-        
(B[m[32m+
(B[m         if text.is_empty() {
             return Err(AgentMemError::llm_error("Mistral returned empty response"));
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:218:
[31m-        
(B[m[31m-        info!("Mistral response generated successfully (tokens: prompt={}, completion={}, total={})", 
(B[m[31m-              response.usage.prompt_tokens, response.usage.completion_tokens, response.usage.total_tokens);
(B[m[31m-        
(B[m[32m+
(B[m[32m+        info!(
(B[m[32m+            "Mistral response generated successfully (tokens: prompt={}, completion={}, total={})",
(B[m[32m+            response.usage.prompt_tokens,
(B[m[32m+            response.usage.completion_tokens,
(B[m[32m+            response.usage.total_tokens
(B[m[32m+        );
(B[m[32m+
(B[m         Ok(text)
     }
[31m-    
(B[m[31m-    async fn generate_stream(&self, messages: &[Message]) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m[32m+
(B[m[32m+    async fn generate_stream(
(B[m[32m+        &self,
(B[m[32m+        messages: &[Message],
(B[m[32m+    ) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m         // For now, fall back to non-streaming
         let response = self.generate(messages).await?;
         let stream = futures::stream::once(async move { Ok(response) });
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:229:
         Ok(Box::new(Box::pin(stream)))
     }
[31m-    
(B[m[32m+
(B[m     fn get_model_info(&self) -> agent_mem_traits::ModelInfo {
         agent_mem_traits::ModelInfo {
             provider: "mistral".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:245:
         }
         Ok(())
     }
[31m-
(B[m[31m-
(B[m }
 
 #[cfg(test)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:253:
 mod tests {
     use super::*;
[31m-    use agent_mem_traits::{MessageRole, LLMProvider};
(B[m[32m+    use agent_mem_traits::{LLMProvider, MessageRole};
(B[m 
     fn create_test_config() -> LLMConfig {
         LLMConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:275:
         let provider = MistralProvider::new(config);
         assert!(provider.is_ok());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_available_models() {
         let models = MistralProvider::available_models();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:283:
         assert!(models.contains(&"mistral-large-latest"));
         assert!(models.contains(&"open-mixtral-8x7b"));
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_message_conversion() {
         let config = create_test_config();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:290:
         let provider = MistralProvider::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let message = Message {
             role: MessageRole::User,
             content: "Hello, Mistral!".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:295:
             timestamp: None,
         };
[31m-        
(B[m[32m+
(B[m         let mistral_message = provider.convert_message(&message);
         assert_eq!(mistral_message.role, "user");
         assert_eq!(mistral_message.content, "Hello, Mistral!");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:301:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_request_building() {
         let config = create_test_config();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:306:
         let provider = MistralProvider::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let messages = vec![
             Message {
                 role: MessageRole::System,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:317:
                 timestamp: None,
             },
         ];
[31m-        
(B[m[32m+
(B[m         let request = provider.build_request(&messages).unwrap();
         assert_eq!(request.model, "mistral-small-latest");
         assert_eq!(request.messages.len(), 2);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:324:
         assert_eq!(request.messages[0].role, "system");
         assert_eq!(request.messages[1].role, "user");
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_model_info() {
         let config = create_test_config();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mistral.rs:331:
         let provider = MistralProvider::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let info = provider.get_model_info();
         assert_eq!(info.provider, "mistral");
         assert_eq!(info.model, "mistral-small-latest");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/mod.rs:1:
 //! LLM提供商实现模块
 
[31m-pub mod openai;
(B[m pub mod anthropic;
 pub mod azure;
[31m-pub mod gemini;
(B[m[31m-pub mod ollama;
(B[m pub mod claude;
 pub mod cohere;
[32m+pub mod gemini;
(B[m pub mod mistral;
[32m+pub mod ollama;
(B[m[32m+pub mod openai;
(B[m pub mod perplexity;
 
[31m-pub use openai::OpenAIProvider;
(B[m pub use anthropic::AnthropicProvider;
 pub use azure::AzureProvider;
[31m-pub use gemini::GeminiProvider;
(B[m[31m-pub use ollama::OllamaProvider;
(B[m pub use claude::ClaudeProvider;
 pub use cohere::CohereProvider;
[32m+pub use gemini::GeminiProvider;
(B[m pub use mistral::MistralProvider;
[32m+pub use ollama::OllamaProvider;
(B[m[32m+pub use openai::OpenAIProvider;
(B[m pub use perplexity::PerplexityProvider;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/ollama.rs:1:
 //! Ollama本地LLM提供商实现
 
[31m-use agent_mem_traits::{LLMProvider, LLMConfig, Message, Result, AgentMemError, ModelInfo};
(B[m[32m+use agent_mem_traits::{AgentMemError, LLMConfig, LLMProvider, Message, ModelInfo, Result};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/ollama.rs:64:
         let client = Client::builder()
             .timeout(Duration::from_secs(120)) // Ollama可能需要更长时间
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(format!("Failed to create HTTP client: {}", e)))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m 
[31m-        let base_url = config.base_url.clone()
(B[m[32m+        let base_url = config
(B[m[32m+            .base_url
(B[m[32m+            .clone()
(B[m             .unwrap_or_else(|| "http://localhost:11434".to_string());
 
         Ok(Self {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/ollama.rs:78:
 
     /// 将Message转换为Ollama格式
     fn convert_messages(&self, messages: &[Message]) -> Vec<OllamaMessage> {
[31m-        messages.iter().map(|msg| {
(B[m[31m-            let role = match msg.role {
(B[m[31m-                agent_mem_traits::MessageRole::System => "system",
(B[m[31m-                agent_mem_traits::MessageRole::User => "user",
(B[m[31m-                agent_mem_traits::MessageRole::Assistant => "assistant",
(B[m[31m-            };
(B[m[31m-            
(B[m[31m-            OllamaMessage {
(B[m[31m-                role: role.to_string(),
(B[m[31m-                content: msg.content.clone(),
(B[m[31m-            }
(B[m[31m-        }).collect()
(B[m[32m+        messages
(B[m[32m+            .iter()
(B[m[32m+            .map(|msg| {
(B[m[32m+                let role = match msg.role {
(B[m[32m+                    agent_mem_traits::MessageRole::System => "system",
(B[m[32m+                    agent_mem_traits::MessageRole::User => "user",
(B[m[32m+                    agent_mem_traits::MessageRole::Assistant => "assistant",
(B[m[32m+                };
(B[m[32m+
(B[m[32m+                OllamaMessage {
(B[m[32m+                    role: role.to_string(),
(B[m[32m+                    content: msg.content.clone(),
(B[m[32m+                }
(B[m[32m+            })
(B[m[32m+            .collect()
(B[m     }
 
     /// 构建API请求
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/ollama.rs:96:
     fn build_request(&self, messages: &[Message]) -> OllamaRequest {
[31m-        let options = if self.config.temperature.is_some() || 
(B[m[31m-                        self.config.top_p.is_some() || 
(B[m[31m-                        self.config.max_tokens.is_some() {
(B[m[32m+        let options = if self.config.temperature.is_some()
(B[m[32m+            || self.config.top_p.is_some()
(B[m[32m+            || self.config.max_tokens.is_some()
(B[m[32m+        {
(B[m             Some(OllamaOptions {
                 temperature: self.config.temperature,
                 top_p: self.config.top_p,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/ollama.rs:121:
         let request = self.build_request(messages);
         let url = format!("{}/api/chat", self.base_url);
 
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Content-Type", "application/json")
             .json(&request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/ollama.rs:131:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::llm_error(format!(
[31m-                "Ollama API error {}: {}", status, error_text
(B[m[32m+                "Ollama API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/ollama.rs:141:
[31m-        let ollama_response: OllamaResponse = response.json().await
(B[m[32m+        let ollama_response: OllamaResponse = response
(B[m[32m+            .json()
(B[m[32m+            .await
(B[m             .map_err(|e| AgentMemError::llm_error(format!("Failed to parse response: {}", e)))?;
 
         Ok(ollama_response.message.content)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/ollama.rs:145:
     }
 
[31m-    async fn generate_stream(&self, _messages: &[Message]) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m[32m+    async fn generate_stream(
(B[m[32m+        &self,
(B[m[32m+        _messages: &[Message],
(B[m[32m+    ) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m         // 流式生成的实现（简化版本）
[31m-        Err(AgentMemError::llm_error("Streaming not implemented for Ollama provider"))
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "Streaming not implemented for Ollama provider",
(B[m[32m+        ))
(B[m     }
 
     fn get_model_info(&self) -> ModelInfo {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/ollama.rs:167:
         // 验证base_url格式
         if let Some(ref url) = self.config.base_url {
             if !url.starts_with("http://") && !url.starts_with("https://") {
[31m-                return Err(AgentMemError::config_error("Base URL must start with http:// or https://"));
(B[m[32m+                return Err(AgentMemError::config_error(
(B[m[32m+                    "Base URL must start with http:// or https://",
(B[m[32m+                ));
(B[m             }
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/ollama.rs:202:
         };
 
         let provider = OllamaProvider::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let messages = vec![
             Message {
                 role: MessageRole::System,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/openai.rs:1:
 //! OpenAI LLM提供商实现
 
[31m-use agent_mem_traits::{LLMProvider, LLMConfig, Message, Result, AgentMemError, ModelInfo};
(B[m[32m+use agent_mem_traits::{AgentMemError, LLMConfig, LLMProvider, Message, ModelInfo, Result};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/openai.rs:75:
         let client = Client::builder()
             .timeout(Duration::from_secs(30))
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(format!("Failed to create HTTP client: {}", e)))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m 
[31m-        let base_url = config.base_url.clone()
(B[m[32m+        let base_url = config
(B[m[32m+            .base_url
(B[m[32m+            .clone()
(B[m             .unwrap_or_else(|| "https://api.openai.com/v1".to_string());
 
         Ok(Self {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/openai.rs:89:
 
     /// 将Message转换为OpenAI格式
     fn convert_messages(&self, messages: &[Message]) -> Vec<OpenAIMessage> {
[31m-        messages.iter().map(|msg| {
(B[m[31m-            let role = match msg.role {
(B[m[31m-                agent_mem_traits::MessageRole::System => "system",
(B[m[31m-                agent_mem_traits::MessageRole::User => "user",
(B[m[31m-                agent_mem_traits::MessageRole::Assistant => "assistant",
(B[m[31m-            };
(B[m[31m-            
(B[m[31m-            OpenAIMessage {
(B[m[31m-                role: role.to_string(),
(B[m[31m-                content: msg.content.clone(),
(B[m[31m-            }
(B[m[31m-        }).collect()
(B[m[32m+        messages
(B[m[32m+            .iter()
(B[m[32m+            .map(|msg| {
(B[m[32m+                let role = match msg.role {
(B[m[32m+                    agent_mem_traits::MessageRole::System => "system",
(B[m[32m+                    agent_mem_traits::MessageRole::User => "user",
(B[m[32m+                    agent_mem_traits::MessageRole::Assistant => "assistant",
(B[m[32m+                };
(B[m[32m+
(B[m[32m+                OpenAIMessage {
(B[m[32m+                    role: role.to_string(),
(B[m[32m+                    content: msg.content.clone(),
(B[m[32m+                }
(B[m[32m+            })
(B[m[32m+            .collect()
(B[m     }
 
     /// 构建API请求
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/openai.rs:120:
 #[async_trait]
 impl LLMProvider for OpenAIProvider {
     async fn generate(&self, messages: &[Message]) -> Result<String> {
[31m-        let api_key = self.config.api_key.as_ref()
(B[m[32m+        let api_key = self
(B[m[32m+            .config
(B[m[32m+            .api_key
(B[m[32m+            .as_ref()
(B[m             .ok_or_else(|| AgentMemError::config_error("OpenAI API key not configured"))?;
 
         let request = self.build_request(messages);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/openai.rs:127:
         let url = format!("{}/chat/completions", self.base_url);
 
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Authorization", format!("Bearer {}", api_key))
             .header("Content-Type", "application/json")
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/openai.rs:137:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::llm_error(format!(
[31m-                "OpenAI API error {}: {}", status, error_text
(B[m[32m+                "OpenAI API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/openai.rs:147:
[31m-        let openai_response: OpenAIResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let openai_response: OpenAIResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         if openai_response.choices.is_empty() {
             return Err(AgentMemError::llm_error("No choices in OpenAI response"));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/openai.rs:154:
         Ok(openai_response.choices[0].message.content.clone())
     }
 
[31m-    async fn generate_stream(&self, _messages: &[Message]) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m[32m+    async fn generate_stream(
(B[m[32m+        &self,
(B[m[32m+        _messages: &[Message],
(B[m[32m+    ) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m         // 流式生成的实现（简化版本）
[31m-        Err(AgentMemError::llm_error("Streaming not implemented for OpenAI provider"))
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "Streaming not implemented for OpenAI provider",
(B[m[32m+        ))
(B[m     }
 
     fn get_model_info(&self) -> ModelInfo {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/openai.rs:180:
 
         // 验证模型名称是否为已知的OpenAI模型
         let known_models = [
[31m-            "gpt-3.5-turbo", "gpt-3.5-turbo-16k",
(B[m[31m-            "gpt-4", "gpt-4-32k", "gpt-4-turbo-preview",
(B[m[31m-            "gpt-4o", "gpt-4o-mini"
(B[m[32m+            "gpt-3.5-turbo",
(B[m[32m+            "gpt-3.5-turbo-16k",
(B[m[32m+            "gpt-4",
(B[m[32m+            "gpt-4-32k",
(B[m[32m+            "gpt-4-turbo-preview",
(B[m[32m+            "gpt-4o",
(B[m[32m+            "gpt-4o-mini",
(B[m         ];
 
         if !known_models.contains(&self.config.model.as_str()) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/openai.rs:235:
         };
 
         let provider = OpenAIProvider::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let messages = vec![
             Message {
                 role: MessageRole::System,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:1:
 //! Perplexity AI LLM provider implementation
[31m-//! 
(B[m[32m+//!
(B[m //! Provides integration with Perplexity AI models including
 //! Sonar models and Llama-based models.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:6:
 use agent_mem_traits::LLMConfig;
[31m-use agent_mem_traits::{Result, AgentMemError, Message, MessageRole};
(B[m[32m+use agent_mem_traits::{AgentMemError, Message, MessageRole, Result};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:91:
 impl PerplexityProvider {
     /// Create a new Perplexity provider
     pub fn new(config: LLMConfig) -> Result<Self> {
[31m-        let api_key = config.api_key.clone()
(B[m[32m+        let api_key = config
(B[m[32m+            .api_key
(B[m[32m+            .clone()
(B[m             .ok_or_else(|| AgentMemError::config_error("Perplexity API key is required"))?;
[31m-        
(B[m[32m+
(B[m         let client = Client::builder()
             .timeout(std::time::Duration::from_secs(30)) // Default timeout
             .build()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:100:
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e)))?;
(B[m[31m-        
(B[m[31m-        let base_url = config.base_url.clone()
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m[32m+        let base_url = config
(B[m[32m+            .base_url
(B[m[32m+            .clone()
(B[m             .unwrap_or_else(|| "https://api.perplexity.ai".to_string());
[31m-        
(B[m[32m+
(B[m         Ok(Self {
             config,
             client,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:109:
             base_url,
         })
     }
[31m-    
(B[m[32m+
(B[m     /// Get available Perplexity models
     pub fn available_models() -> Vec<&'static str> {
         vec![
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:124:
             "mistral-7b-instruct",
         ]
     }
[31m-    
(B[m[32m+
(B[m     /// Convert AgentMem message to Perplexity message
     fn convert_message(&self, message: &Message) -> PerplexityMessage {
         let role = match message.role {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:132:
             MessageRole::User => "user",
             MessageRole::Assistant => "assistant",
         };
[31m-        
(B[m[32m+
(B[m         PerplexityMessage {
             role: role.to_string(),
             content: message.content.clone(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:139:
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Build Perplexity API request
     fn build_request(&self, messages: &[Message]) -> Result<PerplexityRequest> {
         let perplexity_messages: Vec<PerplexityMessage> = messages
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:145:
             .iter()
             .map(|msg| self.convert_message(msg))
             .collect();
[31m-        
(B[m[32m+
(B[m         if perplexity_messages.is_empty() {
             return Err(AgentMemError::validation_error("No messages provided"));
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:152:
[31m-        
(B[m[32m+
(B[m         let request = PerplexityRequest {
             model: self.config.model.clone(),
             messages: perplexity_messages,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:160:
             presence_penalty: None,
             frequency_penalty: None,
         };
[31m-        
(B[m[32m+
(B[m         Ok(request)
     }
[31m-    
(B[m[32m+
(B[m     /// Make API request to Perplexity
     async fn make_request(&self, request: &PerplexityRequest) -> Result<PerplexityResponse> {
         debug!("Making Perplexity API request to model: {}", request.model);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:170:
[31m-        
(B[m[31m-        let response = self.client
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&format!("{}/chat/completions", self.base_url))
             .header("Content-Type", "application/json")
             .header("Authorization", &format!("Bearer {}", self.api_key))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:175:
             .json(request)
             .send()
             .await
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Perplexity API request failed: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Perplexity API request failed: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         let status = response.status();
[31m-        let response_text = response.text().await
(B[m[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to read response: {}", e)))?;
(B[m[31m-        
(B[m[32m+        let response_text = response.text().await.map_err(|e| {
(B[m[32m+            AgentMemError::network_error(&format!("Failed to read response: {}", e))
(B[m[32m+        })?;
(B[m[32m+
(B[m         if status.is_success() {
[31m-            serde_json::from_str(&response_text)
(B[m[31m-                .map_err(|e| AgentMemError::parsing_error(&format!("Failed to parse Perplexity response: {}", e)))
(B[m[32m+            serde_json::from_str(&response_text).map_err(|e| {
(B[m[32m+                AgentMemError::parsing_error(&format!("Failed to parse Perplexity response: {}", e))
(B[m[32m+            })
(B[m         } else {
             // Try to parse error response
             if let Ok(error) = serde_json::from_str::<PerplexityError>(&response_text) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:190:
[31m-                error!("Perplexity API error: {} - {}", error.error.error_type, error.error.message);
(B[m[31m-                Err(AgentMemError::llm_error(&format!("Perplexity API error: {}", error.error.message)))
(B[m[32m+                error!(
(B[m[32m+                    "Perplexity API error: {} - {}",
(B[m[32m+                    error.error.error_type, error.error.message
(B[m[32m+                );
(B[m[32m+                Err(AgentMemError::llm_error(&format!(
(B[m[32m+                    "Perplexity API error: {}",
(B[m[32m+                    error.error.message
(B[m[32m+                )))
(B[m             } else {
[31m-                error!("Perplexity API error (status {}): {}", status, response_text);
(B[m[31m-                Err(AgentMemError::llm_error(&format!("Perplexity API error: HTTP {}", status)))
(B[m[32m+                error!(
(B[m[32m+                    "Perplexity API error (status {}): {}",
(B[m[32m+                    status, response_text
(B[m[32m+                );
(B[m[32m+                Err(AgentMemError::llm_error(&format!(
(B[m[32m+                    "Perplexity API error: HTTP {}",
(B[m[32m+                    status
(B[m[32m+                )))
(B[m             }
         }
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:200:
 #[async_trait]
 impl crate::LLMProvider for PerplexityProvider {
     async fn generate(&self, messages: &[Message]) -> Result<String> {
[31m-        info!("Generating response using Perplexity model: {}", self.config.model);
(B[m[31m-        
(B[m[32m+        info!(
(B[m[32m+            "Generating response using Perplexity model: {}",
(B[m[32m+            self.config.model
(B[m[32m+        );
(B[m[32m+
(B[m         let request = self.build_request(messages)?;
         let response = self.make_request(&request).await?;
[31m-        
(B[m[32m+
(B[m         if response.choices.is_empty() {
             return Err(AgentMemError::llm_error("Perplexity returned no choices"));
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:211:
[31m-        
(B[m[32m+
(B[m         let text = response.choices[0].message.content.clone();
[31m-        
(B[m[32m+
(B[m         if text.is_empty() {
[31m-            return Err(AgentMemError::llm_error("Perplexity returned empty response"));
(B[m[32m+            return Err(AgentMemError::llm_error(
(B[m[32m+                "Perplexity returned empty response",
(B[m[32m+            ));
(B[m         }
[31m-        
(B[m[32m+
(B[m         info!("Perplexity response generated successfully (tokens: prompt={}, completion={}, total={})", 
               response.usage.prompt_tokens, response.usage.completion_tokens, response.usage.total_tokens);
[31m-        
(B[m[32m+
(B[m         Ok(text)
     }
[31m-    
(B[m[31m-    async fn generate_stream(&self, messages: &[Message]) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m[32m+
(B[m[32m+    async fn generate_stream(
(B[m[32m+        &self,
(B[m[32m+        messages: &[Message],
(B[m[32m+    ) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>> {
(B[m         // For now, fall back to non-streaming
         let response = self.generate(messages).await?;
         let stream = futures::stream::once(async move { Ok(response) });
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:228:
         Ok(Box::new(Box::pin(stream)))
     }
[31m-    
(B[m[32m+
(B[m     fn get_model_info(&self) -> agent_mem_traits::ModelInfo {
         agent_mem_traits::ModelInfo {
             provider: "perplexity".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:240:
 
     fn validate_config(&self) -> Result<()> {
         if self.api_key.is_empty() {
[31m-            return Err(AgentMemError::config_error("Perplexity API key is required"));
(B[m[32m+            return Err(AgentMemError::config_error(
(B[m[32m+                "Perplexity API key is required",
(B[m[32m+            ));
(B[m         }
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:247:
[31m-
(B[m[31m-
(B[m }
 
 #[cfg(test)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:252:
 mod tests {
     use super::*;
[31m-    use agent_mem_traits::{MessageRole, LLMProvider};
(B[m[32m+    use agent_mem_traits::{LLMProvider, MessageRole};
(B[m 
     fn create_test_config() -> LLMConfig {
         LLMConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:274:
         let provider = PerplexityProvider::new(config);
         assert!(provider.is_ok());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_available_models() {
         let models = PerplexityProvider::available_models();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:282:
         assert!(models.contains(&"llama-3.1-sonar-large-128k-online"));
         assert!(models.contains(&"mixtral-8x7b-instruct"));
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_message_conversion() {
         let config = create_test_config();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:289:
         let provider = PerplexityProvider::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let message = Message {
             role: MessageRole::User,
             content: "Hello, Perplexity!".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:294:
             timestamp: None,
         };
[31m-        
(B[m[32m+
(B[m         let perplexity_message = provider.convert_message(&message);
         assert_eq!(perplexity_message.role, "user");
         assert_eq!(perplexity_message.content, "Hello, Perplexity!");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:300:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_model_info() {
         let config = create_test_config();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-llm/src/providers/perplexity.rs:305:
         let provider = PerplexityProvider::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let info = provider.get_model_info();
         assert_eq!(info.provider, "perplexity");
         assert_eq!(info.model, "llama-3.1-sonar-small-128k-chat");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:1:
 //! Async batch processing for improved performance
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides efficient batch processing capabilities for memory operations,
 //! reducing overhead and improving throughput.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use async_trait::async_trait;
 use serde::{Deserialize, Serialize};
 use std::collections::VecDeque;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:77:
 
     /// Process a single item
     async fn process(&self) -> std::result::Result<Self::Output, Self::Error>;
[31m-    
(B[m[32m+
(B[m     /// Get item size for batching decisions
     fn size(&self) -> usize {
         1
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:84:
     }
[31m-    
(B[m[32m+
(B[m     /// Get item priority (higher = more priority)
     fn priority(&self) -> u8 {
         0
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:132:
             });
         }
 
[31m-        info!("Batch processor started with {} workers", config.concurrency);
(B[m[32m+        info!(
(B[m[32m+            "Batch processor started with {} workers",
(B[m[32m+            config.concurrency
(B[m[32m+        );
(B[m         Ok(processor)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:142:
         T: BatchItem,
     {
         let (response_tx, response_rx) = tokio::sync::oneshot::channel();
[31m-        
(B[m[32m+
(B[m         // Convert to boxed trait object
         let boxed_item = Box::new(GenericBatchItem::new(item));
[31m-        
(B[m[32m+
(B[m         let request = BatchRequest {
             item: boxed_item,
             response_tx,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:152:
         };
 
[31m-        self.sender.send(request)
(B[m[32m+        self.sender
(B[m[32m+            .send(request)
(B[m             .map_err(|_| AgentMemError::memory_error("Batch processor channel closed"))?;
 
[31m-        let result = response_rx.await
(B[m[32m+        let result = response_rx
(B[m[32m+            .await
(B[m             .map_err(|_| AgentMemError::memory_error("Batch processing response lost"))?;
 
         // Convert back to original type
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:248:
 
     async fn run(mut self) {
         debug!("Batch worker {} started", self.id);
[31m-        
(B[m[32m+
(B[m         let mut flush_interval = interval(Duration::from_millis(self.config.max_wait_time_ms));
[31m-        
(B[m[32m+
(B[m         loop {
             tokio::select! {
                 // Receive new items
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:276:
                         }
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 // Periodic flush
                 _ = flush_interval.tick() => {
                     if !self.batch_buffer.is_empty() && self.should_flush_by_time() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:285:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         debug!("Batch worker {} stopped", self.id);
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:306:
         let batch_size = self.batch_buffer.len();
         let start_time = Instant::now();
 
[31m-        debug!("Worker {} processing batch of {} items", self.id, batch_size);
(B[m[32m+        debug!(
(B[m[32m+            "Worker {} processing batch of {} items",
(B[m[32m+            self.id, batch_size
(B[m[32m+        );
(B[m 
         // Process all items in the batch
         let mut processed = 0;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:314:
 
         while let Some(request) = self.batch_buffer.pop_front() {
             let result = self.process_item(request.item).await;
[31m-            
(B[m[32m+
(B[m             match result {
                 Ok(output) => {
                     processed += 1;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:331:
         self.last_flush = Instant::now();
 
         // Update statistics
[31m-        self.update_stats(batch_size, processed, failed, processing_time).await;
(B[m[32m+        self.update_stats(batch_size, processed, failed, processing_time)
(B[m[32m+            .await;
(B[m 
         debug!(
             "Worker {} completed batch: {} processed, {} failed, took {:?}",
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:344:
         item: Box<dyn BatchItem<Output = Vec<u8>, Error = AgentMemError>>,
     ) -> Result<Vec<u8>> {
         let mut attempts = 0;
[31m-        
(B[m[32m+
(B[m         loop {
             match item.process().await {
                 Ok(result) => return Ok(result),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:352:
                     attempts += 1;
                     if attempts >= self.config.retry_attempts {
                         return Err(AgentMemError::memory_error(&format!(
[31m-                            "Failed after {} attempts: {}", attempts, e
(B[m[32m+                            "Failed after {} attempts: {}",
(B[m[32m+                            attempts, e
(B[m                         )));
                     }
[31m-                    
(B[m[32m+
(B[m                     tokio::time::sleep(Duration::from_millis(self.config.retry_delay_ms)).await;
                 }
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:362:
         }
     }
 
[31m-    async fn update_stats(&self, batch_size: usize, processed: u64, failed: u64, duration: Duration) {
(B[m[32m+    async fn update_stats(
(B[m[32m+        &self,
(B[m[32m+        batch_size: usize,
(B[m[32m+        processed: u64,
(B[m[32m+        failed: u64,
(B[m[32m+        duration: Duration,
(B[m[32m+    ) {
(B[m         let mut stats = self.stats.write().await;
[31m-        
(B[m[32m+
(B[m         stats.processed_items += processed;
         stats.failed_items += failed;
         stats.total_batches += 1;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:371:
[31m-        
(B[m[32m+
(B[m         // Update averages
         let total_items = stats.processed_items + stats.failed_items;
         if total_items > 0 {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:375:
             stats.average_batch_size = total_items as f64 / stats.total_batches as f64;
         }
[31m-        
(B[m[32m+
(B[m         let duration_ms = duration.as_millis() as f64;
         if stats.total_batches > 0 {
[31m-            stats.average_processing_time_ms = 
(B[m[31m-                (stats.average_processing_time_ms * (stats.total_batches - 1) as f64 + duration_ms) 
(B[m[31m-                / stats.total_batches as f64;
(B[m[32m+            stats.average_processing_time_ms =
(B[m[32m+                (stats.average_processing_time_ms * (stats.total_batches - 1) as f64 + duration_ms)
(B[m[32m+                    / stats.total_batches as f64;
(B[m         }
[31m-        
(B[m[32m+
(B[m         // Calculate throughput (items per second)
         if duration_ms > 0.0 {
             stats.throughput_items_per_second = batch_size as f64 / (duration_ms / 1000.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:426:
             max_wait_time_ms: 100,
             ..Default::default()
         };
[31m-        
(B[m[32m+
(B[m         let processor = BatchProcessor::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let item = TestBatchItem {
             data: "test".to_string(),
             should_fail: false,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:435:
         };
[31m-        
(B[m[32m+
(B[m         let result = processor.submit(item).await;
         assert!(result.is_ok());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/batch.rs:442:
     async fn test_batch_stats() {
         let config = BatchConfig::default();
         let processor = BatchProcessor::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let stats = processor.get_stats().await.unwrap();
         assert_eq!(stats.processed_items, 0);
         assert_eq!(stats.failed_items, 0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:1:
 //! Multi-level caching system for improved performance
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides a sophisticated caching system with multiple levels,
 //! intelligent eviction policies, and cache warming capabilities.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use dashmap::DashMap;
 use lru::LruCache;
 use parking_lot::RwLock;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:149:
 impl CacheManager {
     /// Create a new cache manager
     pub async fn new(config: CacheConfig) -> Result<Self> {
[31m-        let l1_cache = Arc::new(RwLock::new(
(B[m[31m-            LruCache::new(NonZeroUsize::new(config.l1_size).unwrap())
(B[m[31m-        ));
(B[m[31m-        
(B[m[32m+        let l1_cache = Arc::new(RwLock::new(LruCache::new(
(B[m[32m+            NonZeroUsize::new(config.l1_size).unwrap(),
(B[m[32m+        )));
(B[m[32m+
(B[m         let l2_cache = Arc::new(DashMap::new());
[31m-        
(B[m[32m+
(B[m         let l3_cache = if config.l3_size.is_some() {
             Some(Arc::new(AsyncRwLock::new(HashMap::new())))
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:175:
         if manager.config.enable_stats {
             manager.start_stats_updater().await;
         }
[31m-        
(B[m[32m+
(B[m         manager.start_cleanup_task().await;
 
[31m-        info!("Cache manager initialized with L1: {}, L2: {}, L3: {:?}", 
(B[m[31m-              manager.config.l1_size, 
(B[m[31m-              manager.config.l2_size, 
(B[m[31m-              manager.config.l3_size);
(B[m[32m+        info!(
(B[m[32m+            "Cache manager initialized with L1: {}, L2: {}, L3: {:?}",
(B[m[32m+            manager.config.l1_size, manager.config.l2_size, manager.config.l3_size
(B[m[32m+        );
(B[m 
         Ok(manager)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:219:
     }
 
     /// Put a value into cache
[31m-    pub async fn put<K: AsRef<str>>(&self, key: K, value: Vec<u8>, ttl: Option<Duration>) -> Result<()> {
(B[m[32m+    pub async fn put<K: AsRef<str>>(
(B[m[32m+        &self,
(B[m[32m+        key: K,
(B[m[32m+        value: Vec<u8>,
(B[m[32m+        ttl: Option<Duration>,
(B[m[32m+    ) -> Result<()> {
(B[m         let key_str = key.as_ref().to_string();
         let size = value.len();
[31m-        
(B[m[32m+
(B[m         // Always put in L1 first
         self.put_to_l1(&key_str, &value).await;
[31m-        
(B[m[32m+
(B[m         // Put in L2 if it doesn't fit in L1 or for redundancy
         self.put_to_l2(&key_str, &value).await;
[31m-        
(B[m[32m+
(B[m         // Put in L3 if available
         if self.l3_cache.is_some() {
             self.put_to_l3(&key_str, &value).await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:241:
     /// Remove a value from cache
     pub async fn remove<K: AsRef<str>>(&self, key: K) -> Result<bool> {
         let key_str = key.as_ref();
[31m-        
(B[m[32m+
(B[m         let mut removed = false;
[31m-        
(B[m[32m+
(B[m         // Remove from all levels
         if self.remove_from_l1(key_str).await {
             removed = true;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:250:
         }
[31m-        
(B[m[32m+
(B[m         if self.remove_from_l2(key_str).await {
             removed = true;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:255:
[31m-        
(B[m[32m+
(B[m         if self.remove_from_l3(key_str).await {
             removed = true;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:268:
     pub async fn clear(&self) -> Result<()> {
         self.l1_cache.write().clear();
         self.l2_cache.clear();
[31m-        
(B[m[32m+
(B[m         if let Some(l3) = &self.l3_cache {
             l3.write().await.clear();
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:379:
     // Statistics and maintenance
     async fn update_stats_hit(&self, level: u8, access_time: Duration) {
         let mut stats = self.stats.write().await;
[31m-        
(B[m[32m+
(B[m         match level {
             1 => stats.l1_hits += 1,
             2 => stats.l2_hits += 1,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:391:
         let total_accesses = stats.l1_hits + stats.l2_hits + stats.l3_hits;
         if total_accesses > 0 {
             let access_time_ms = access_time.as_millis() as f64;
[31m-            stats.average_access_time_ms = 
(B[m[31m-                (stats.average_access_time_ms * (total_accesses - 1) as f64 + access_time_ms) 
(B[m[31m-                / total_accesses as f64;
(B[m[32m+            stats.average_access_time_ms =
(B[m[32m+                (stats.average_access_time_ms * (total_accesses - 1) as f64 + access_time_ms)
(B[m[32m+                    / total_accesses as f64;
(B[m         }
 
         // Update hit rate
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:400:
[31m-        let total_requests = stats.l1_hits + stats.l2_hits + stats.l3_hits + 
(B[m[31m-                           stats.l1_misses + stats.l2_misses + stats.l3_misses;
(B[m[32m+        let total_requests = stats.l1_hits
(B[m[32m+            + stats.l2_hits
(B[m[32m+            + stats.l3_hits
(B[m[32m+            + stats.l1_misses
(B[m[32m+            + stats.l2_misses
(B[m[32m+            + stats.l3_misses;
(B[m         if total_requests > 0 {
[31m-            stats.hit_rate = (stats.l1_hits + stats.l2_hits + stats.l3_hits) as f64 / total_requests as f64;
(B[m[32m+            stats.hit_rate =
(B[m[32m+                (stats.l1_hits + stats.l2_hits + stats.l3_hits) as f64 / total_requests as f64;
(B[m         }
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:411:
         stats.l3_misses += 1;
 
         // Update hit rate
[31m-        let total_requests = stats.l1_hits + stats.l2_hits + stats.l3_hits + 
(B[m[31m-                           stats.l1_misses + stats.l2_misses + stats.l3_misses;
(B[m[32m+        let total_requests = stats.l1_hits
(B[m[32m+            + stats.l2_hits
(B[m[32m+            + stats.l3_hits
(B[m[32m+            + stats.l1_misses
(B[m[32m+            + stats.l2_misses
(B[m[32m+            + stats.l3_misses;
(B[m         if total_requests > 0 {
[31m-            stats.hit_rate = (stats.l1_hits + stats.l2_hits + stats.l3_hits) as f64 / total_requests as f64;
(B[m[32m+            stats.hit_rate =
(B[m[32m+                (stats.l1_hits + stats.l2_hits + stats.l3_hits) as f64 / total_requests as f64;
(B[m         }
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:426:
 
         tokio::spawn(async move {
             let mut interval = interval(Duration::from_secs(60)); // Update every minute
[31m-            
(B[m[32m+
(B[m             loop {
                 interval.tick().await;
[31m-                
(B[m[32m+
(B[m                 let mut stats_guard = stats.write().await;
[31m-                
(B[m[32m+
(B[m                 // Update entry counts and memory usage
                 stats_guard.total_entries = l1_cache.read().len() + l2_cache.len();
                 stats_guard.memory_usage_bytes = 0; // Simplified - would calculate actual usage
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:438:
[31m-                
(B[m[32m+
(B[m                 if let Some(l3) = &l3_cache {
                     stats_guard.total_entries += l3.read().await.len();
                 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:449:
 
         tokio::spawn(async move {
             let mut interval = interval(Duration::from_secs(300)); // Cleanup every 5 minutes
[31m-            
(B[m[32m+
(B[m             loop {
                 interval.tick().await;
[31m-                
(B[m[32m+
(B[m                 // Clean expired entries from L2
                 l2_cache.retain(|_, entry| !entry.is_expired());
[31m-                
(B[m[32m+
(B[m                 // Clean expired entries from L3
                 if let Some(l3) = &l3_cache {
                     let mut cache = l3.write().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:481:
     async fn test_cache_put_get() {
         let config = CacheConfig::default();
         let manager = CacheManager::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let key = "test_key";
         let value = b"test_value".to_vec();
[31m-        
(B[m[32m+
(B[m         manager.put(key, value.clone(), None).await.unwrap();
         let retrieved = manager.get(key).await.unwrap();
[31m-        
(B[m[32m+
(B[m         assert_eq!(retrieved, Some(value));
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:495:
     async fn test_cache_remove() {
         let config = CacheConfig::default();
         let manager = CacheManager::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let key = "test_key";
         let value = b"test_value".to_vec();
[31m-        
(B[m[32m+
(B[m         manager.put(key, value, None).await.unwrap();
         let removed = manager.remove(key).await.unwrap();
         assert!(removed);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:505:
[31m-        
(B[m[32m+
(B[m         let retrieved = manager.get(key).await.unwrap();
         assert_eq!(retrieved, None);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/cache.rs:511:
     async fn test_cache_stats() {
         let config = CacheConfig::default();
         let manager = CacheManager::new(config).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let stats = manager.get_stats().await.unwrap();
         assert_eq!(stats.l1_hits, 0);
         assert_eq!(stats.total_entries, 0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:1:
 //! Concurrency control and task management
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides advanced concurrency control mechanisms including
 //! rate limiting, circuit breakers, and adaptive task scheduling.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
 use std::sync::Arc;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:108:
             failed_tasks: AtomicU64::new(0),
         };
 
[31m-        info!("Concurrency manager initialized with {} max tasks", manager.config.max_concurrent_tasks);
(B[m[32m+        info!(
(B[m[32m+            "Concurrency manager initialized with {} max tasks",
(B[m[32m+            manager.config.max_concurrent_tasks
(B[m[32m+        );
(B[m         Ok(manager)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:128:
         self.rate_limiter.acquire().await?;
 
         // Acquire semaphore permit
[31m-        let _permit = self.semaphore.acquire().await
(B[m[32m+        let _permit = self
(B[m[32m+            .semaphore
(B[m[32m+            .acquire()
(B[m[32m+            .await
(B[m             .map_err(|_| AgentMemError::memory_error("Failed to acquire semaphore permit"))?;
 
         self.active_tasks.fetch_add(1, Ordering::Relaxed);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:135:
         let start_time = Instant::now();
 
         let result = task().await;
[31m-        
(B[m[32m+
(B[m         let duration = start_time.elapsed();
         self.active_tasks.fetch_sub(1, Ordering::Relaxed);
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:162:
         stats.failed_tasks = self.failed_tasks.load(Ordering::Relaxed);
         stats.circuit_breaker_state = self.circuit_breaker.get_state().await;
         stats.current_rps = self.rate_limiter.get_current_rate().await;
[31m-        
(B[m[32m+
(B[m         Ok(stats)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:169:
     async fn update_stats(&self, duration: Duration) {
         let mut stats = self.stats.write().await;
[31m-        
(B[m[32m+
(B[m         let total_tasks = stats.completed_tasks + stats.failed_tasks + 1;
         let duration_ms = duration.as_millis() as f64;
[31m-        
(B[m[31m-        stats.average_task_duration_ms = 
(B[m[31m-            (stats.average_task_duration_ms * (total_tasks - 1) as f64 + duration_ms) 
(B[m[31m-            / total_tasks as f64;
(B[m[32m+
(B[m[32m+        stats.average_task_duration_ms =
(B[m[32m+            (stats.average_task_duration_ms * (total_tasks - 1) as f64 + duration_ms)
(B[m[32m+                / total_tasks as f64;
(B[m     }
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:215:
         let now = Instant::now();
         let mut last_refill = self.last_refill.write().await;
         let elapsed = now.duration_since(*last_refill);
[31m-        
(B[m[32m+
(B[m         if elapsed >= Duration::from_millis(1) {
             let mut tokens = self.tokens.write().await;
             let tokens_to_add = elapsed.as_secs_f64() * self.max_rps as f64;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:270:
 
     async fn record_failure(&self) {
         let failures = self.failure_count.fetch_add(1, Ordering::Relaxed) + 1;
[31m-        
(B[m[32m+
(B[m         if failures >= self.failure_threshold as u64 {
             let mut state = self.state.write().await;
             *state = CircuitBreakerState::Open;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:277:
[31m-            
(B[m[32m+
(B[m             let mut last_failure = self.last_failure_time.write().await;
             *last_failure = Some(Instant::now());
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:313:
     async fn test_task_execution() {
         let config = ConcurrencyConfig::default();
         let manager = ConcurrencyManager::new(config).unwrap();
[31m-        
(B[m[31m-        let result = manager.execute(|| async { Ok::<i32, AgentMemError>(42) }).await;
(B[m[32m+
(B[m[32m+        let result = manager
(B[m[32m+            .execute(|| async { Ok::<i32, AgentMemError>(42) })
(B[m[32m+            .await;
(B[m         assert!(result.is_ok());
         assert_eq!(result.unwrap(), 42);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:324:
         let rate_limiter = RateLimiter::new(100); // Higher rate to avoid timeout
 
         let start = Instant::now();
[31m-        for _ in 0..3 { // Fewer requests
(B[m[32m+        for _ in 0..3 {
(B[m[32m+            // Fewer requests
(B[m             rate_limiter.acquire().await.unwrap();
         }
         let elapsed = start.elapsed();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:336:
     #[tokio::test]
     async fn test_circuit_breaker() {
         let circuit_breaker = CircuitBreaker::new(3, Duration::from_secs(1));
[31m-        
(B[m[32m+
(B[m         // Record failures to trip the circuit breaker
         for _ in 0..3 {
             circuit_breaker.record_failure().await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/concurrency.rs:343:
         }
[31m-        
(B[m[32m+
(B[m         // Circuit breaker should be open
         assert!(!circuit_breaker.can_execute().await);
[31m-        
(B[m[32m+
(B[m         // Record success to close it
         circuit_breaker.record_success().await;
         assert!(circuit_breaker.can_execute().await);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/lib.rs:1:
 //! AgentMem Performance Optimization Module
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides performance optimization components including:
 //! - Async batch processing
 //! - Memory pools and object pools
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/lib.rs:9:
 
 pub mod batch;
 pub mod cache;
[31m-pub mod pool;
(B[m[31m-pub mod metrics;
(B[m pub mod concurrency;
[32m+pub mod metrics;
(B[m[32m+pub mod pool;
(B[m pub mod query;
 
 // Re-export main types
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/lib.rs:18:
[31m-pub use batch::{BatchProcessor, BatchConfig, BatchResult};
(B[m[31m-pub use cache::{CacheManager, CacheConfig, CacheStats};
(B[m[31m-pub use pool::{ObjectPool, MemoryPool, PoolConfig};
(B[m[31m-pub use metrics::{PerformanceMetrics, MetricsCollector};
(B[m[31m-pub use concurrency::{ConcurrencyManager, ConcurrencyConfig};
(B[m[31m-pub use query::{QueryOptimizer, QueryPlan, OptimizationHint};
(B[m[32m+pub use batch::{BatchConfig, BatchProcessor, BatchResult};
(B[m[32m+pub use cache::{CacheConfig, CacheManager, CacheStats};
(B[m[32m+pub use concurrency::{ConcurrencyConfig, ConcurrencyManager};
(B[m[32m+pub use metrics::{MetricsCollector, PerformanceMetrics};
(B[m[32m+pub use pool::{MemoryPool, ObjectPool, PoolConfig};
(B[m[32m+pub use query::{OptimizationHint, QueryOptimizer, QueryPlan};
(B[m 
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use std::sync::Arc;
 use tokio::sync::RwLock;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/lib.rs:161:
     pub memory: pool::MemoryStats,
     pub concurrency: concurrency::ConcurrencyStats,
 }
[31m-
(B[m[31m-
(B[m 
 #[cfg(test)]
 mod tests {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/metrics.rs:1:
 //! Performance metrics collection and monitoring
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides comprehensive metrics collection for monitoring
 //! AgentMem performance and identifying bottlenecks.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/metrics.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::sync::Arc;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/metrics.rs:74:
 
         let mut metrics = self.metrics.write().await;
         metrics.request_count += 1;
[31m-        
(B[m[32m+
(B[m         if !success {
             metrics.error_count += 1;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/metrics.rs:81:
 
         // Update average response time
         let duration_ms = duration.as_millis() as f64;
[31m-        metrics.average_response_time_ms = 
(B[m[31m-            (metrics.average_response_time_ms * (metrics.request_count - 1) as f64 + duration_ms) 
(B[m[31m-            / metrics.request_count as f64;
(B[m[32m+        metrics.average_response_time_ms =
(B[m[32m+            (metrics.average_response_time_ms * (metrics.request_count - 1) as f64 + duration_ms)
(B[m[32m+                / metrics.request_count as f64;
(B[m 
         // Update throughput
         let elapsed_seconds = self.start_time.elapsed().as_secs_f64();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/metrics.rs:94:
         #[cfg(feature = "metrics")]
         {
             // Simplified metrics implementation
[31m-            debug!("Request recorded: duration={}ms, success={}", duration_ms, success);
(B[m[32m+            debug!(
(B[m[32m+                "Request recorded: duration={}ms, success={}",
(B[m[32m+                duration_ms, success
(B[m[32m+            );
(B[m         }
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/metrics.rs:226:
     #[tokio::test]
     async fn test_record_request() {
         let collector = MetricsCollector::new(true).unwrap();
[31m-        collector.record_request(Duration::from_millis(100), true).await;
(B[m[31m-        
(B[m[32m+        collector
(B[m[32m+            .record_request(Duration::from_millis(100), true)
(B[m[32m+            .await;
(B[m[32m+
(B[m         let metrics = collector.get_metrics().await.unwrap();
         assert_eq!(metrics.request_count, 1);
         assert_eq!(metrics.error_count, 0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/metrics.rs:236:
     #[tokio::test]
     async fn test_record_error() {
         let collector = MetricsCollector::new(true).unwrap();
[31m-        collector.record_request(Duration::from_millis(100), false).await;
(B[m[31m-        
(B[m[32m+        collector
(B[m[32m+            .record_request(Duration::from_millis(100), false)
(B[m[32m+            .await;
(B[m[32m+
(B[m         let metrics = collector.get_metrics().await.unwrap();
         assert_eq!(metrics.request_count, 1);
         assert_eq!(metrics.error_count, 1);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/metrics.rs:247:
     async fn test_custom_metrics() {
         let collector = MetricsCollector::new(true).unwrap();
         collector.record_custom_metric("test_metric", 42.0).await;
[31m-        
(B[m[32m+
(B[m         let metrics = collector.get_metrics().await.unwrap();
         assert_eq!(metrics.custom_metrics.get("test_metric"), Some(&42.0));
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/metrics.rs:256:
     async fn test_metrics_timer() {
         let collector = Arc::new(MetricsCollector::new(true).unwrap());
         let timer = MetricsTimer::start(Arc::clone(&collector));
[31m-        
(B[m[32m+
(B[m         tokio::time::sleep(Duration::from_millis(10)).await;
         timer.finish(true).await;
[31m-        
(B[m[32m+
(B[m         let metrics = collector.get_metrics().await.unwrap();
         assert_eq!(metrics.request_count, 1);
         assert!(metrics.average_response_time_ms >= 10.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:1:
 //! Object and memory pools for efficient resource management
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides object pooling and memory pooling capabilities
 //! to reduce allocation overhead and improve performance.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use bytes::{Bytes, BytesMut};
 use crossbeam::queue::SegQueue;
 use parking_lot::{Mutex, RwLock};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:42:
             max_size: 1000,
             min_size: 10,
             enable_stats: true,
[31m-            cleanup_interval_seconds: 300, // 5 minutes
(B[m[31m-            object_lifetime_seconds: 3600, // 1 hour
(B[m[31m-            memory_block_size: 4096, // 4KB blocks
(B[m[32m+            cleanup_interval_seconds: 300,           // 5 minutes
(B[m[32m+            object_lifetime_seconds: 3600,           // 1 hour
(B[m[32m+            memory_block_size: 4096,                 // 4KB blocks
(B[m             max_memory_pool_size: 100 * 1024 * 1024, // 100MB
         }
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:54:
 pub trait Poolable: Send + Sync + 'static {
     /// Reset the object to its initial state
     fn reset(&mut self);
[31m-    
(B[m[32m+
(B[m     /// Check if the object is valid for reuse
     fn is_valid(&self) -> bool {
         true
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:61:
     }
[31m-    
(B[m[32m+
(B[m     /// Get the size of the object in bytes
[31m-    fn size(&self) -> usize where Self: Sized {
(B[m[32m+    fn size(&self) -> usize
(B[m[32m+    where
(B[m[32m+        Self: Sized,
(B[m[32m+    {
(B[m         std::mem::size_of::<Self>()
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:131:
             borrowed_count: AtomicUsize::new(0),
         };
 
[31m-        info!("Object pool created with max size: {}", object_pool.config.max_size);
(B[m[32m+        info!(
(B[m[32m+            "Object pool created with max size: {}",
(B[m[32m+            object_pool.config.max_size
(B[m[32m+        );
(B[m         Ok(object_pool)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:140:
         // Try to get from pool first
         while let Some(boxed_obj) = self.pool.pop() {
             if let Ok(mut pooled_obj) = boxed_obj.downcast::<PooledObject<T>>() {
[31m-                if pooled_obj.object.is_valid() && !pooled_obj.is_expired(self.config.object_lifetime_seconds) {
(B[m[32m+                if pooled_obj.object.is_valid()
(B[m[32m+                    && !pooled_obj.is_expired(self.config.object_lifetime_seconds)
(B[m[32m+                {
(B[m                     pooled_obj.object.reset();
                     self.borrowed_count.fetch_add(1, Ordering::Relaxed);
[31m-                    
(B[m[32m+
(B[m                     return Ok(PooledObjectGuard {
                         object: Some(pooled_obj),
                         pool: Arc::clone(&self.pool),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:157:
         // Create new object if pool is empty or objects are invalid
         let new_object = T::default();
         let pooled_obj = Box::new(PooledObject::new(new_object));
[31m-        
(B[m[32m+
(B[m         self.created_count.fetch_add(1, Ordering::Relaxed);
         self.borrowed_count.fetch_add(1, Ordering::Relaxed);
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:176:
         stats.available_objects = self.pool.len();
         stats.borrowed_objects = self.borrowed_count.load(Ordering::Relaxed);
         stats.created_objects = self.created_count.load(Ordering::Relaxed);
[31m-        
(B[m[32m+
(B[m         Ok(stats)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:183:
     /// Clear the pool
     pub fn clear(&self) -> Result<()> {
         while self.pool.pop().is_some() {}
[31m-        
(B[m[32m+
(B[m         let mut stats = self.stats.write();
         stats.total_objects = 0;
         stats.available_objects = 0;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:190:
[31m-        
(B[m[32m+
(B[m         info!("Object pool cleared");
         Ok(())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:218:
         if let Some(mut pooled_obj) = self.object.take() {
             // Reset the object before returning to pool
             pooled_obj.object.reset();
[31m-            
(B[m[32m+
(B[m             // Return to pool if it's still valid
             if pooled_obj.object.is_valid() {
                 self.pool.push(pooled_obj);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:225:
[31m-                
(B[m[32m+
(B[m                 let mut stats = self.stats.write();
                 stats.recycled_objects += 1;
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:229:
[31m-            
(B[m[32m+
(B[m             self.borrowed_count.fetch_sub(1, Ordering::Relaxed);
         }
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:279:
             total_allocated: AtomicUsize::new(0),
         };
 
[31m-        info!("Memory pool created with max size: {} bytes", memory_pool.config.max_memory_pool_size);
(B[m[32m+        info!(
(B[m[32m+            "Memory pool created with max size: {} bytes",
(B[m[32m+            memory_pool.config.max_memory_pool_size
(B[m[32m+        );
(B[m         Ok(memory_pool)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:293:
             self.get_or_create_buffer(&self.large_blocks, size)
         };
 
[31m-        self.total_allocated.fetch_add(buffer.capacity(), Ordering::Relaxed);
(B[m[31m-        
(B[m[32m+        self.total_allocated
(B[m[32m+            .fetch_add(buffer.capacity(), Ordering::Relaxed);
(B[m[32m+
(B[m         let mut stats = self.stats.write();
         stats.allocation_count += 1;
         stats.total_allocated = self.total_allocated.load(Ordering::Relaxed);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:313:
         stats.medium_blocks_count = self.medium_blocks.len();
         stats.large_blocks_count = self.large_blocks.len();
         stats.total_allocated = self.total_allocated.load(Ordering::Relaxed);
[31m-        
(B[m[32m+
(B[m         Ok(stats)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:324:
                 return buffer;
             }
         }
[31m-        
(B[m[32m+
(B[m         BytesMut::with_capacity(capacity)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:331:
     fn return_buffer(&self, mut buffer: BytesMut) {
         buffer.clear();
[31m-        
(B[m[32m+
(B[m         let capacity = buffer.capacity();
         if capacity <= 1024 {
             self.small_blocks.push(buffer);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:375:
     fn drop(&mut self) {
         let buffer = std::mem::replace(&mut self.buffer, BytesMut::new());
         self.pool.return_buffer(buffer);
[31m-        self.pool.total_allocated.fetch_sub(self.size, Ordering::Relaxed);
(B[m[32m+        self.pool
(B[m[32m+            .total_allocated
(B[m[32m+            .fetch_sub(self.size, Ordering::Relaxed);
(B[m     }
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:445:
     fn test_object_pool_get() {
         let config = PoolConfig::default();
         let pool = ObjectPool::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let guard = pool.get::<StringBuffer>();
         assert!(guard.is_ok());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:461:
     fn test_memory_pool_allocate() {
         let config = PoolConfig::default();
         let pool = MemoryPool::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let block = pool.allocate(1024);
         assert!(block.is_ok());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/pool.rs:470:
     fn test_pool_stats() {
         let config = PoolConfig::default();
         let pool = ObjectPool::new(config).unwrap();
[31m-        
(B[m[32m+
(B[m         let stats = pool.get_stats().unwrap();
         assert_eq!(stats.created_objects, 0);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:1:
 //! Query optimization and execution planning
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides intelligent query optimization capabilities
 //! to improve search performance and reduce resource usage.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::sync::Arc;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:120:
 
         // Create optimized plan
         let plan = self.create_optimized_plan(query).await?;
[31m-        
(B[m[32m+
(B[m         // Cache the plan
[31m-        self.cache_plan(query_hash, plan.clone(), start_time.elapsed()).await;
(B[m[31m-        
(B[m[32m+        self.cache_plan(query_hash, plan.clone(), start_time.elapsed())
(B[m[32m+            .await;
(B[m[32m+
(B[m         // Update statistics
         self.update_optimization_stats(start_time.elapsed()).await;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:137:
         Fut: std::future::Future<Output = Result<T>>,
     {
         let start_time = Instant::now();
[31m-        
(B[m[31m-        debug!("Executing query plan {} with {} steps", 
(B[m[31m-               plan.query_id, plan.execution_steps.len());
(B[m 
[32m+        debug!(
(B[m[32m+            "Executing query plan {} with {} steps",
(B[m[32m+            plan.query_id,
(B[m[32m+            plan.execution_steps.len()
(B[m[32m+        );
(B[m[32m+
(B[m         let result = executor(plan).await;
[31m-        
(B[m[32m+
(B[m         let execution_time = start_time.elapsed();
[31m-        self.update_execution_stats(&plan.query_id, execution_time, result.is_ok()).await;
(B[m[32m+        self.update_execution_stats(&plan.query_id, execution_time, result.is_ok())
(B[m[32m+            .await;
(B[m 
         result
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:180:
 
         // Analyze query characteristics
         let query_complexity = self.analyze_query_complexity(query);
[31m-        
(B[m[32m+
(B[m         // Vector search step
         if query.has_vector_search() {
             let vector_step = ExecutionStep {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:209:
                 estimated_time_ms: self.estimate_filter_time(query),
                 estimated_memory_mb: 10.0,
                 parallelizable: false,
[31m-                dependencies: if query.has_vector_search() { 
(B[m[31m-                    vec!["vector_search".to_string()] 
(B[m[31m-                } else { 
(B[m[31m-                    vec![] 
(B[m[32m+                dependencies: if query.has_vector_search() {
(B[m[32m+                    vec!["vector_search".to_string()]
(B[m[32m+                } else {
(B[m[32m+                    vec![]
(B[m                 },
             };
             estimated_cost += filter_step.estimated_time_ms;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:285:
 
     fn analyze_query_complexity(&self, query: &QueryRequest) -> f64 {
         let mut complexity = 0.0;
[31m-        
(B[m[32m+
(B[m         if query.has_vector_search() {
             complexity += 0.3;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:298:
         if query.has_aggregations() {
             complexity += 0.4;
         }
[31m-        
(B[m[32m+
(B[m         complexity.min(1.0)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:307:
         let base_time = 20.0;
         let limit_factor = (query.result_limit() as f64).log10() * 5.0;
         let dimension_factor = query.vector_dimensions().unwrap_or(1536) as f64 / 1536.0;
[31m-        
(B[m[32m+
(B[m         base_time + limit_factor + dimension_factor * 10.0
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:315:
         // Estimate memory usage in MB
         let base_memory = 10.0;
         let result_memory = query.result_limit() as f64 * 0.001; // 1KB per result
[31m-        let vector_memory = query.vector_dimensions().unwrap_or(1536) as f64 * 4.0 / 1024.0 / 1024.0; // 4 bytes per dimension
(B[m[31m-        
(B[m[32m+        let vector_memory =
(B[m[32m+            query.vector_dimensions().unwrap_or(1536) as f64 * 4.0 / 1024.0 / 1024.0; // 4 bytes per dimension
(B[m[32m+
(B[m         base_memory + result_memory + vector_memory
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:345:
             hit_count: 0,
             average_execution_time_ms: 0.0,
         };
[31m-        
(B[m[32m+
(B[m         let mut cache = self.query_cache.write().await;
         cache.insert(query_hash, cached_plan);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:360:
         let mut stats = self.statistics.write().await;
         stats.optimized_queries += 1;
         stats.total_queries += 1;
[31m-        
(B[m[32m+
(B[m         let optimization_time_ms = optimization_time.as_millis() as f64;
[31m-        stats.average_optimization_time_ms = 
(B[m[31m-            (stats.average_optimization_time_ms * (stats.optimized_queries - 1) as f64 + optimization_time_ms) 
(B[m[32m+        stats.average_optimization_time_ms = (stats.average_optimization_time_ms
(B[m[32m+            * (stats.optimized_queries - 1) as f64
(B[m[32m+            + optimization_time_ms)
(B[m             / stats.optimized_queries as f64;
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:370:
[31m-    async fn update_execution_stats(&self, query_id: &str, execution_time: Duration, success: bool) {
(B[m[32m+    async fn update_execution_stats(
(B[m[32m+        &self,
(B[m[32m+        query_id: &str,
(B[m[32m+        execution_time: Duration,
(B[m[32m+        success: bool,
(B[m[32m+    ) {
(B[m         // Update execution statistics for the query plan
[31m-        debug!("Query {} executed in {:?}, success: {}", query_id, execution_time, success);
(B[m[32m+        debug!(
(B[m[32m+            "Query {} executed in {:?}, success: {}",
(B[m[32m+            query_id, execution_time, success
(B[m[32m+        );
(B[m     }
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:410:
 
     pub fn is_frequent(&self) -> bool {
         // Simplified frequency detection
[31m-        self.metadata.get("frequency").map_or(false, |f| f == "high")
(B[m[32m+        self.metadata
(B[m[32m+            .get("frequency")
(B[m[32m+            .map_or(false, |f| f == "high")
(B[m     }
 
     pub fn is_expensive(&self) -> bool {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:442:
     #[tokio::test]
     async fn test_query_optimization() {
         let optimizer = QueryOptimizer::new(true).unwrap();
[31m-        
(B[m[32m+
(B[m         let query = QueryRequest {
             vector: Some(vec![0.1; 1536]),
             filters: HashMap::new(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:450:
             aggregations: vec![],
             metadata: HashMap::new(),
         };
[31m-        
(B[m[32m+
(B[m         let plan = optimizer.optimize_query(&query).await;
         assert!(plan.is_ok());
[31m-        
(B[m[32m+
(B[m         let plan = plan.unwrap();
         assert!(!plan.execution_steps.is_empty());
         assert!(plan.estimated_cost > 0.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:462:
     #[tokio::test]
     async fn test_query_complexity_analysis() {
         let optimizer = QueryOptimizer::new(true).unwrap();
[31m-        
(B[m[32m+
(B[m         let simple_query = QueryRequest {
             vector: Some(vec![0.1; 100]),
             filters: HashMap::new(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:470:
             aggregations: vec![],
             metadata: HashMap::new(),
         };
[31m-        
(B[m[32m+
(B[m         let complexity = optimizer.analyze_query_complexity(&simple_query);
         assert!(complexity > 0.0 && complexity <= 1.0);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-performance/src/query.rs:478:
     #[tokio::test]
     async fn test_optimizer_statistics() {
         let optimizer = QueryOptimizer::new(true).unwrap();
[31m-        
(B[m[32m+
(B[m         let stats = optimizer.get_statistics().await.unwrap();
         assert_eq!(stats.total_queries, 0);
         assert_eq!(stats.cache_hits, 0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/auth.rs:1:
 //! Authentication and authorization
 
 use crate::error::{ServerError, ServerResult};
[32m+use chrono::{Duration, Utc};
(B[m use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
 use serde::{Deserialize, Serialize};
[31m-use chrono::{Duration, Utc};
(B[m 
 /// JWT claims
 #[derive(Debug, Serialize, Deserialize)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/auth.rs:34:
             decoding_key: DecodingKey::from_secret(secret.as_ref()),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Generate a JWT token
     pub fn generate_token(
         &self,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/auth.rs:44:
     ) -> ServerResult<String> {
         let now = Utc::now();
         let exp = now + Duration::hours(24); // Token expires in 24 hours
[31m-        
(B[m[32m+
(B[m         let claims = Claims {
             sub: user_id.to_string(),
             org_id,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/auth.rs:52:
             exp: exp.timestamp(),
             iat: now.timestamp(),
         };
[31m-        
(B[m[32m+
(B[m         encode(&Header::default(), &claims, &self.encoding_key)
             .map_err(|e| ServerError::Unauthorized(format!("Token generation failed: {}", e)))
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/auth.rs:59:
[31m-    
(B[m[32m+
(B[m     /// Validate a JWT token
     pub fn validate_token(&self, token: &str) -> ServerResult<Claims> {
         decode::<Claims>(token, &self.decoding_key, &Validation::default())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/auth.rs:63:
             .map(|data| data.claims)
             .map_err(|e| ServerError::Unauthorized(format!("Token validation failed: {}", e)))
     }
[31m-    
(B[m[32m+
(B[m     /// Extract token from Authorization header
     pub fn extract_token_from_header(auth_header: &str) -> ServerResult<&str> {
         if auth_header.starts_with("Bearer ") {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/auth.rs:70:
             Ok(&auth_header[7..])
         } else {
[31m-            Err(ServerError::Unauthorized("Invalid authorization header format".to_string()))
(B[m[32m+            Err(ServerError::Unauthorized(
(B[m[32m+                "Invalid authorization header format".to_string(),
(B[m[32m+            ))
(B[m         }
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/auth.rs:99:
     #[test]
     fn test_token_generation_and_validation() {
         let auth_service = AuthService::new("test-secret-key-that-is-long-enough");
[31m-        
(B[m[32m+
(B[m         let token = auth_service
             .generate_token("user123", Some("org456".to_string()), None)
             .unwrap();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/auth.rs:106:
[31m-        
(B[m[32m+
(B[m         let claims = auth_service.validate_token(&token).unwrap();
         assert_eq!(claims.sub, "user123");
         assert_eq!(claims.org_id, Some("org456".to_string()));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/auth.rs:110:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_extract_token_from_header() {
         let header = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9";
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/auth.rs:115:
         let token = AuthService::extract_token_from_header(header).unwrap();
         assert_eq!(token, "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9");
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_invalid_header_format() {
         let header = "Invalid header";
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/config.rs:41:
                 .unwrap_or_else(|_| "8080".to_string())
                 .parse()
                 .unwrap_or(8080),
[31m-            host: env::var("AGENT_MEM_HOST")
(B[m[31m-                .unwrap_or_else(|_| "0.0.0.0".to_string()),
(B[m[32m+            host: env::var("AGENT_MEM_HOST").unwrap_or_else(|_| "0.0.0.0".to_string()),
(B[m             enable_cors: env::var("AGENT_MEM_ENABLE_CORS")
                 .unwrap_or_else(|_| "true".to_string())
                 .parse()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/config.rs:73:
                 .unwrap_or_else(|_| "true".to_string())
                 .parse()
                 .unwrap_or(true),
[31m-            log_level: env::var("AGENT_MEM_LOG_LEVEL")
(B[m[31m-                .unwrap_or_else(|_| "info".to_string()),
(B[m[32m+            log_level: env::var("AGENT_MEM_LOG_LEVEL").unwrap_or_else(|_| "info".to_string()),
(B[m             multi_tenant: env::var("AGENT_MEM_MULTI_TENANT")
                 .unwrap_or_else(|_| "false".to_string())
                 .parse()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/config.rs:92:
     pub fn from_env() -> Self {
         Self::default()
     }
[31m-    
(B[m[32m+
(B[m     /// Validate configuration
     pub fn validate(&self) -> Result<(), String> {
         if self.port == 0 {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/config.rs:99:
             return Err("Port cannot be 0".to_string());
         }
[31m-        
(B[m[32m+
(B[m         if self.jwt_secret.len() < 32 {
             return Err("JWT secret must be at least 32 characters".to_string());
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/config.rs:105:
[31m-        
(B[m[32m+
(B[m         if self.request_timeout == 0 {
             return Err("Request timeout must be greater than 0".to_string());
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/config.rs:109:
[31m-        
(B[m[32m+
(B[m         if self.max_body_size == 0 {
             return Err("Max body size must be greater than 0".to_string());
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/config.rs:113:
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/config.rs:126:
         assert_eq!(config.host, "0.0.0.0");
         assert!(config.enable_cors);
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_config_validation() {
         let mut config = ServerConfig::default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/config.rs:133:
         assert!(config.validate().is_ok());
[31m-        
(B[m[32m+
(B[m         config.port = 0;
         assert!(config.validate().is_err());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/error.rs:14:
 pub enum ServerError {
     #[error("Memory operation failed: {0}")]
     MemoryError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Resource not found: {0}")]
     NotFound(String),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid request: {0}")]
     BadRequest(String),
[31m-    
(B[m[32m+
(B[m     #[error("Authentication failed: {0}")]
     Unauthorized(String),
[31m-    
(B[m[32m+
(B[m     #[error("Access forbidden: {0}")]
     Forbidden(String),
[31m-    
(B[m[32m+
(B[m     #[error("Validation failed: {0}")]
     ValidationError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Server binding failed: {0}")]
     BindError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Server error: {0}")]
     ServerError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Configuration error: {0}")]
     ConfigError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Telemetry setup failed: {0}")]
     TelemetryError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Internal server error: {0}")]
     Internal(String),
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/error.rs:52:
 impl IntoResponse for ServerError {
     fn into_response(self) -> Response {
         let (status, code, message) = match self {
[31m-            ServerError::MemoryError(msg) => (StatusCode::INTERNAL_SERVER_ERROR, "MEMORY_ERROR", msg),
(B[m[32m+            ServerError::MemoryError(msg) => {
(B[m[32m+                (StatusCode::INTERNAL_SERVER_ERROR, "MEMORY_ERROR", msg)
(B[m[32m+            }
(B[m             ServerError::NotFound(msg) => (StatusCode::NOT_FOUND, "NOT_FOUND", msg),
             ServerError::BadRequest(msg) => (StatusCode::BAD_REQUEST, "BAD_REQUEST", msg),
             ServerError::Unauthorized(msg) => (StatusCode::UNAUTHORIZED, "UNAUTHORIZED", msg),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/error.rs:59:
             ServerError::Forbidden(msg) => (StatusCode::FORBIDDEN, "FORBIDDEN", msg),
             ServerError::ValidationError(msg) => (StatusCode::BAD_REQUEST, "VALIDATION_ERROR", msg),
             ServerError::BindError(msg) => (StatusCode::INTERNAL_SERVER_ERROR, "BIND_ERROR", msg),
[31m-            ServerError::ServerError(msg) => (StatusCode::INTERNAL_SERVER_ERROR, "SERVER_ERROR", msg),
(B[m[31m-            ServerError::ConfigError(msg) => (StatusCode::INTERNAL_SERVER_ERROR, "CONFIG_ERROR", msg),
(B[m[31m-            ServerError::TelemetryError(msg) => (StatusCode::INTERNAL_SERVER_ERROR, "TELEMETRY_ERROR", msg),
(B[m[31m-            ServerError::Internal(msg) => (StatusCode::INTERNAL_SERVER_ERROR, "INTERNAL_ERROR", msg),
(B[m[32m+            ServerError::ServerError(msg) => {
(B[m[32m+                (StatusCode::INTERNAL_SERVER_ERROR, "SERVER_ERROR", msg)
(B[m[32m+            }
(B[m[32m+            ServerError::ConfigError(msg) => {
(B[m[32m+                (StatusCode::INTERNAL_SERVER_ERROR, "CONFIG_ERROR", msg)
(B[m[32m+            }
(B[m[32m+            ServerError::TelemetryError(msg) => {
(B[m[32m+                (StatusCode::INTERNAL_SERVER_ERROR, "TELEMETRY_ERROR", msg)
(B[m[32m+            }
(B[m[32m+            ServerError::Internal(msg) => {
(B[m[32m+                (StatusCode::INTERNAL_SERVER_ERROR, "INTERNAL_ERROR", msg)
(B[m[32m+            }
(B[m         };
[31m-        
(B[m[32m+
(B[m         let error_response = ErrorResponse {
             code: code.to_string(),
             message,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/error.rs:71:
             details: None,
             timestamp: Utc::now(),
         };
[31m-        
(B[m[32m+
(B[m         (status, Json(error_response)).into_response()
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/error.rs:103:
     fn test_error_conversion() {
         let error = ServerError::NotFound("Test not found".to_string());
         let response = error.into_response();
[31m-        
(B[m[32m+
(B[m         // We can't easily test the exact response content here,
         // but we can verify the error type conversion works
         assert!(matches!(response.status(), StatusCode::NOT_FOUND));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/error.rs:110:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_memory_error_conversion() {
         let memory_error = agent_mem_traits::AgentMemError::memory_error("test");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/lib.rs:1:
 //! AgentMem REST API Server
[31m-//! 
(B[m[32m+//!
(B[m //! Enterprise-grade REST API server for AgentMem memory management platform.
 //! Provides HTTP endpoints for all memory operations with authentication,
 //! multi-tenancy, and comprehensive monitoring.
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/lib.rs:6:
 
[31m-pub mod server;
(B[m[31m-pub mod routes;
(B[m[31m-pub mod middleware;
(B[m pub mod auth;
[31m-pub mod models;
(B[m[31m-pub mod error;
(B[m pub mod config;
[32m+pub mod error;
(B[m[32m+pub mod middleware;
(B[m[32m+pub mod models;
(B[m[32m+pub mod routes;
(B[m[32m+pub mod server;
(B[m pub mod telemetry;
 
[31m-pub use server::MemoryServer;
(B[m pub use config::ServerConfig;
 pub use error::{ServerError, ServerResult};
[32m+pub use server::MemoryServer;
(B[m 
 /// Re-export commonly used types
 pub use models::{
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/lib.rs:22:
[31m-    MemoryRequest, MemoryResponse, SearchRequest, SearchResponse,
(B[m[31m-    BatchRequest, BatchResponse, HealthResponse, MetricsResponse
(B[m[32m+    BatchRequest, BatchResponse, HealthResponse, MemoryRequest, MemoryResponse, MetricsResponse,
(B[m[32m+    SearchRequest, SearchResponse,
(B[m };
 
 #[cfg(test)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/middleware.rs:1:
 //! Middleware for the server
 
[31m-use axum::{
(B[m[31m-    extract::Request,
(B[m[31m-    middleware::Next,
(B[m[31m-    response::Response,
(B[m[31m-};
(B[m[32m+use axum::{extract::Request, middleware::Next, response::Response};
(B[m // Middleware functionality is now handled directly in routes/mod.rs
 // This module is kept for future middleware implementations
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/middleware.rs:11:
 /// Request logging middleware
[31m-pub async fn request_logging_middleware(
(B[m[31m-    request: Request,
(B[m[31m-    next: Next,
(B[m[31m-) -> Response {
(B[m[32m+pub async fn request_logging_middleware(request: Request, next: Next) -> Response {
(B[m     let method = request.method().clone();
     let uri = request.uri().clone();
[31m-    
(B[m[32m+
(B[m     tracing::info!("Processing {} {}", method, uri);
[31m-    
(B[m[32m+
(B[m     let start = std::time::Instant::now();
     let response = next.run(request).await;
     let duration = start.elapsed();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/middleware.rs:24:
[31m-    
(B[m[32m+
(B[m     tracing::info!(
         "Completed {} {} - Status: {} - Duration: {:?}",
         method,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/middleware.rs:29:
         response.status(),
         duration
     );
[31m-    
(B[m[32m+
(B[m     response
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/middleware.rs:36:
 /// Authentication middleware (placeholder)
[31m-pub async fn auth_middleware(
(B[m[31m-    request: Request,
(B[m[31m-    next: Next,
(B[m[31m-) -> Response {
(B[m[32m+pub async fn auth_middleware(request: Request, next: Next) -> Response {
(B[m     // TODO: Implement JWT authentication
     // For now, just pass through
     next.run(request).await
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/middleware.rs:44:
 }
 
 /// Rate limiting middleware (placeholder)
[31m-pub async fn rate_limit_middleware(
(B[m[31m-    request: Request,
(B[m[31m-    next: Next,
(B[m[31m-) -> Response {
(B[m[32m+pub async fn rate_limit_middleware(request: Request, next: Next) -> Response {
(B[m     // TODO: Implement rate limiting
     // For now, just pass through
     next.run(request).await
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:13:
     /// Agent ID
     #[validate(length(min = 1, max = 255))]
     pub agent_id: String,
[31m-    
(B[m[32m+
(B[m     /// User ID (optional)
     #[validate(length(max = 255))]
     pub user_id: Option<String>,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:20:
[31m-    
(B[m[32m+
(B[m     /// Memory content
     #[validate(length(min = 1, max = 10000))]
     pub content: String,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:24:
[31m-    
(B[m[32m+
(B[m     /// Memory type
     pub memory_type: Option<MemoryType>,
[31m-    
(B[m[32m+
(B[m     /// Importance score (0.0 to 1.0)
     #[validate(range(min = 0.0, max = 1.0))]
     pub importance: Option<f32>,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:31:
[31m-    
(B[m[32m+
(B[m     /// Additional metadata
     pub metadata: Option<HashMap<String, String>>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:39:
     /// New content (optional)
     #[validate(length(max = 10000))]
     pub content: Option<String>,
[31m-    
(B[m[32m+
(B[m     /// New importance score (optional)
     #[validate(range(min = 0.0, max = 1.0))]
     pub importance: Option<f32>,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:50:
 pub struct MemoryResponse {
     /// Memory ID
     pub id: String,
[31m-    
(B[m[32m+
(B[m     /// Response message
     pub message: String,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:61:
     /// Search query
     #[validate(length(min = 1, max = 1000))]
     pub query: String,
[31m-    
(B[m[32m+
(B[m     /// Agent ID (optional)
     #[validate(length(max = 255))]
     pub agent_id: Option<String>,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:68:
[31m-    
(B[m[32m+
(B[m     /// User ID (optional)
     #[validate(length(max = 255))]
     pub user_id: Option<String>,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:72:
[31m-    
(B[m[32m+
(B[m     /// Memory type filter (optional)
     pub memory_type: Option<MemoryType>,
[31m-    
(B[m[32m+
(B[m     /// Maximum number of results
     #[validate(range(min = 1, max = 100))]
     pub limit: Option<usize>,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:79:
[31m-    
(B[m[32m+
(B[m     /// Similarity threshold
     #[validate(range(min = 0.0, max = 1.0))]
     pub threshold: Option<f32>,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:87:
 pub struct SearchResponse {
     /// Search results
     pub results: Vec<serde_json::Value>,
[31m-    
(B[m[32m+
(B[m     /// Total number of results
     pub total: usize,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:105:
 pub struct BatchResponse {
     /// Number of successful operations
     pub successful: usize,
[31m-    
(B[m[32m+
(B[m     /// Number of failed operations
     pub failed: usize,
[31m-    
(B[m[32m+
(B[m     /// Results from successful operations
     pub results: Vec<String>,
[31m-    
(B[m[32m+
(B[m     /// Error messages from failed operations
     pub errors: Vec<String>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:121:
 pub struct HealthResponse {
     /// Overall health status
     pub status: String,
[31m-    
(B[m[32m+
(B[m     /// Timestamp of the health check
     pub timestamp: DateTime<Utc>,
[31m-    
(B[m[32m+
(B[m     /// Service version
     pub version: String,
[31m-    
(B[m[32m+
(B[m     /// Individual component health checks
     pub checks: HashMap<String, String>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:137:
 pub struct MetricsResponse {
     /// Timestamp of metrics collection
     pub timestamp: DateTime<Utc>,
[31m-    
(B[m[32m+
(B[m     /// Collected metrics
     pub metrics: HashMap<String, f64>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:147:
 pub struct ErrorResponse {
     /// Error code
     pub code: String,
[31m-    
(B[m[32m+
(B[m     /// Error message
     pub message: String,
[31m-    
(B[m[32m+
(B[m     /// Additional error details
     pub details: Option<serde_json::Value>,
[31m-    
(B[m[32m+
(B[m     /// Timestamp of the error
     pub timestamp: DateTime<Utc>,
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:172:
             importance: Some(0.8),
             metadata: None,
         };
[31m-        
(B[m[32m+
(B[m         assert!(request.validate().is_ok());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_memory_request_validation_fails() {
         let request = MemoryRequest {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:186:
             importance: Some(0.8),
             metadata: None,
         };
[31m-        
(B[m[32m+
(B[m         assert!(request.validate().is_err());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_search_request_validation() {
         let request = SearchRequest {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/models.rs:200:
             limit: Some(10),
             threshold: Some(0.7),
         };
[31m-        
(B[m[32m+
(B[m         assert!(request.validate().is_ok());
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/docs.rs:1:
 //! Documentation routes
 
[31m-use axum::{
(B[m[31m-    response::Html,
(B[m[31m-    http::StatusCode,
(B[m[31m-};
(B[m[32m+use axum::{http::StatusCode, response::Html};
(B[m 
 /// Serve OpenAPI documentation
 pub async fn serve_docs() -> Result<Html<String>, StatusCode> {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/docs.rs:30:
 </body>
 </html>
     "#;
[31m-    
(B[m[32m+
(B[m     Ok(Html(html.to_string()))
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/docs.rs:42:
     async fn test_serve_docs() {
         let result = serve_docs().await;
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let html = result.unwrap().0;
         assert!(html.contains("AgentMem API Documentation"));
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/health.rs:1:
 //! Health check routes
 
[31m-use crate::{
(B[m[31m-    error::ServerResult,
(B[m[31m-    models::HealthResponse,
(B[m[31m-};
(B[m[32m+use crate::{error::ServerResult, models::HealthResponse};
(B[m use agent_mem_core::MemoryManager;
[31m-use axum::{
(B[m[31m-    extract::Extension,
(B[m[31m-    response::Json,
(B[m[31m-};
(B[m[31m-use std::sync::Arc;
(B[m[32m+use axum::{extract::Extension, response::Json};
(B[m use chrono::Utc;
[32m+use std::sync::Arc;
(B[m use utoipa;
 
 /// Health check endpoint
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/health.rs:28:
 ) -> ServerResult<Json<HealthResponse>> {
     // Perform basic health checks
     let mut checks = std::collections::HashMap::new();
[31m-    
(B[m[32m+
(B[m     // Check memory manager
     checks.insert("memory_manager".to_string(), "healthy".to_string());
[31m-    
(B[m[32m+
(B[m     // Check database connectivity (if applicable)
     // This would be expanded based on actual storage backends
     checks.insert("storage".to_string(), "healthy".to_string());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/health.rs:38:
[31m-    
(B[m[32m+
(B[m     let response = HealthResponse {
         status: "healthy".to_string(),
         timestamp: Utc::now(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/health.rs:42:
         version: env!("CARGO_PKG_VERSION").to_string(),
         checks,
     };
[31m-    
(B[m[32m+
(B[m     Ok(Json(response))
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/health.rs:56:
         let memory_manager = Arc::new(MemoryManager::new());
         let result = health_check(Extension(memory_manager)).await;
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let response = result.unwrap().0;
         assert_eq!(response.status, "healthy");
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:3:
 use crate::{
     error::{ServerError, ServerResult},
     models::{
[31m-        MemoryRequest, MemoryResponse, SearchRequest, SearchResponse,
(B[m[31m-        BatchRequest, BatchResponse, UpdateMemoryRequest
(B[m[32m+        BatchRequest, BatchResponse, MemoryRequest, MemoryResponse, SearchRequest, SearchResponse,
(B[m[32m+        UpdateMemoryRequest,
(B[m     },
 };
 use agent_mem_core::MemoryManager;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:11:
 use agent_mem_core::MemoryType;
 use axum::{
[31m-    extract::{Path, Extension},
(B[m[32m+    extract::{Extension, Path},
(B[m     http::StatusCode,
     response::Json,
 };
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:17:
 use std::sync::Arc;
[31m-use tracing::{info, error};
(B[m[32m+use tracing::{error, info};
(B[m use utoipa;
 
 /// Add a new memory
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:34:
     Extension(memory_manager): Extension<Arc<MemoryManager>>,
     Json(request): Json<MemoryRequest>,
 ) -> ServerResult<(StatusCode, Json<MemoryResponse>)> {
[31m-    info!("Adding new memory for agent_id: {:?}, user_id: {:?}", 
(B[m[31m-          request.agent_id, request.user_id);
(B[m[31m-    
(B[m[32m+    info!(
(B[m[32m+        "Adding new memory for agent_id: {:?}, user_id: {:?}",
(B[m[32m+        request.agent_id, request.user_id
(B[m[32m+    );
(B[m[32m+
(B[m     let memory_type = request.memory_type.unwrap_or(MemoryType::Episodic);
     let importance = request.importance.unwrap_or(0.5);
[31m-    
(B[m[32m+
(B[m     let memory_id = memory_manager
         .add_memory(
             request.agent_id,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:54:
             error!("Failed to add memory: {}", e);
             ServerError::MemoryError(e.to_string())
         })?;
[31m-    
(B[m[32m+
(B[m     let response = MemoryResponse {
         id: memory_id,
         message: "Memory added successfully".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:61:
     };
[31m-    
(B[m[32m+
(B[m     Ok((StatusCode::CREATED, Json(response)))
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:82:
     Path(id): Path<String>,
 ) -> ServerResult<Json<serde_json::Value>> {
     info!("Getting memory with ID: {}", id);
[31m-    
(B[m[31m-    let memory = memory_manager
(B[m[31m-        .get_memory(&id)
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| {
(B[m[31m-            error!("Failed to get memory: {}", e);
(B[m[31m-            ServerError::MemoryError(e.to_string())
(B[m[31m-        })?;
(B[m[31m-    
(B[m[32m+
(B[m[32m+    let memory = memory_manager.get_memory(&id).await.map_err(|e| {
(B[m[32m+        error!("Failed to get memory: {}", e);
(B[m[32m+        ServerError::MemoryError(e.to_string())
(B[m[32m+    })?;
(B[m[32m+
(B[m     match memory {
         Some(mem) => {
             let response = serde_json::json!({
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:131:
     Json(request): Json<UpdateMemoryRequest>,
 ) -> ServerResult<Json<MemoryResponse>> {
     info!("Updating memory with ID: {}", id);
[31m-    
(B[m[32m+
(B[m     memory_manager
         .update_memory(&id, request.content, request.importance, None)
         .await
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:139:
             error!("Failed to update memory: {}", e);
             ServerError::MemoryError(e.to_string())
         })?;
[31m-    
(B[m[32m+
(B[m     let response = MemoryResponse {
         id,
         message: "Memory updated successfully".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:146:
     };
[31m-    
(B[m[32m+
(B[m     Ok(Json(response))
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:167:
     Path(id): Path<String>,
 ) -> ServerResult<Json<MemoryResponse>> {
     info!("Deleting memory with ID: {}", id);
[31m-    
(B[m[31m-    memory_manager
(B[m[31m-        .delete_memory(&id)
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| {
(B[m[31m-            error!("Failed to delete memory: {}", e);
(B[m[31m-            ServerError::MemoryError(e.to_string())
(B[m[31m-        })?;
(B[m[31m-    
(B[m[32m+
(B[m[32m+    memory_manager.delete_memory(&id).await.map_err(|e| {
(B[m[32m+        error!("Failed to delete memory: {}", e);
(B[m[32m+        ServerError::MemoryError(e.to_string())
(B[m[32m+    })?;
(B[m[32m+
(B[m     let response = MemoryResponse {
         id,
         message: "Memory deleted successfully".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:182:
     };
[31m-    
(B[m[32m+
(B[m     Ok(Json(response))
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:201:
     Json(request): Json<SearchRequest>,
 ) -> ServerResult<Json<SearchResponse>> {
     info!("Searching memories with query: {}", request.query);
[31m-    
(B[m[32m+
(B[m     let query = agent_mem_core::MemoryQuery {
         agent_id: request.agent_id.unwrap_or_default(),
         user_id: request.user_id,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:212:
         max_age_seconds: None,
         limit: request.limit.unwrap_or(10),
     };
[31m-    
(B[m[31m-    let results = memory_manager
(B[m[31m-        .search_memories(query)
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| {
(B[m[31m-            error!("Failed to search memories: {}", e);
(B[m[31m-            ServerError::MemoryError(e.to_string())
(B[m[31m-        })?;
(B[m[31m-    
(B[m[32m+
(B[m[32m+    let results = memory_manager.search_memories(query).await.map_err(|e| {
(B[m[32m+        error!("Failed to search memories: {}", e);
(B[m[32m+        ServerError::MemoryError(e.to_string())
(B[m[32m+    })?;
(B[m[32m+
(B[m     let total = results.len();
     let response = SearchResponse {
[31m-        results: results.into_iter().map(|r| serde_json::json!({
(B[m[31m-            "id": r.memory.id,
(B[m[31m-            "content": r.memory.content,
(B[m[31m-            "score": r.score,
(B[m[31m-            "agent_id": r.memory.agent_id,
(B[m[31m-            "user_id": r.memory.user_id,
(B[m[31m-            "memory_type": r.memory.memory_type,
(B[m[31m-            "importance": r.memory.importance,
(B[m[31m-            "created_at": r.memory.created_at,
(B[m[31m-            "metadata": r.memory.metadata
(B[m[31m-        })).collect(),
(B[m[32m+        results: results
(B[m[32m+            .into_iter()
(B[m[32m+            .map(|r| {
(B[m[32m+                serde_json::json!({
(B[m[32m+                    "id": r.memory.id,
(B[m[32m+                    "content": r.memory.content,
(B[m[32m+                    "score": r.score,
(B[m[32m+                    "agent_id": r.memory.agent_id,
(B[m[32m+                    "user_id": r.memory.user_id,
(B[m[32m+                    "memory_type": r.memory.memory_type,
(B[m[32m+                    "importance": r.memory.importance,
(B[m[32m+                    "created_at": r.memory.created_at,
(B[m[32m+                    "metadata": r.memory.metadata
(B[m[32m+                })
(B[m[32m+            })
(B[m[32m+            .collect(),
(B[m         total,
     };
[31m-    
(B[m[32m+
(B[m     Ok(Json(response))
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:259:
     Path(id): Path<String>,
 ) -> ServerResult<Json<serde_json::Value>> {
     info!("Getting history for memory ID: {}", id);
[31m-    
(B[m[32m+
(B[m     // TODO: Implement memory history functionality
     let response = serde_json::json!({
         "memory_id": id,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:266:
         "history": [],
         "message": "Memory history feature not yet implemented"
     });
[31m-    
(B[m[32m+
(B[m     Ok(Json(response))
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:287:
     Json(request): Json<BatchRequest>,
 ) -> ServerResult<(StatusCode, Json<BatchResponse>)> {
     info!("Batch adding {} memories", request.memories.len());
[31m-    
(B[m[32m+
(B[m     let mut results = Vec::new();
     let mut errors = Vec::new();
[31m-    
(B[m[32m+
(B[m     for memory_req in request.memories {
         let memory_type = memory_req.memory_type.unwrap_or(MemoryType::Episodic);
         let importance = memory_req.importance.unwrap_or(0.5);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:297:
[31m-        
(B[m[32m+
(B[m         match memory_manager
             .add_memory(
                 memory_req.agent_id,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:310:
             Err(e) => errors.push(e.to_string()),
         }
     }
[31m-    
(B[m[32m+
(B[m     let response = BatchResponse {
         successful: results.len(),
         failed: errors.len(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:317:
         results,
         errors,
     };
[31m-    
(B[m[32m+
(B[m     Ok((StatusCode::CREATED, Json(response)))
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:338:
     Json(ids): Json<Vec<String>>,
 ) -> ServerResult<Json<BatchResponse>> {
     info!("Batch deleting {} memories", ids.len());
[31m-    
(B[m[32m+
(B[m     let mut successful = 0;
     let mut errors = Vec::new();
[31m-    
(B[m[32m+
(B[m     for id in &ids {
         match memory_manager.delete_memory(id).await {
             Ok(_) => successful += 1,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:348:
             Err(e) => errors.push(format!("Failed to delete {}: {}", id, e)),
         }
     }
[31m-    
(B[m[32m+
(B[m     let response = BatchResponse {
         successful,
         failed: errors.len(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/memory.rs:355:
         results: vec![], // No results for delete operations
         errors,
     };
[31m-    
(B[m[32m+
(B[m     Ok(Json(response))
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/metrics.rs:1:
 //! Metrics and monitoring routes
 
[31m-use crate::{
(B[m[31m-    error::ServerResult,
(B[m[31m-    models::MetricsResponse,
(B[m[31m-};
(B[m[32m+use crate::{error::ServerResult, models::MetricsResponse};
(B[m use agent_mem_core::MemoryManager;
[31m-use axum::{
(B[m[31m-    extract::Extension,
(B[m[31m-    response::Json,
(B[m[31m-};
(B[m[31m-use std::sync::Arc;
(B[m[32m+use axum::{extract::Extension, response::Json};
(B[m use chrono::Utc;
[32m+use std::sync::Arc;
(B[m use utoipa;
 
 /// Get system metrics
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/metrics.rs:27:
     Extension(memory_manager): Extension<Arc<MemoryManager>>,
 ) -> ServerResult<Json<MetricsResponse>> {
     // Get memory statistics
[31m-    let stats = memory_manager.get_memory_stats(None).await
(B[m[32m+    let stats = memory_manager
(B[m[32m+        .get_memory_stats(None)
(B[m[32m+        .await
(B[m         .map_err(|e| crate::error::ServerError::MemoryError(e.to_string()))?;
 
     let mut metrics = std::collections::HashMap::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/metrics.rs:36:
     metrics.insert("total_memories".to_string(), stats.total_memories as f64);
 
     // Extract memory counts by type
[31m-    let episodic_count = stats.memories_by_type.get(&agent_mem_core::MemoryType::Episodic).unwrap_or(&0);
(B[m[31m-    let semantic_count = stats.memories_by_type.get(&agent_mem_core::MemoryType::Semantic).unwrap_or(&0);
(B[m[31m-    let procedural_count = stats.memories_by_type.get(&agent_mem_core::MemoryType::Procedural).unwrap_or(&0);
(B[m[32m+    let episodic_count = stats
(B[m[32m+        .memories_by_type
(B[m[32m+        .get(&agent_mem_core::MemoryType::Episodic)
(B[m[32m+        .unwrap_or(&0);
(B[m[32m+    let semantic_count = stats
(B[m[32m+        .memories_by_type
(B[m[32m+        .get(&agent_mem_core::MemoryType::Semantic)
(B[m[32m+        .unwrap_or(&0);
(B[m[32m+    let procedural_count = stats
(B[m[32m+        .memories_by_type
(B[m[32m+        .get(&agent_mem_core::MemoryType::Procedural)
(B[m[32m+        .unwrap_or(&0);
(B[m 
     metrics.insert("episodic_memories".to_string(), *episodic_count as f64);
     metrics.insert("semantic_memories".to_string(), *semantic_count as f64);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/metrics.rs:45:
     metrics.insert("procedural_memories".to_string(), *procedural_count as f64);
[31m-    metrics.insert("average_importance".to_string(), stats.average_importance as f64);
(B[m[31m-    
(B[m[32m+    metrics.insert(
(B[m[32m+        "average_importance".to_string(),
(B[m[32m+        stats.average_importance as f64,
(B[m[32m+    );
(B[m[32m+
(B[m     // System metrics (would be expanded with actual system monitoring)
     metrics.insert("uptime_seconds".to_string(), 0.0); // Placeholder
     metrics.insert("memory_usage_bytes".to_string(), 0.0); // Placeholder
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/metrics.rs:51:
     metrics.insert("cpu_usage_percent".to_string(), 0.0); // Placeholder
[31m-    
(B[m[32m+
(B[m     let response = MetricsResponse {
         timestamp: Utc::now(),
         metrics,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/metrics.rs:56:
     };
[31m-    
(B[m[32m+
(B[m     Ok(Json(response))
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/metrics.rs:68:
         let memory_manager = Arc::new(MemoryManager::new());
         let result = get_metrics(Extension(memory_manager)).await;
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let response = result.unwrap().0;
         assert!(response.metrics.contains_key("total_memories"));
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/mod.rs:1:
 //! HTTP routes for the AgentMem API
 
[31m-pub mod memory;
(B[m[32m+pub mod docs;
(B[m pub mod health;
[32m+pub mod memory;
(B[m pub mod metrics;
[31m-pub mod docs;
(B[m 
 use crate::error::ServerResult;
 use agent_mem_core::MemoryManager;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/mod.rs:10:
 use axum::{
[31m-    routing::{get, post, put, delete},
(B[m[31m-    Router, Extension,
(B[m[32m+    routing::{delete, get, post, put},
(B[m[32m+    Extension, Router,
(B[m };
 use std::sync::Arc;
[31m-use tower_http::{
(B[m[31m-    cors::CorsLayer,
(B[m[31m-    trace::TraceLayer,
(B[m[31m-};
(B[m[32m+use tower_http::{cors::CorsLayer, trace::TraceLayer};
(B[m use utoipa::OpenApi;
 use utoipa_swagger_ui::SwaggerUi;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/mod.rs:28:
         .route("/api/v1/memories/:id", put(memory::update_memory))
         .route("/api/v1/memories/:id", delete(memory::delete_memory))
         .route("/api/v1/memories/search", post(memory::search_memories))
[31m-        .route("/api/v1/memories/:id/history", get(memory::get_memory_history))
(B[m[31m-        
(B[m[32m+        .route(
(B[m[32m+            "/api/v1/memories/:id/history",
(B[m[32m+            get(memory::get_memory_history),
(B[m[32m+        )
(B[m         // Batch operations
         .route("/api/v1/memories/batch", post(memory::batch_add_memories))
[31m-        .route("/api/v1/memories/batch/delete", post(memory::batch_delete_memories))
(B[m[31m-        
(B[m[32m+        .route(
(B[m[32m+            "/api/v1/memories/batch/delete",
(B[m[32m+            post(memory::batch_delete_memories),
(B[m[32m+        )
(B[m         // Health and monitoring
         .route("/health", get(health::health_check))
         .route("/metrics", get(metrics::get_metrics))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/routes/mod.rs:40:
[31m-        
(B[m         // OpenAPI documentation
         .merge(SwaggerUi::new("/swagger-ui").url("/api-docs/openapi.json", ApiDoc::openapi()))
[31m-        
(B[m         // Add shared state
         .layer(Extension(memory_manager))
[31m-        
(B[m         // Add middleware
         .layer(TraceLayer::new_for_http())
         .layer(CorsLayer::permissive());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/server.rs:25:
     pub async fn new(config: ServerConfig) -> ServerResult<Self> {
         // Setup telemetry
         setup_telemetry(&config)?;
[31m-        
(B[m[32m+
(B[m         // Create memory manager
         let memory_manager = Arc::new(MemoryManager::new());
[31m-        
(B[m[32m+
(B[m         // Create router with all routes and middleware
         let router = create_router(memory_manager.clone()).await?;
[31m-        
(B[m[32m+
(B[m         info!("Memory server initialized successfully");
[31m-        
(B[m[32m+
(B[m         Ok(Self {
             config,
             memory_manager,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/server.rs:40:
             router,
         })
     }
[31m-    
(B[m[32m+
(B[m     /// Start the server
     pub async fn start(self) -> ServerResult<()> {
         let addr = SocketAddr::from(([0, 0, 0, 0], self.config.port));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/server.rs:47:
[31m-        let listener = TcpListener::bind(addr).await
(B[m[32m+        let listener = TcpListener::bind(addr)
(B[m[32m+            .await
(B[m             .map_err(|e| ServerError::BindError(e.to_string()))?;
[31m-        
(B[m[32m+
(B[m         info!("AgentMem server starting on {}", addr);
         info!("API documentation available at http://{}/swagger-ui/", addr);
         info!("Health check endpoint: http://{}/health", addr);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/server.rs:53:
         info!("Metrics endpoint: http://{}/metrics", addr);
[31m-        
(B[m[32m+
(B[m         // Start the server
         axum::serve(listener, self.router)
             .await
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/server.rs:58:
             .map_err(|e| ServerError::ServerError(e.to_string()))?;
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Get server configuration
     pub fn config(&self) -> &ServerConfig {
         &self.config
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/server.rs:66:
     }
[31m-    
(B[m[32m+
(B[m     /// Get memory manager reference
     pub fn memory_manager(&self) -> Arc<MemoryManager> {
         self.memory_manager.clone()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/server.rs:71:
     }
[31m-    
(B[m[32m+
(B[m     /// Graceful shutdown
     pub async fn shutdown(&self) -> ServerResult<()> {
         info!("Shutting down AgentMem server gracefully...");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/telemetry.rs:1:
 //! Telemetry and monitoring setup
 
[31m-use crate::{config::ServerConfig, error::{ServerError, ServerResult}};
(B[m[32m+use crate::{
(B[m[32m+    config::ServerConfig,
(B[m[32m+    error::{ServerError, ServerResult},
(B[m[32m+};
(B[m use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
 
 /// Setup telemetry and logging
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/telemetry.rs:8:
     if !config.enable_logging {
         return Ok(());
     }
[31m-    
(B[m[32m+
(B[m     // Create environment filter
[31m-    let env_filter = EnvFilter::try_from_default_env()
(B[m[31m-        .unwrap_or_else(|_| EnvFilter::new(&config.log_level));
(B[m[31m-    
(B[m[32m+    let env_filter =
(B[m[32m+        EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(&config.log_level));
(B[m[32m+
(B[m     // Setup tracing subscriber
     tracing_subscriber::registry()
         .with(env_filter)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/telemetry.rs:19:
         .with(tracing_subscriber::fmt::layer().with_target(false))
         .try_init()
         .map_err(|e| ServerError::TelemetryError(format!("Failed to setup tracing: {}", e)))?;
[31m-    
(B[m[32m+
(B[m     tracing::info!("Telemetry initialized with log level: {}", config.log_level);
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/telemetry.rs:34:
     pub fn new() -> Self {
         Self {}
     }
[31m-    
(B[m[32m+
(B[m     pub fn record_request(&self, _method: &str, _path: &str, _status: u16, _duration_ms: u64) {
         // TODO: Record request metrics
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/telemetry.rs:41:
[31m-    
(B[m[32m+
(B[m     pub fn record_memory_operation(&self, _operation: &str, _success: bool, _duration_ms: u64) {
         // TODO: Record memory operation metrics
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/telemetry.rs:45:
[31m-    
(B[m[32m+
(B[m     pub fn get_metrics(&self) -> std::collections::HashMap<String, f64> {
         // TODO: Return actual metrics
         std::collections::HashMap::new()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/telemetry.rs:65:
         let metrics = collector.get_metrics();
         assert!(metrics.is_empty()); // Placeholder implementation
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_telemetry_setup_disabled() {
         let mut config = ServerConfig::default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/telemetry.rs:72:
         config.enable_logging = false;
[31m-        
(B[m[32m+
(B[m         let result = setup_telemetry(&config);
         assert!(result.is_ok());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:1:
 //! AgentMem Server Binary
[31m-//! 
(B[m[32m+//!
(B[m //! Standalone server for AgentMem memory management platform.
 
 use agent_mem_server::{MemoryServer, ServerConfig};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:15:
     /// Server port
     #[arg(short, long, default_value = "8080")]
     port: u16,
[31m-    
(B[m[32m+
(B[m     /// Server host
     #[arg(long, default_value = "0.0.0.0")]
     host: String,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:22:
[31m-    
(B[m[32m+
(B[m     /// Enable CORS
     #[arg(long, default_value = "true")]
     cors: bool,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:26:
[31m-    
(B[m[32m+
(B[m     /// Enable authentication
     #[arg(long, default_value = "false")]
     auth: bool,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:30:
[31m-    
(B[m[32m+
(B[m     /// JWT secret (required if auth is enabled)
     #[arg(long)]
     jwt_secret: Option<String>,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:34:
[31m-    
(B[m[32m+
(B[m     /// Log level
     #[arg(long, default_value = "info")]
     log_level: String,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:38:
[31m-    
(B[m[32m+
(B[m     /// Configuration file
     #[arg(short, long)]
     config: Option<String>,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:44:
 #[tokio::main]
 async fn main() {
     let cli = Cli::parse();
[31m-    
(B[m[32m+
(B[m     // Create server configuration
     let mut config = if let Some(config_file) = cli.config {
         // TODO: Load configuration from file
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:53:
     } else {
         ServerConfig::default()
     };
[31m-    
(B[m[32m+
(B[m     // Override with CLI arguments
     config.port = cli.port;
     config.host = cli.host;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:60:
     config.enable_cors = cli.cors;
     config.enable_auth = cli.auth;
     config.log_level = cli.log_level;
[31m-    
(B[m[32m+
(B[m     if cli.auth {
         if let Some(secret) = cli.jwt_secret {
             config.jwt_secret = secret;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:70:
             process::exit(1);
         }
     }
[31m-    
(B[m[32m+
(B[m     // Validate configuration
     if let Err(e) = config.validate() {
         eprintln!("Configuration error: {}", e);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:77:
         process::exit(1);
     }
[31m-    
(B[m[32m+
(B[m     // Create and start server
     match MemoryServer::new(config).await {
         Ok(server) => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:83:
             info!("Starting AgentMem server...");
[31m-            
(B[m[32m+
(B[m             // Setup graceful shutdown
             let shutdown_signal = async {
                 tokio::signal::ctrl_c()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/src/main.rs:89:
                     .expect("Failed to install CTRL+C signal handler");
                 info!("Shutdown signal received");
             };
[31m-            
(B[m[32m+
(B[m             // Start server with graceful shutdown
             tokio::select! {
                 result = server.start() => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/tests/integration_tests.rs:12:
     let mut config = ServerConfig::default();
     config.port = 8081; // Use different port for testing
     config.enable_auth = false;
[31m-    
(B[m[32m+
(B[m     // Start server in background
[31m-    let server = MemoryServer::new(config).await.expect("Failed to create server");
(B[m[31m-    
(B[m[32m+    let server = MemoryServer::new(config)
(B[m[32m+        .await
(B[m[32m+        .expect("Failed to create server");
(B[m[32m+
(B[m     tokio::spawn(async move {
         if let Err(e) = server.start().await {
             eprintln!("Server error: {}", e);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/tests/integration_tests.rs:22:
         }
     });
[31m-    
(B[m[32m+
(B[m     // Wait for server to start
     sleep(Duration::from_millis(100)).await;
[31m-    
(B[m[32m+
(B[m     // Test health check endpoint
     let client = reqwest::Client::new();
[31m-    let response = client
(B[m[31m-        .get("http://localhost:8081/health")
(B[m[31m-        .send()
(B[m[31m-        .await;
(B[m[31m-    
(B[m[32m+    let response = client.get("http://localhost:8081/health").send().await;
(B[m[32m+
(B[m     match response {
         Ok(resp) => {
             assert_eq!(resp.status(), 200);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/tests/integration_tests.rs:49:
 async fn test_memory_api_endpoints() {
     // This test would require a running server
     // For now, we'll just test the data structures
[31m-    
(B[m[32m+
(B[m     let memory_request = json!({
         "agent_id": "test_agent",
         "user_id": "test_user",
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/tests/integration_tests.rs:57:
         "memory_type": "Episodic",
         "importance": 0.8
     });
[31m-    
(B[m[32m+
(B[m     // Validate the JSON structure
     assert!(memory_request["agent_id"].is_string());
     assert!(memory_request["content"].is_string());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/tests/integration_tests.rs:67:
 #[test]
 fn test_server_config_validation() {
     let mut config = ServerConfig::default();
[31m-    
(B[m[32m+
(B[m     // Valid configuration should pass
     assert!(config.validate().is_ok());
[31m-    
(B[m[32m+
(B[m     // Invalid port should fail
     config.port = 0;
     assert!(config.validate().is_err());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-server/tests/integration_tests.rs:77:
[31m-    
(B[m[32m+
(B[m     // Reset port and test JWT secret
     config.port = 8080;
     config.jwt_secret = "short".to_string(); // Too short
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:1:
 //! Chroma向量存储实现
 
[31m-use agent_mem_traits::{VectorStore, VectorStoreConfig, VectorData, VectorSearchResult, Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{
(B[m[32m+    AgentMemError, Result, VectorData, VectorSearchResult, VectorStore, VectorStoreConfig,
(B[m[32m+};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:46:
         let client = Client::builder()
             .timeout(Duration::from_secs(30))
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(format!("Failed to create HTTP client: {}", e)))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m 
[31m-        let base_url = config.url.clone()
(B[m[32m+        let base_url = config
(B[m[32m+            .url
(B[m[32m+            .clone()
(B[m             .unwrap_or_else(|| "http://localhost:8000".to_string());
 
[31m-        let collection_name = config.collection_name.clone()
(B[m[32m+        let collection_name = config
(B[m[32m+            .collection_name
(B[m[32m+            .clone()
(B[m             .unwrap_or_else(|| "default".to_string());
 
         Ok(Self {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:64:
 
     /// 获取集合URL
     fn get_collection_url(&self) -> String {
[31m-        format!("{}/api/v1/collections/{}", self.base_url, self.collection_name)
(B[m[32m+        format!(
(B[m[32m+            "{}/api/v1/collections/{}",
(B[m[32m+            self.base_url, self.collection_name
(B[m[32m+        )
(B[m     }
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:85:
         };
 
         let url = format!("{}/add", self.get_collection_url());
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Content-Type", "application/json")
             .json(&request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:95:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Chroma API error {}: {}", status, error_text
(B[m[32m+                "Chroma API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:105:
         Ok(ids)
     }
 
[31m-    async fn search_vectors(&self, query_vector: Vec<f32>, limit: usize, _threshold: Option<f32>) -> Result<Vec<VectorSearchResult>> {
(B[m[32m+    async fn search_vectors(
(B[m[32m+        &self,
(B[m[32m+        query_vector: Vec<f32>,
(B[m[32m+        limit: usize,
(B[m[32m+        _threshold: Option<f32>,
(B[m[32m+    ) -> Result<Vec<VectorSearchResult>> {
(B[m         let request = ChromaQueryRequest {
             query_embeddings: vec![query_vector],
             n_results: limit,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:113:
         };
 
         let url = format!("{}/query", self.get_collection_url());
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Content-Type", "application/json")
             .json(&request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:123:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Chroma API error {}: {}", status, error_text
(B[m[32m+                "Chroma API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:133:
[31m-        let chroma_response: ChromaQueryResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let chroma_response: ChromaQueryResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         let mut results = Vec::new();
[31m-        
(B[m[31m-        if let (Some(ids), Some(distances)) = (chroma_response.ids.get(0), chroma_response.distances.get(0)) {
(B[m[32m+
(B[m[32m+        if let (Some(ids), Some(distances)) =
(B[m[32m+            (chroma_response.ids.get(0), chroma_response.distances.get(0))
(B[m[32m+        {
(B[m             for (i, (id, distance)) in ids.iter().zip(distances.iter()).enumerate() {
[31m-                let vector = chroma_response.embeddings
(B[m[32m+                let vector = chroma_response
(B[m[32m+                    .embeddings
(B[m                     .as_ref()
                     .and_then(|embs| embs.get(0))
                     .and_then(|emb| emb.get(i))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:144:
                     .cloned()
                     .unwrap_or_default();
 
[31m-                let metadata = chroma_response.metadatas
(B[m[32m+                let metadata = chroma_response
(B[m[32m+                    .metadatas
(B[m                     .as_ref()
                     .and_then(|metas| metas.get(0))
                     .and_then(|meta| meta.get(i))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:174:
             "ids": ids
         });
 
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Content-Type", "application/json")
             .json(&request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:184:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Chroma API error {}: {}", status, error_text
(B[m[32m+                "Chroma API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:209:
         });
 
         let url = format!("{}/update", self.get_collection_url());
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Content-Type", "application/json")
             .json(&request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:219:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Chroma API error {}: {}", status, error_text
(B[m[32m+                "Chroma API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:236:
             "include": ["embeddings", "metadatas"]
         });
 
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Content-Type", "application/json")
             .json(&request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:246:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Chroma API error {}: {}", status, error_text
(B[m[32m+                "Chroma API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:256:
[31m-        let response_data: serde_json::Value = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let response_data: serde_json::Value = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         // 解析响应并构建VectorData
         if let (Some(ids), Some(embeddings)) = (
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:261:
             response_data["ids"].as_array(),
[31m-            response_data["embeddings"].as_array()
(B[m[32m+            response_data["embeddings"].as_array(),
(B[m         ) {
             if !ids.is_empty() && !embeddings.is_empty() {
[31m-                let vector: Vec<f32> = embeddings[0].as_array()
(B[m[32m+                let vector: Vec<f32> = embeddings[0]
(B[m[32m+                    .as_array()
(B[m                     .unwrap_or(&Vec::new())
                     .iter()
                     .filter_map(|v| v.as_f64().map(|f| f as f32))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:269:
                     .collect();
 
[31m-                let metadata = response_data["metadatas"].as_array()
(B[m[32m+                let metadata = response_data["metadatas"]
(B[m[32m+                    .as_array()
(B[m                     .and_then(|metas| metas.get(0))
                     .and_then(|meta| serde_json::from_value(meta.clone()).ok())
                     .unwrap_or_default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:286:
 
     async fn count_vectors(&self) -> Result<usize> {
         let url = format!("{}/count", self.get_collection_url());
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .get(&url)
             .send()
             .await
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:294:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Chroma API error {}: {}", status, error_text
(B[m[32m+                "Chroma API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:304:
[31m-        let count: usize = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let count: usize = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         Ok(count)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:309:
 
     async fn clear(&self) -> Result<()> {
         // Chroma没有直接的清空API，我们需要删除整个集合然后重新创建
[31m-        Err(AgentMemError::llm_error("Clear operation not supported for Chroma"))
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "Clear operation not supported for Chroma",
(B[m[32m+        ))
(B[m     }
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/chroma.rs:341:
 
         let rt = tokio::runtime::Runtime::new().unwrap();
         let store = rt.block_on(ChromaStore::new(config)).unwrap();
[31m-        
(B[m[31m-        assert_eq!(store.get_collection_url(), "http://localhost:8000/api/v1/collections/test");
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            store.get_collection_url(),
(B[m[32m+            "http://localhost:8000/api/v1/collections/test"
(B[m[32m+        );
(B[m     }
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:1:
 //! Elasticsearch vector database backend implementation
[31m-//! 
(B[m[32m+//!
(B[m //! Provides integration with Elasticsearch for vector similarity search
 //! using dense vector fields and kNN search capabilities.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError, EmbeddingVectorStore, SearchResult};
(B[m[32m+use agent_mem_traits::{AgentMemError, EmbeddingVectorStore, Result, SearchResult};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:128:
         let client = Client::builder()
             .timeout(std::time::Duration::from_secs(config.timeout_seconds))
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         Ok(Self { config, client })
     }
[31m-    
(B[m[32m+
(B[m     /// Initialize the Elasticsearch index
     pub async fn initialize_index(&self) -> Result<()> {
[31m-        info!("Initializing Elasticsearch index: {}", self.config.index_name);
(B[m[31m-        
(B[m[32m+        info!(
(B[m[32m+            "Initializing Elasticsearch index: {}",
(B[m[32m+            self.config.index_name
(B[m[32m+        );
(B[m[32m+
(B[m         // Check if index exists
         let exists = self.index_exists().await?;
         if exists {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:143:
             info!("Index {} already exists", self.config.index_name);
             return Ok(());
         }
[31m-        
(B[m[32m+
(B[m         // Create index mapping
         let mapping = serde_json::json!({
             "mappings": {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:176:
                 "number_of_replicas": 0
             }
         });
[31m-        
(B[m[31m-        let response = self.build_request(
(B[m[31m-            reqwest::Method::PUT,
(B[m[31m-            &format!("{}/{}", self.config.url, self.config.index_name)
(B[m[31m-        )
(B[m[31m-        .header("Content-Type", "application/json")
(B[m[31m-        .json(&mapping)
(B[m[31m-        .send()
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| AgentMemError::network_error(&format!("Failed to create index: {}", e)))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .build_request(
(B[m[32m+                reqwest::Method::PUT,
(B[m[32m+                &format!("{}/{}", self.config.url, self.config.index_name),
(B[m[32m+            )
(B[m[32m+            .header("Content-Type", "application/json")
(B[m[32m+            .json(&mapping)
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m[32m+            .map_err(|e| AgentMemError::network_error(&format!("Failed to create index: {}", e)))?;
(B[m[32m+
(B[m         if response.status().is_success() {
             info!("Elasticsearch index created successfully");
             Ok(())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:194:
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
             error!("Failed to create index: {} - {}", status, error_text);
[31m-            Err(AgentMemError::storage_error(&format!("Index creation failed: {}", error_text)))
(B[m[32m+            Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Index creation failed: {}",
(B[m[32m+                error_text
(B[m[32m+            )))
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     /// Check if index exists
     async fn index_exists(&self) -> Result<bool> {
[31m-        let response = self.build_request(
(B[m[31m-            reqwest::Method::HEAD,
(B[m[31m-            &format!("{}/{}", self.config.url, self.config.index_name)
(B[m[31m-        )
(B[m[31m-        .send()
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| AgentMemError::network_error(&format!("Failed to check index: {}", e)))?;
(B[m[31m-        
(B[m[32m+        let response = self
(B[m[32m+            .build_request(
(B[m[32m+                reqwest::Method::HEAD,
(B[m[32m+                &format!("{}/{}", self.config.url, self.config.index_name),
(B[m[32m+            )
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m[32m+            .map_err(|e| AgentMemError::network_error(&format!("Failed to check index: {}", e)))?;
(B[m[32m+
(B[m         Ok(response.status().is_success())
     }
[31m-    
(B[m[32m+
(B[m     /// Build request with authentication
     fn build_request(&self, method: reqwest::Method, url: &str) -> reqwest::RequestBuilder {
         let mut request = self.client.request(method, url);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:217:
[31m-        
(B[m[32m+
(B[m         if let (Some(username), Some(password)) = (&self.config.username, &self.config.password) {
             request = request.basic_auth(username, Some(password));
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:221:
[31m-        
(B[m[32m+
(B[m         request
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:232:
         metadata: &HashMap<String, String>,
     ) -> Result<()> {
         debug!("Storing embedding for memory: {}", memory_id);
[31m-        
(B[m[32m+
(B[m         let mut doc_metadata = HashMap::new();
         for (key, value) in metadata {
             if !["memory_id", "content", "agent_id", "user_id"].contains(&key.as_str()) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:239:
                 doc_metadata.insert(key.clone(), serde_json::Value::String(value.clone()));
             }
         }
[31m-        
(B[m[32m+
(B[m         let document = ElasticsearchDocument {
             memory_id: memory_id.to_string(),
             embedding: embedding.to_vec(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:249:
             created_at: chrono::Utc::now().timestamp(),
             metadata: doc_metadata,
         };
[31m-        
(B[m[31m-        let response = self.build_request(
(B[m[31m-            reqwest::Method::PUT,
(B[m[31m-            &format!("{}/{}/_doc/{}", self.config.url, self.config.index_name, memory_id)
(B[m[31m-        )
(B[m[31m-        .header("Content-Type", "application/json")
(B[m[31m-        .json(&document)
(B[m[31m-        .send()
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| AgentMemError::network_error(&format!("Failed to store embedding: {}", e)))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .build_request(
(B[m[32m+                reqwest::Method::PUT,
(B[m[32m+                &format!(
(B[m[32m+                    "{}/{}/_doc/{}",
(B[m[32m+                    self.config.url, self.config.index_name, memory_id
(B[m[32m+                ),
(B[m[32m+            )
(B[m[32m+            .header("Content-Type", "application/json")
(B[m[32m+            .json(&document)
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to store embedding: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         if response.status().is_success() {
             debug!("Successfully stored embedding for memory: {}", memory_id);
             Ok(())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:267:
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
             error!("Failed to store embedding: {} - {}", status, error_text);
[31m-            Err(AgentMemError::storage_error(&format!("Failed to store embedding: {}", error_text)))
(B[m[32m+            Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Failed to store embedding: {}",
(B[m[32m+                error_text
(B[m[32m+            )))
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     async fn search_similar(
         &self,
         query_embedding: &[f32],
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:278:
         threshold: Option<f32>,
     ) -> Result<Vec<SearchResult>> {
         debug!("Searching for similar embeddings with limit: {}", limit);
[31m-        
(B[m[32m+
(B[m         let search_request = ElasticsearchSearchRequest {
             size: limit,
             query: ElasticsearchQuery {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:296:
                 "user_id".to_string(),
             ],
         };
[31m-        
(B[m[31m-        let response = self.build_request(
(B[m[31m-            reqwest::Method::POST,
(B[m[31m-            &format!("{}/{}/_search", self.config.url, self.config.index_name)
(B[m[31m-        )
(B[m[31m-        .header("Content-Type", "application/json")
(B[m[31m-        .json(&search_request)
(B[m[31m-        .send()
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| AgentMemError::network_error(&format!("Failed to search: {}", e)))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .build_request(
(B[m[32m+                reqwest::Method::POST,
(B[m[32m+                &format!("{}/{}/_search", self.config.url, self.config.index_name),
(B[m[32m+            )
(B[m[32m+            .header("Content-Type", "application/json")
(B[m[32m+            .json(&search_request)
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m[32m+            .map_err(|e| AgentMemError::network_error(&format!("Failed to search: {}", e)))?;
(B[m[32m+
(B[m         if !response.status().is_success() {
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:313:
             error!("Search failed: {} - {}", status, error_text);
[31m-            return Err(AgentMemError::storage_error(&format!("Search failed: {}", error_text)));
(B[m[32m+            return Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Search failed: {}",
(B[m[32m+                error_text
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[31m-        let search_response: ElasticsearchSearchResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(&format!("Failed to parse search response: {}", e)))?;
(B[m[31m-        
(B[m[31m-        let results: Vec<SearchResult> = search_response.hits.hits
(B[m[32m+
(B[m[32m+        let search_response: ElasticsearchSearchResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(&format!("Failed to parse search response: {}", e))
(B[m[32m+        })?;
(B[m[32m+
(B[m[32m+        let results: Vec<SearchResult> = search_response
(B[m[32m+            .hits
(B[m[32m+            .hits
(B[m             .into_iter()
             .filter_map(|hit| {
                 // Apply threshold filter
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:326:
                         return None;
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 let mut metadata = HashMap::new();
[31m-                metadata.insert("content".to_string(), serde_json::Value::String(hit.source.content));
(B[m[31m-                metadata.insert("agent_id".to_string(), serde_json::Value::String(hit.source.agent_id));
(B[m[31m-                metadata.insert("user_id".to_string(), serde_json::Value::String(hit.source.user_id));
(B[m[32m+                metadata.insert(
(B[m[32m+                    "content".to_string(),
(B[m[32m+                    serde_json::Value::String(hit.source.content),
(B[m[32m+                );
(B[m[32m+                metadata.insert(
(B[m[32m+                    "agent_id".to_string(),
(B[m[32m+                    serde_json::Value::String(hit.source.agent_id),
(B[m[32m+                );
(B[m[32m+                metadata.insert(
(B[m[32m+                    "user_id".to_string(),
(B[m[32m+                    serde_json::Value::String(hit.source.user_id),
(B[m[32m+                );
(B[m 
                 Some(SearchResult {
                     id: hit.source.memory_id,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:339:
                 })
             })
             .collect();
[31m-        
(B[m[32m+
(B[m         debug!("Found {} similar embeddings", results.len());
         Ok(results)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:346:
[31m-    
(B[m[32m+
(B[m     async fn delete_embedding(&self, memory_id: &str) -> Result<()> {
         debug!("Deleting embedding for memory: {}", memory_id);
[31m-        
(B[m[31m-        let response = self.build_request(
(B[m[31m-            reqwest::Method::DELETE,
(B[m[31m-            &format!("{}/{}/_doc/{}", self.config.url, self.config.index_name, memory_id)
(B[m[31m-        )
(B[m[31m-        .send()
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| AgentMemError::network_error(&format!("Failed to delete embedding: {}", e)))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .build_request(
(B[m[32m+                reqwest::Method::DELETE,
(B[m[32m+                &format!(
(B[m[32m+                    "{}/{}/_doc/{}",
(B[m[32m+                    self.config.url, self.config.index_name, memory_id
(B[m[32m+                ),
(B[m[32m+            )
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to delete embedding: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         if response.status().is_success() {
             debug!("Successfully deleted embedding for memory: {}", memory_id);
             Ok(())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:362:
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
             error!("Failed to delete embedding: {} - {}", status, error_text);
[31m-            Err(AgentMemError::storage_error(&format!("Failed to delete embedding: {}", error_text)))
(B[m[32m+            Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Failed to delete embedding: {}",
(B[m[32m+                error_text
(B[m[32m+            )))
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     async fn update_embedding(
         &self,
         memory_id: &str,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:373:
         metadata: &HashMap<String, String>,
     ) -> Result<()> {
         debug!("Updating embedding for memory: {}", memory_id);
[31m-        
(B[m[32m+
(B[m         // Elasticsearch PUT will update or create
         self.store_embedding(memory_id, embedding, metadata).await
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:380:
[31m-    
(B[m[32m+
(B[m     async fn get_embedding(&self, memory_id: &str) -> Result<Option<Vec<f32>>> {
         debug!("Getting embedding for memory: {}", memory_id);
[31m-        
(B[m[31m-        let response = self.build_request(
(B[m[31m-            reqwest::Method::GET,
(B[m[31m-            &format!("{}/{}/_doc/{}", self.config.url, self.config.index_name, memory_id)
(B[m[31m-        )
(B[m[31m-        .send()
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| AgentMemError::network_error(&format!("Failed to get embedding: {}", e)))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .build_request(
(B[m[32m+                reqwest::Method::GET,
(B[m[32m+                &format!(
(B[m[32m+                    "{}/{}/_doc/{}",
(B[m[32m+                    self.config.url, self.config.index_name, memory_id
(B[m[32m+                ),
(B[m[32m+            )
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to get embedding: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         if response.status().is_success() {
[31m-            let doc_response: serde_json::Value = response.json().await
(B[m[31m-                .map_err(|e| AgentMemError::parsing_error(&format!("Failed to parse document: {}", e)))?;
(B[m[31m-            
(B[m[32m+            let doc_response: serde_json::Value = response.json().await.map_err(|e| {
(B[m[32m+                AgentMemError::parsing_error(&format!("Failed to parse document: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m             if let Some(source) = doc_response.get("_source") {
                 if let Some(embedding) = source.get(&self.config.vector_field) {
                     if let Some(embedding_array) = embedding.as_array() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:399:
                         let embedding_vec: std::result::Result<Vec<f32>, &str> = embedding_array
                             .iter()
[31m-                            .map(|v| v.as_f64().map(|f| f as f32).ok_or("Invalid embedding value"))
(B[m[32m+                            .map(|v| {
(B[m[32m+                                v.as_f64()
(B[m[32m+                                    .map(|f| f as f32)
(B[m[32m+                                    .ok_or("Invalid embedding value")
(B[m[32m+                            })
(B[m                             .collect();
[31m-                        
(B[m[32m+
(B[m                         match embedding_vec {
                             Ok(vec) => return Ok(Some(vec)),
[31m-                            Err(e) => return Err(AgentMemError::parsing_error(&format!("Failed to parse embedding: {}", e))),
(B[m[32m+                            Err(e) => {
(B[m[32m+                                return Err(AgentMemError::parsing_error(&format!(
(B[m[32m+                                    "Failed to parse embedding: {}",
(B[m[32m+                                    e
(B[m[32m+                                )))
(B[m[32m+                            }
(B[m                         }
                     }
                 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:410:
             }
[31m-            
(B[m[32m+
(B[m             Ok(None)
         } else if response.status().as_u16() == 404 {
             Ok(None)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:416:
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
             error!("Failed to get embedding: {} - {}", status, error_text);
[31m-            Err(AgentMemError::storage_error(&format!("Failed to get embedding: {}", error_text)))
(B[m[32m+            Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Failed to get embedding: {}",
(B[m[32m+                error_text
(B[m[32m+            )))
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     async fn list_embeddings(&self, prefix: Option<&str>) -> Result<Vec<String>> {
         debug!("Listing embeddings with prefix: {:?}", prefix);
[31m-        
(B[m[32m+
(B[m         let query = if let Some(prefix) = prefix {
             serde_json::json!({
                 "query": {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:442:
                 "size": 10000
             })
         };
[31m-        
(B[m[31m-        let response = self.build_request(
(B[m[31m-            reqwest::Method::POST,
(B[m[31m-            &format!("{}/{}/_search", self.config.url, self.config.index_name)
(B[m[31m-        )
(B[m[31m-        .header("Content-Type", "application/json")
(B[m[31m-        .json(&query)
(B[m[31m-        .send()
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| AgentMemError::network_error(&format!("Failed to list embeddings: {}", e)))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .build_request(
(B[m[32m+                reqwest::Method::POST,
(B[m[32m+                &format!("{}/{}/_search", self.config.url, self.config.index_name),
(B[m[32m+            )
(B[m[32m+            .header("Content-Type", "application/json")
(B[m[32m+            .json(&query)
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to list embeddings: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         if !response.status().is_success() {
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:459:
             error!("Failed to list embeddings: {} - {}", status, error_text);
[31m-            return Err(AgentMemError::storage_error(&format!("Failed to list embeddings: {}", error_text)));
(B[m[32m+            return Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Failed to list embeddings: {}",
(B[m[32m+                error_text
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[31m-        let search_response: ElasticsearchSearchResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(&format!("Failed to parse list response: {}", e)))?;
(B[m[31m-        
(B[m[31m-        let memory_ids: Vec<String> = search_response.hits.hits
(B[m[32m+
(B[m[32m+        let search_response: ElasticsearchSearchResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(&format!("Failed to parse list response: {}", e))
(B[m[32m+        })?;
(B[m[32m+
(B[m[32m+        let memory_ids: Vec<String> = search_response
(B[m[32m+            .hits
(B[m[32m+            .hits
(B[m             .into_iter()
             .map(|hit| hit.source.memory_id)
             .collect();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:470:
[31m-        
(B[m[32m+
(B[m         debug!("Found {} embeddings", memory_ids.len());
         Ok(memory_ids)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/elasticsearch.rs:495:
         let store = ElasticsearchStore::new(config);
         assert!(store.is_ok());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_config_default() {
         let config = ElasticsearchConfig::default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/lancedb.rs:1:
 //! LanceDB向量存储实现
 
[31m-use agent_mem_traits::{VectorStore, VectorStoreConfig, VectorData, VectorSearchResult, Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{
(B[m[32m+    AgentMemError, Result, VectorData, VectorSearchResult, VectorStore, VectorStoreConfig,
(B[m[32m+};
(B[m use async_trait::async_trait;
 
 /// LanceDB向量存储实现
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/lancedb.rs:13:
     pub async fn new(config: VectorStoreConfig) -> Result<Self> {
         // 验证配置
         if config.url.is_none() {
[31m-            return Err(AgentMemError::config_error("LanceDB database path is required"));
(B[m[32m+            return Err(AgentMemError::config_error(
(B[m[32m+                "LanceDB database path is required",
(B[m[32m+            ));
(B[m         }
 
         Ok(Self { config })
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/lancedb.rs:25:
     async fn add_vectors(&self, _vectors: Vec<VectorData>) -> Result<Vec<String>> {
         // LanceDB的实现
         // 这里提供一个基础框架，实际实现需要根据LanceDB的API规范
[31m-        Err(AgentMemError::llm_error("LanceDB provider not fully implemented yet"))
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "LanceDB provider not fully implemented yet",
(B[m[32m+        ))
(B[m     }
 
[31m-    async fn search_vectors(&self, _query_vector: Vec<f32>, _limit: usize, _threshold: Option<f32>) -> Result<Vec<VectorSearchResult>> {
(B[m[31m-        Err(AgentMemError::llm_error("LanceDB provider not fully implemented yet"))
(B[m[32m+    async fn search_vectors(
(B[m[32m+        &self,
(B[m[32m+        _query_vector: Vec<f32>,
(B[m[32m+        _limit: usize,
(B[m[32m+        _threshold: Option<f32>,
(B[m[32m+    ) -> Result<Vec<VectorSearchResult>> {
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "LanceDB provider not fully implemented yet",
(B[m[32m+        ))
(B[m     }
 
     async fn delete_vectors(&self, _ids: Vec<String>) -> Result<()> {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/lancedb.rs:36:
[31m-        Err(AgentMemError::llm_error("LanceDB provider not fully implemented yet"))
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "LanceDB provider not fully implemented yet",
(B[m[32m+        ))
(B[m     }
 
     async fn update_vectors(&self, _vectors: Vec<VectorData>) -> Result<()> {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/lancedb.rs:40:
[31m-        Err(AgentMemError::llm_error("LanceDB provider not fully implemented yet"))
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "LanceDB provider not fully implemented yet",
(B[m[32m+        ))
(B[m     }
 
     async fn get_vector(&self, _id: &str) -> Result<Option<VectorData>> {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/lancedb.rs:44:
[31m-        Err(AgentMemError::llm_error("LanceDB provider not fully implemented yet"))
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "LanceDB provider not fully implemented yet",
(B[m[32m+        ))
(B[m     }
 
     async fn count_vectors(&self) -> Result<usize> {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/lancedb.rs:48:
[31m-        Err(AgentMemError::llm_error("LanceDB provider not fully implemented yet"))
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "LanceDB provider not fully implemented yet",
(B[m[32m+        ))
(B[m     }
 
     async fn clear(&self) -> Result<()> {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/lancedb.rs:52:
[31m-        Err(AgentMemError::llm_error("LanceDB provider not fully implemented yet"))
(B[m[32m+        Err(AgentMemError::llm_error(
(B[m[32m+            "LanceDB provider not fully implemented yet",
(B[m[32m+        ))
(B[m     }
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:1:
 //! 内存向量存储实现
 
[31m-use agent_mem_traits::{VectorStore, VectorStoreConfig, VectorData, VectorSearchResult, Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{
(B[m[32m+    AgentMemError, Result, VectorData, VectorSearchResult, VectorStore, VectorStoreConfig,
(B[m[32m+};
(B[m use async_trait::async_trait;
 use dashmap::DashMap;
 use std::sync::Arc;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:55:
 impl VectorStore for MemoryVectorStore {
     async fn add_vectors(&self, vectors: Vec<VectorData>) -> Result<Vec<String>> {
         let mut ids = Vec::new();
[31m-        
(B[m[32m+
(B[m         for vector in vectors {
             // 验证向量维度
             if let Some(expected_dim) = self.config.dimension {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:72:
             self.vectors.insert(id.clone(), vector);
             ids.push(id);
         }
[31m-        
(B[m[32m+
(B[m         Ok(ids)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:79:
[31m-    async fn search_vectors(&self, query_vector: Vec<f32>, limit: usize, threshold: Option<f32>) -> Result<Vec<VectorSearchResult>> {
(B[m[32m+    async fn search_vectors(
(B[m[32m+        &self,
(B[m[32m+        query_vector: Vec<f32>,
(B[m[32m+        limit: usize,
(B[m[32m+        threshold: Option<f32>,
(B[m[32m+    ) -> Result<Vec<VectorSearchResult>> {
(B[m         let mut results = Vec::new();
[31m-        
(B[m[32m+
(B[m         // 验证查询向量维度
         if let Some(expected_dim) = self.config.dimension {
             if query_vector.len() != expected_dim {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:92:
 
         for entry in self.vectors.iter() {
             let vector_data = entry.value();
[31m-            
(B[m[32m+
(B[m             // 计算相似度和距离
             let similarity = self.cosine_similarity(&query_vector, &vector_data.vector);
             let distance = self.euclidean_distance(&query_vector, &vector_data.vector);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:99:
[31m-            
(B[m[32m+
(B[m             // 应用阈值过滤
             if let Some(threshold) = threshold {
                 if similarity < threshold {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:103:
                     continue;
                 }
             }
[31m-            
(B[m[32m+
(B[m             results.push(VectorSearchResult {
                 id: vector_data.id.clone(),
                 vector: vector_data.vector.clone(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:112:
                 distance,
             });
         }
[31m-        
(B[m[32m+
(B[m         // 按相似度排序（降序）
[31m-        results.sort_by(|a, b| b.similarity.partial_cmp(&a.similarity).unwrap_or(std::cmp::Ordering::Equal));
(B[m[31m-        
(B[m[32m+        results.sort_by(|a, b| {
(B[m[32m+            b.similarity
(B[m[32m+                .partial_cmp(&a.similarity)
(B[m[32m+                .unwrap_or(std::cmp::Ordering::Equal)
(B[m[32m+        });
(B[m[32m+
(B[m         // 限制结果数量
         results.truncate(limit);
[31m-        
(B[m[32m+
(B[m         Ok(results)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:146:
             if self.vectors.contains_key(&id) {
                 self.vectors.insert(id, vector);
             } else {
[31m-                return Err(AgentMemError::not_found(&format!("Vector with id {} not found", id)));
(B[m[32m+                return Err(AgentMemError::not_found(&format!(
(B[m[32m+                    "Vector with id {} not found",
(B[m[32m+                    id
(B[m[32m+                )));
(B[m             }
         }
         Ok(())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:191:
     #[tokio::test]
     async fn test_add_and_get_vectors() {
         let store = create_test_store().await;
[31m-        
(B[m[32m+
(B[m         let vectors = vec![
             create_test_vector("1", vec![1.0, 0.0, 0.0]),
             create_test_vector("2", vec![0.0, 1.0, 0.0]),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:198:
         ];
[31m-        
(B[m[32m+
(B[m         let ids = store.add_vectors(vectors).await.unwrap();
         assert_eq!(ids.len(), 2);
[31m-        
(B[m[32m+
(B[m         let vector = store.get_vector("1").await.unwrap();
         assert!(vector.is_some());
         assert_eq!(vector.unwrap().vector, vec![1.0, 0.0, 0.0]);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:208:
     #[tokio::test]
     async fn test_search_vectors() {
         let store = create_test_store().await;
[31m-        
(B[m[32m+
(B[m         let vectors = vec![
             create_test_vector("1", vec![1.0, 0.0, 0.0]),
             create_test_vector("2", vec![0.0, 1.0, 0.0]),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:215:
             create_test_vector("3", vec![0.0, 0.0, 1.0]),
         ];
[31m-        
(B[m[32m+
(B[m         store.add_vectors(vectors).await.unwrap();
[31m-        
(B[m[32m+
(B[m         // 搜索与第一个向量相似的向量
[31m-        let results = store.search_vectors(vec![1.0, 0.0, 0.0], 2, None).await.unwrap();
(B[m[32m+        let results = store
(B[m[32m+            .search_vectors(vec![1.0, 0.0, 0.0], 2, None)
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m         assert_eq!(results.len(), 2);
         assert_eq!(results[0].id, "1");
         assert_eq!(results[0].similarity, 1.0); // 完全匹配
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:227:
     #[tokio::test]
     async fn test_delete_vectors() {
         let store = create_test_store().await;
[31m-        
(B[m[32m+
(B[m         let vectors = vec![
             create_test_vector("1", vec![1.0, 0.0, 0.0]),
             create_test_vector("2", vec![0.0, 1.0, 0.0]),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:234:
         ];
[31m-        
(B[m[32m+
(B[m         store.add_vectors(vectors).await.unwrap();
         assert_eq!(store.count_vectors().await.unwrap(), 2);
[31m-        
(B[m[32m+
(B[m         store.delete_vectors(vec!["1".to_string()]).await.unwrap();
         assert_eq!(store.count_vectors().await.unwrap(), 1);
[31m-        
(B[m[32m+
(B[m         let vector = store.get_vector("1").await.unwrap();
         assert!(vector.is_none());
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:246:
     #[tokio::test]
     async fn test_update_vectors() {
         let store = create_test_store().await;
[31m-        
(B[m[32m+
(B[m         let vectors = vec![create_test_vector("1", vec![1.0, 0.0, 0.0])];
         store.add_vectors(vectors).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let updated_vectors = vec![create_test_vector("1", vec![0.0, 1.0, 0.0])];
         store.update_vectors(updated_vectors).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let vector = store.get_vector("1").await.unwrap().unwrap();
         assert_eq!(vector.vector, vec![0.0, 1.0, 0.0]);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:260:
     #[tokio::test]
     async fn test_clear() {
         let store = create_test_store().await;
[31m-        
(B[m[32m+
(B[m         let vectors = vec![
             create_test_vector("1", vec![1.0, 0.0, 0.0]),
             create_test_vector("2", vec![0.0, 1.0, 0.0]),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:267:
         ];
[31m-        
(B[m[32m+
(B[m         store.add_vectors(vectors).await.unwrap();
         assert_eq!(store.count_vectors().await.unwrap(), 2);
[31m-        
(B[m[32m+
(B[m         store.clear().await.unwrap();
         assert_eq!(store.count_vectors().await.unwrap(), 0);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:276:
     #[tokio::test]
     async fn test_dimension_validation() {
         let store = create_test_store().await;
[31m-        
(B[m[32m+
(B[m         // 尝试添加错误维度的向量
         let vectors = vec![create_test_vector("1", vec![1.0, 0.0])]; // 2维而不是3维
         let result = store.add_vectors(vectors).await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:286:
     #[tokio::test]
     async fn test_cosine_similarity() {
         let store = create_test_store().await;
[31m-        
(B[m[32m+
(B[m         // 测试余弦相似度计算
         let sim = store.cosine_similarity(&[1.0, 0.0, 0.0], &[1.0, 0.0, 0.0]);
         assert_eq!(sim, 1.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/memory.rs:293:
[31m-        
(B[m[32m+
(B[m         let sim = store.cosine_similarity(&[1.0, 0.0, 0.0], &[0.0, 1.0, 0.0]);
         assert_eq!(sim, 0.0);
[31m-        
(B[m[32m+
(B[m         let sim = store.cosine_similarity(&[1.0, 0.0, 0.0], &[-1.0, 0.0, 0.0]);
         assert_eq!(sim, -1.0);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:1:
 //! Milvus vector database backend implementation
[31m-//! 
(B[m[32m+//!
(B[m //! Provides integration with Milvus vector database for high-performance
 //! vector similarity search and storage.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError, EmbeddingVectorStore, SearchResult};
(B[m[32m+use agent_mem_traits::{AgentMemError, EmbeddingVectorStore, Result, SearchResult};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:145:
         let client = Client::builder()
             .timeout(std::time::Duration::from_secs(config.timeout_seconds))
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         Ok(Self { config, client })
     }
[31m-    
(B[m[32m+
(B[m     /// Initialize the Milvus collection
     pub async fn initialize_collection(&self) -> Result<()> {
[31m-        info!("Initializing Milvus collection: {}", self.config.collection_name);
(B[m[31m-        
(B[m[32m+        info!(
(B[m[32m+            "Initializing Milvus collection: {}",
(B[m[32m+            self.config.collection_name
(B[m[32m+        );
(B[m[32m+
(B[m         // Check if collection exists
         let exists = self.collection_exists().await?;
         if exists {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:160:
             info!("Collection {} already exists", self.config.collection_name);
             return Ok(());
         }
[31m-        
(B[m[32m+
(B[m         // Create collection schema
         let schema = MilvusCollectionSchema {
             name: self.config.collection_name.clone(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:204:
                 },
             ],
         };
[31m-        
(B[m[32m+
(B[m         let create_request = serde_json::json!({
             "collection_name": self.config.collection_name,
             "schema": schema
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:211:
         });
[31m-        
(B[m[31m-        let response = self.client
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&format!("{}/v1/collection", self.config.url))
             .header("Content-Type", "application/json")
             .json(&create_request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:217:
             .send()
             .await
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to create collection: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to create collection: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         if response.status().is_success() {
             info!("Milvus collection created successfully");
[31m-            
(B[m[32m+
(B[m             // Create index
             self.create_index().await?;
[31m-            
(B[m[32m+
(B[m             Ok(())
         } else {
             let status = response.status();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:230:
             let error_text = response.text().await.unwrap_or_default();
             error!("Failed to create collection: {} - {}", status, error_text);
[31m-            Err(AgentMemError::storage_error(&format!("Collection creation failed: {}", error_text)))
(B[m[32m+            Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Collection creation failed: {}",
(B[m[32m+                error_text
(B[m[32m+            )))
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     /// Check if collection exists
     async fn collection_exists(&self) -> Result<bool> {
[31m-        let response = self.client
(B[m[31m-            .get(&format!("{}/v1/collection/{}", self.config.url, self.config.collection_name))
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m[32m+            .get(&format!(
(B[m[32m+                "{}/v1/collection/{}",
(B[m[32m+                self.config.url, self.config.collection_name
(B[m[32m+            ))
(B[m             .send()
             .await
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to check collection: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to check collection: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         Ok(response.status().is_success())
     }
[31m-    
(B[m[32m+
(B[m     /// Create index for the collection
     async fn create_index(&self) -> Result<()> {
[31m-        info!("Creating index for collection: {}", self.config.collection_name);
(B[m[31m-        
(B[m[32m+        info!(
(B[m[32m+            "Creating index for collection: {}",
(B[m[32m+            self.config.collection_name
(B[m[32m+        );
(B[m[32m+
(B[m         let index_request = serde_json::json!({
             "collection_name": self.config.collection_name,
             "field_name": "embedding",
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:259:
                 "efConstruction": 200
             }
         });
[31m-        
(B[m[31m-        let response = self.client
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&format!("{}/v1/index", self.config.url))
             .header("Content-Type", "application/json")
             .json(&index_request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:267:
             .send()
             .await
             .map_err(|e| AgentMemError::network_error(&format!("Failed to create index: {}", e)))?;
[31m-        
(B[m[32m+
(B[m         if response.status().is_success() {
             info!("Index created successfully");
             Ok(())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:290:
         metadata: &HashMap<String, String>,
     ) -> Result<()> {
         debug!("Storing embedding for memory: {}", memory_id);
[31m-        
(B[m[32m+
(B[m         let entity = MilvusEntity {
             memory_id: memory_id.to_string(),
             embedding: embedding.to_vec(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:299:
             user_id: metadata.get("user_id").unwrap_or(&String::new()).clone(),
             created_at: chrono::Utc::now().timestamp(),
         };
[31m-        
(B[m[32m+
(B[m         let insert_request = serde_json::json!({
             "collection_name": self.config.collection_name,
             "fields_data": [
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:359:
                 }
             ]
         });
[31m-        
(B[m[31m-        let response = self.client
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&format!("{}/v1/entities", self.config.url))
             .header("Content-Type", "application/json")
             .json(&insert_request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:367:
             .send()
             .await
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to store embedding: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to store embedding: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         if response.status().is_success() {
             debug!("Successfully stored embedding for memory: {}", memory_id);
             Ok(())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:375:
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
             error!("Failed to store embedding: {} - {}", status, error_text);
[31m-            Err(AgentMemError::storage_error(&format!("Failed to store embedding: {}", error_text)))
(B[m[32m+            Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Failed to store embedding: {}",
(B[m[32m+                error_text
(B[m[32m+            )))
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     async fn search_similar(
         &self,
         query_embedding: &[f32],
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:386:
         threshold: Option<f32>,
     ) -> Result<Vec<SearchResult>> {
         debug!("Searching for similar embeddings with limit: {}", limit);
[31m-        
(B[m[32m+
(B[m         let search_request = MilvusSearchRequest {
             collection_name: self.config.collection_name.clone(),
             vectors: vec![query_embedding.to_vec()],
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:394:
             metric_type: self.config.metric_type.clone(),
             params: {
                 let mut params = HashMap::new();
[31m-                params.insert("ef".to_string(), serde_json::Value::Number(serde_json::Number::from(64)));
(B[m[32m+                params.insert(
(B[m[32m+                    "ef".to_string(),
(B[m[32m+                    serde_json::Value::Number(serde_json::Number::from(64)),
(B[m[32m+                );
(B[m                 params
             },
             output_fields: vec![
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:404:
                 "user_id".to_string(),
             ],
         };
[31m-        
(B[m[31m-        let response = self.client
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&format!("{}/v1/search", self.config.url))
             .header("Content-Type", "application/json")
             .json(&search_request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:412:
             .send()
             .await
             .map_err(|e| AgentMemError::network_error(&format!("Failed to search: {}", e)))?;
[31m-        
(B[m[32m+
(B[m         if !response.status().is_success() {
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:419:
             error!("Search failed: {} - {}", status, error_text);
[31m-            return Err(AgentMemError::storage_error(&format!("Search failed: {}", error_text)));
(B[m[32m+            return Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Search failed: {}",
(B[m[32m+                error_text
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[31m-        let search_response: MilvusSearchResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(&format!("Failed to parse search response: {}", e)))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let search_response: MilvusSearchResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(&format!("Failed to parse search response: {}", e))
(B[m[32m+        })?;
(B[m[32m+
(B[m         if search_response.status.error_code != 0 {
             error!("Milvus search error: {}", search_response.status.reason);
[31m-            return Err(AgentMemError::storage_error(&format!("Milvus error: {}", search_response.status.reason)));
(B[m[32m+            return Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Milvus error: {}",
(B[m[32m+                search_response.status.reason
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[32m+
(B[m         let mut results = Vec::new();
[31m-        
(B[m[32m+
(B[m         for result in search_response.results {
             for (i, memory_id) in result.ids.iter().enumerate() {
                 let score = result.scores.get(i).copied().unwrap_or(0.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:436:
[31m-                
(B[m[32m+
(B[m                 // Apply threshold filter
                 if let Some(threshold) = threshold {
                     if score < threshold {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:440:
                         continue;
                     }
                 }
[31m-                
(B[m[32m+
(B[m                 let mut metadata = HashMap::new();
 
                 // Extract field data
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:448:
                     if let Some(scalars) = &field_data.scalars {
                         if let Some(string_data) = &scalars.string_data {
                             if let Some(value) = string_data.data.get(i) {
[31m-                                metadata.insert(field_data.field_name.clone(), serde_json::Value::String(value.clone()));
(B[m[32m+                                metadata.insert(
(B[m[32m+                                    field_data.field_name.clone(),
(B[m[32m+                                    serde_json::Value::String(value.clone()),
(B[m[32m+                                );
(B[m                             }
                         }
                     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:461:
                 });
             }
         }
[31m-        
(B[m[32m+
(B[m         debug!("Found {} similar embeddings", results.len());
         Ok(results)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:468:
[31m-    
(B[m[32m+
(B[m     async fn delete_embedding(&self, memory_id: &str) -> Result<()> {
         debug!("Deleting embedding for memory: {}", memory_id);
[31m-        
(B[m[32m+
(B[m         let delete_request = serde_json::json!({
             "collection_name": self.config.collection_name,
             "expr": format!("memory_id == \"{}\"", memory_id)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:475:
         });
[31m-        
(B[m[31m-        let response = self.client
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .delete(&format!("{}/v1/entities", self.config.url))
             .header("Content-Type", "application/json")
             .json(&delete_request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:481:
             .send()
             .await
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to delete embedding: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to delete embedding: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         if response.status().is_success() {
             debug!("Successfully deleted embedding for memory: {}", memory_id);
             Ok(())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:489:
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
             error!("Failed to delete embedding: {} - {}", status, error_text);
[31m-            Err(AgentMemError::storage_error(&format!("Failed to delete embedding: {}", error_text)))
(B[m[32m+            Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Failed to delete embedding: {}",
(B[m[32m+                error_text
(B[m[32m+            )))
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     async fn update_embedding(
         &self,
         memory_id: &str,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:500:
         metadata: &HashMap<String, String>,
     ) -> Result<()> {
         debug!("Updating embedding for memory: {}", memory_id);
[31m-        
(B[m[32m+
(B[m         // Delete existing and insert new (Milvus doesn't have direct update)
         self.delete_embedding(memory_id).await?;
         self.store_embedding(memory_id, embedding, metadata).await
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:507:
     }
[31m-    
(B[m[32m+
(B[m     async fn get_embedding(&self, memory_id: &str) -> Result<Option<Vec<f32>>> {
         debug!("Getting embedding for memory: {}", memory_id);
[31m-        
(B[m[32m+
(B[m         let query_request = serde_json::json!({
             "collection_name": self.config.collection_name,
             "expr": format!("memory_id == \"{}\"", memory_id),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:515:
             "output_fields": ["embedding"]
         });
[31m-        
(B[m[31m-        let response = self.client
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&format!("{}/v1/query", self.config.url))
             .header("Content-Type", "application/json")
             .json(&query_request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:522:
             .send()
             .await
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to get embedding: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to get embedding: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         if response.status().is_success() {
             // Parse response and extract embedding
             // This is a simplified implementation
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:533:
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
             error!("Failed to get embedding: {} - {}", status, error_text);
[31m-            Err(AgentMemError::storage_error(&format!("Failed to get embedding: {}", error_text)))
(B[m[32m+            Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Failed to get embedding: {}",
(B[m[32m+                error_text
(B[m[32m+            )))
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     async fn list_embeddings(&self, prefix: Option<&str>) -> Result<Vec<String>> {
         debug!("Listing embeddings with prefix: {:?}", prefix);
[31m-        
(B[m[32m+
(B[m         let expr = if let Some(prefix) = prefix {
             format!("memory_id like \"{}%\"", prefix)
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:546:
             "memory_id != \"\"".to_string()
         };
[31m-        
(B[m[32m+
(B[m         let query_request = serde_json::json!({
             "collection_name": self.config.collection_name,
             "expr": expr,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:552:
             "output_fields": ["memory_id"]
         });
[31m-        
(B[m[31m-        let response = self.client
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&format!("{}/v1/query", self.config.url))
             .header("Content-Type", "application/json")
             .json(&query_request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:559:
             .send()
             .await
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to list embeddings: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to list embeddings: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         if response.status().is_success() {
             // Parse response and extract memory IDs
             // This is a simplified implementation
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:568:
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
             error!("Failed to list embeddings: {} - {}", status, error_text);
[31m-            Err(AgentMemError::storage_error(&format!("Failed to list embeddings: {}", error_text)))
(B[m[32m+            Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Failed to list embeddings: {}",
(B[m[32m+                error_text
(B[m[32m+            )))
(B[m         }
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/milvus.rs:595:
         let store = MilvusStore::new(config);
         assert!(store.is_ok());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_config_default() {
         let config = MilvusConfig::default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/mod.rs:1:
 //! 存储后端实现模块
 
[31m-pub mod memory;
(B[m pub mod chroma;
[32m+pub mod elasticsearch;
(B[m pub mod lancedb;
[31m-pub mod qdrant;
(B[m[32m+pub mod memory;
(B[m[32m+pub mod milvus;
(B[m pub mod pinecone;
[32m+pub mod qdrant;
(B[m pub mod weaviate;
[31m-pub mod milvus;
(B[m[31m-pub mod elasticsearch;
(B[m 
[31m-pub use memory::MemoryVectorStore;
(B[m pub use chroma::ChromaStore;
[32m+pub use elasticsearch::ElasticsearchStore;
(B[m pub use lancedb::LanceDBStore;
[31m-pub use qdrant::QdrantStore;
(B[m[32m+pub use memory::MemoryVectorStore;
(B[m[32m+pub use milvus::MilvusStore;
(B[m pub use pinecone::PineconeStore;
[32m+pub use qdrant::QdrantStore;
(B[m pub use weaviate::WeaviateStore;
[31m-pub use milvus::MilvusStore;
(B[m[31m-pub use elasticsearch::ElasticsearchStore;
(B[m 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:1:
 //! Pinecone向量存储实现
 
[31m-use agent_mem_traits::{VectorStore, VectorStoreConfig, VectorData, VectorSearchResult, Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{
(B[m[32m+    AgentMemError, Result, VectorData, VectorSearchResult, VectorStore, VectorStoreConfig,
(B[m[32m+};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:84:
 impl PineconeStore {
     /// 创建新的Pinecone存储实例
     pub async fn new(config: VectorStoreConfig) -> Result<Self> {
[31m-        let api_key = config.api_key.clone()
(B[m[32m+        let api_key = config
(B[m[32m+            .api_key
(B[m[32m+            .clone()
(B[m             .ok_or_else(|| AgentMemError::config_error("Pinecone API key is required"))?;
 
[31m-        let index_name = config.index_name.clone()
(B[m[32m+        let index_name = config
(B[m[32m+            .index_name
(B[m[32m+            .clone()
(B[m             .ok_or_else(|| AgentMemError::config_error("Pinecone index name is required"))?;
 
         // 构建基础URL
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:95:
             url.clone()
         } else {
             // 默认使用Pinecone的标准URL格式
[31m-            format!("https://{}-{}.svc.{}.pinecone.io", 
(B[m[31m-                    index_name, 
(B[m[31m-                    "default", // 项目ID，实际使用时需要配置
(B[m[31m-                    "us-east1-gcp") // 区域，实际使用时需要配置
(B[m[32m+            format!(
(B[m[32m+                "https://{}-{}.svc.{}.pinecone.io",
(B[m[32m+                index_name,
(B[m[32m+                "default", // 项目ID，实际使用时需要配置
(B[m[32m+                "us-east1-gcp"
(B[m[32m+            ) // 区域，实际使用时需要配置
(B[m         };
 
         let client = Client::builder()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:105:
             .timeout(Duration::from_secs(30))
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(format!("Failed to create HTTP client: {}", e)))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m 
         Ok(Self {
             config,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:135:
         let metadata = if data.metadata.is_empty() {
             None
         } else {
[31m-            Some(data.metadata.iter()
(B[m[31m-                .map(|(k, v)| (k.clone(), serde_json::Value::String(v.clone())))
(B[m[31m-                .collect())
(B[m[32m+            Some(
(B[m[32m+                data.metadata
(B[m[32m+                    .iter()
(B[m[32m+                    .map(|(k, v)| (k.clone(), serde_json::Value::String(v.clone())))
(B[m[32m+                    .collect(),
(B[m[32m+            )
(B[m         };
 
         PineconeVector {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:149:
 
     /// 转换PineconeMatch到VectorSearchResult
     fn from_pinecone_match(&self, pinecone_match: PineconeMatch) -> VectorSearchResult {
[31m-        let metadata = pinecone_match.metadata.iter()
(B[m[32m+        let metadata = pinecone_match
(B[m[32m+            .metadata
(B[m[32m+            .iter()
(B[m             .filter_map(|(k, v)| {
                 if let serde_json::Value::String(s) = v {
                     Some((k.clone(), s.clone()))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:176:
             return Ok(Vec::new());
         }
 
[31m-        let pinecone_vectors: Vec<PineconeVector> = vectors.iter()
(B[m[31m-            .map(|v| self.to_pinecone_vector(v))
(B[m[31m-            .collect();
(B[m[32m+        let pinecone_vectors: Vec<PineconeVector> =
(B[m[32m+            vectors.iter().map(|v| self.to_pinecone_vector(v)).collect();
(B[m 
         let request = PineconeUpsertRequest {
             vectors: pinecone_vectors,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:186:
         };
 
         let url = format!("{}/vectors/upsert", self.base_url);
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .headers(self.get_headers())
             .json(&request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:196:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Pinecone API error {}: {}", status, error_text
(B[m[32m+                "Pinecone API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:207:
         Ok(vectors.iter().map(|v| v.id.clone()).collect())
     }
 
[31m-    async fn search_vectors(&self, query_vector: Vec<f32>, limit: usize, threshold: Option<f32>) -> Result<Vec<VectorSearchResult>> {
(B[m[32m+    async fn search_vectors(
(B[m[32m+        &self,
(B[m[32m+        query_vector: Vec<f32>,
(B[m[32m+        limit: usize,
(B[m[32m+        threshold: Option<f32>,
(B[m[32m+    ) -> Result<Vec<VectorSearchResult>> {
(B[m         let request = PineconeQueryRequest {
             vector: query_vector,
             top_k: limit,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:217:
         };
 
         let url = format!("{}/query", self.base_url);
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .headers(self.get_headers())
             .json(&request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:227:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Pinecone API error {}: {}", status, error_text
(B[m[32m+                "Pinecone API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:237:
[31m-        let query_response: PineconeQueryResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let query_response: PineconeQueryResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
[31m-        let mut results: Vec<VectorSearchResult> = query_response.matches
(B[m[32m+        let mut results: Vec<VectorSearchResult> = query_response
(B[m[32m+            .matches
(B[m             .into_iter()
             .map(|m| self.from_pinecone_match(m))
             .collect();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:261:
         };
 
         let url = format!("{}/vectors/delete", self.base_url);
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .headers(self.get_headers())
             .json(&request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:271:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Pinecone API error {}: {}", status, error_text
(B[m[32m+                "Pinecone API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:295:
             "namespace": self.namespace
         });
 
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .headers(self.get_headers())
             .json(&request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:305:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Pinecone API error {}: {}", status, error_text
(B[m[32m+                "Pinecone API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:315:
[31m-        let fetch_response: serde_json::Value = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let fetch_response: serde_json::Value = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         if let Some(vectors) = fetch_response.get("vectors") {
             if let Some(vector_data) = vectors.get(id) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:320:
                 if let (Some(values), Some(metadata)) = (
                     vector_data.get("values").and_then(|v| v.as_array()),
[31m-                    vector_data.get("metadata").and_then(|m| m.as_object())
(B[m[32m+                    vector_data.get("metadata").and_then(|m| m.as_object()),
(B[m                 ) {
[31m-                    let vector: Vec<f32> = values.iter()
(B[m[32m+                    let vector: Vec<f32> = values
(B[m[32m+                        .iter()
(B[m                         .filter_map(|v| v.as_f64().map(|f| f as f32))
                         .collect();
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:328:
[31m-                    let metadata_map: HashMap<String, String> = metadata.iter()
(B[m[32m+                    let metadata_map: HashMap<String, String> = metadata
(B[m[32m+                        .iter()
(B[m                         .filter_map(|(k, v)| {
                             if let serde_json::Value::String(s) = v {
                                 Some((k.clone(), s.clone()))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:349:
 
     async fn count_vectors(&self) -> Result<usize> {
         let url = format!("{}/describe_index_stats", self.base_url);
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .headers(self.get_headers())
             .json(&serde_json::json!({}))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:359:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Pinecone API error {}: {}", status, error_text
(B[m[32m+                "Pinecone API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:369:
[31m-        let stats: PineconeStatsResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let stats: PineconeStatsResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         Ok(stats.total_vector_count)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:376:
         // Pinecone没有直接的清空操作，需要删除所有向量
         // 这里返回错误，建议用户手动删除索引
         Err(AgentMemError::storage_error(
[31m-            "Pinecone does not support clear operation. Please delete the index manually."
(B[m[32m+            "Pinecone does not support clear operation. Please delete the index manually.",
(B[m         ))
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/pinecone.rs:474:
         let store = rt.block_on(PineconeStore::new(config)).unwrap();
 
         let mut metadata = HashMap::new();
[31m-        metadata.insert("key1".to_string(), serde_json::Value::String("value1".to_string()));
(B[m[32m+        metadata.insert(
(B[m[32m+            "key1".to_string(),
(B[m[32m+            serde_json::Value::String("value1".to_string()),
(B[m[32m+        );
(B[m 
         let pinecone_match = PineconeMatch {
             id: "test-id".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:1:
 //! Qdrant向量存储实现
 
[31m-use agent_mem_traits::{VectorStore, VectorStoreConfig, VectorData, VectorSearchResult, Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{
(B[m[32m+    AgentMemError, Result, VectorData, VectorSearchResult, VectorStore, VectorStoreConfig,
(B[m[32m+};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:88:
 impl QdrantStore {
     /// 创建新的Qdrant存储实例
     pub async fn new(config: VectorStoreConfig) -> Result<Self> {
[31m-        let base_url = config.url.clone()
(B[m[32m+        let base_url = config
(B[m[32m+            .url
(B[m[32m+            .clone()
(B[m             .unwrap_or_else(|| "http://localhost:6333".to_string());
 
[31m-        let collection_name = config.collection_name.clone()
(B[m[32m+        let collection_name = config
(B[m[32m+            .collection_name
(B[m[32m+            .clone()
(B[m             .or_else(|| Some(config.table_name.clone()))
             .unwrap_or_else(|| "memories".to_string());
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:98:
         let client = Client::builder()
             .timeout(Duration::from_secs(30))
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(format!("Failed to create HTTP client: {}", e)))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m 
         let store = Self {
             config,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:134:
     /// 创建集合
     async fn create_collection(&self) -> Result<()> {
         let dimension = self.config.dimension.unwrap_or(1536);
[31m-        
(B[m[32m+
(B[m         let create_request = serde_json::json!({
             "vectors": {
                 "size": dimension,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:143:
         });
 
         let url = format!("{}/collections/{}", self.base_url, self.collection_name);
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .put(&url)
             .header("Content-Type", "application/json")
             .json(&create_request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:153:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Qdrant API error {}: {}", status, error_text
(B[m[32m+                "Qdrant API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:168:
         let payload = if data.metadata.is_empty() {
             None
         } else {
[31m-            Some(data.metadata.iter()
(B[m[31m-                .map(|(k, v)| (k.clone(), serde_json::Value::String(v.clone())))
(B[m[31m-                .collect())
(B[m[32m+            Some(
(B[m[32m+                data.metadata
(B[m[32m+                    .iter()
(B[m[32m+                    .map(|(k, v)| (k.clone(), serde_json::Value::String(v.clone())))
(B[m[32m+                    .collect(),
(B[m[32m+            )
(B[m         };
 
         QdrantPoint {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:187:
             QdrantPointId::Number(n) => n.to_string(),
         };
 
[31m-        let metadata = qdrant_result.payload.iter()
(B[m[32m+        let metadata = qdrant_result
(B[m[32m+            .payload
(B[m[32m+            .iter()
(B[m             .filter_map(|(k, v)| {
                 if let serde_json::Value::String(s) = v {
                     Some((k.clone(), s.clone()))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:214:
             return Ok(Vec::new());
         }
 
[31m-        let qdrant_points: Vec<QdrantPoint> = vectors.iter()
(B[m[31m-            .map(|v| self.to_qdrant_point(v))
(B[m[31m-            .collect();
(B[m[32m+        let qdrant_points: Vec<QdrantPoint> =
(B[m[32m+            vectors.iter().map(|v| self.to_qdrant_point(v)).collect();
(B[m 
         let request = QdrantUpsertRequest {
             points: qdrant_points,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:223:
         };
 
[31m-        let url = format!("{}/collections/{}/points", self.base_url, self.collection_name);
(B[m[31m-        let response = self.client
(B[m[32m+        let url = format!(
(B[m[32m+            "{}/collections/{}/points",
(B[m[32m+            self.base_url, self.collection_name
(B[m[32m+        );
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .put(&url)
             .header("Content-Type", "application/json")
             .json(&request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:233:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Qdrant API error {}: {}", status, error_text
(B[m[32m+                "Qdrant API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:244:
         Ok(vectors.iter().map(|v| v.id.clone()).collect())
     }
 
[31m-    async fn search_vectors(&self, query_vector: Vec<f32>, limit: usize, threshold: Option<f32>) -> Result<Vec<VectorSearchResult>> {
(B[m[32m+    async fn search_vectors(
(B[m[32m+        &self,
(B[m[32m+        query_vector: Vec<f32>,
(B[m[32m+        limit: usize,
(B[m[32m+        threshold: Option<f32>,
(B[m[32m+    ) -> Result<Vec<VectorSearchResult>> {
(B[m         let request = QdrantSearchRequest {
             vector: query_vector,
             limit,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:253:
             with_vector: true,
         };
 
[31m-        let url = format!("{}/collections/{}/points/search", self.base_url, self.collection_name);
(B[m[31m-        let response = self.client
(B[m[32m+        let url = format!(
(B[m[32m+            "{}/collections/{}/points/search",
(B[m[32m+            self.base_url, self.collection_name
(B[m[32m+        );
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Content-Type", "application/json")
             .json(&request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:264:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Qdrant API error {}: {}", status, error_text
(B[m[32m+                "Qdrant API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:274:
[31m-        let search_response: QdrantSearchResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let search_response: QdrantSearchResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
[31m-        let results: Vec<VectorSearchResult> = search_response.result
(B[m[32m+        let results: Vec<VectorSearchResult> = search_response
(B[m[32m+            .result
(B[m             .into_iter()
             .map(|r| self.from_qdrant_result(r))
             .collect();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:287:
             return Ok(());
         }
 
[31m-        let qdrant_ids: Vec<QdrantPointId> = ids.into_iter()
(B[m[31m-            .map(QdrantPointId::String)
(B[m[31m-            .collect();
(B[m[32m+        let qdrant_ids: Vec<QdrantPointId> = ids.into_iter().map(QdrantPointId::String).collect();
(B[m 
[31m-        let request = QdrantDeleteRequest {
(B[m[31m-            points: qdrant_ids,
(B[m[31m-        };
(B[m[32m+        let request = QdrantDeleteRequest { points: qdrant_ids };
(B[m 
[31m-        let url = format!("{}/collections/{}/points/delete", self.base_url, self.collection_name);
(B[m[31m-        let response = self.client
(B[m[32m+        let url = format!(
(B[m[32m+            "{}/collections/{}/points/delete",
(B[m[32m+            self.base_url, self.collection_name
(B[m[32m+        );
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Content-Type", "application/json")
             .json(&request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:306:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Qdrant API error {}: {}", status, error_text
(B[m[32m+                "Qdrant API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:323:
     }
 
     async fn get_vector(&self, id: &str) -> Result<Option<VectorData>> {
[31m-        let url = format!("{}/collections/{}/points/{}", self.base_url, self.collection_name, id);
(B[m[31m-        let response = self.client
(B[m[32m+        let url = format!(
(B[m[32m+            "{}/collections/{}/points/{}",
(B[m[32m+            self.base_url, self.collection_name, id
(B[m[32m+        );
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .get(&url)
             .send()
             .await
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:336:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Qdrant API error {}: {}", status, error_text
(B[m[32m+                "Qdrant API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:346:
[31m-        let point_response: serde_json::Value = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let point_response: serde_json::Value = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         if let Some(result) = point_response.get("result") {
             if let (Some(vector), Some(payload)) = (
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:351:
                 result.get("vector").and_then(|v| v.as_array()),
[31m-                result.get("payload").and_then(|p| p.as_object())
(B[m[32m+                result.get("payload").and_then(|p| p.as_object()),
(B[m             ) {
[31m-                let vector_data: Vec<f32> = vector.iter()
(B[m[32m+                let vector_data: Vec<f32> = vector
(B[m[32m+                    .iter()
(B[m                     .filter_map(|v| v.as_f64().map(|f| f as f32))
                     .collect();
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:358:
[31m-                let metadata: HashMap<String, String> = payload.iter()
(B[m[32m+                let metadata: HashMap<String, String> = payload
(B[m[32m+                    .iter()
(B[m                     .filter_map(|(k, v)| {
                         if let serde_json::Value::String(s) = v {
                             Some((k.clone(), s.clone()))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:378:
 
     async fn count_vectors(&self) -> Result<usize> {
         let url = format!("{}/collections/{}", self.base_url, self.collection_name);
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .get(&url)
             .send()
             .await
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:386:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Qdrant API error {}: {}", status, error_text
(B[m[32m+                "Qdrant API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:396:
[31m-        let info: QdrantCollectionInfo = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let info: QdrantCollectionInfo = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         Ok(info.result.points_count)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:402:
     async fn clear(&self) -> Result<()> {
         // 删除并重新创建集合
         let url = format!("{}/collections/{}", self.base_url, self.collection_name);
[31m-        let response = self.client
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .delete(&url)
             .send()
             .await
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/qdrant.rs:410:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Qdrant API error {}: {}", status, error_text
(B[m[32m+                "Qdrant API error {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:1:
 //! Weaviate vector database backend implementation
[31m-//! 
(B[m[32m+//!
(B[m //! Provides integration with Weaviate vector database for storing
 //! and retrieving memory embeddings with semantic search capabilities.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:6:
[31m-use agent_mem_traits::{Result, AgentMemError, EmbeddingVectorStore, SearchResult};
(B[m[32m+use agent_mem_traits::{AgentMemError, EmbeddingVectorStore, Result, SearchResult};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:105:
         let client = Client::builder()
             .timeout(std::time::Duration::from_secs(config.timeout_seconds))
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e)))?;
(B[m[31m-        
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         Ok(Self { config, client })
     }
[31m-    
(B[m[32m+
(B[m     /// Initialize the Weaviate schema
     pub async fn initialize_schema(&self) -> Result<()> {
[31m-        info!("Initializing Weaviate schema for class: {}", self.config.class_name);
(B[m[31m-        
(B[m[32m+        info!(
(B[m[32m+            "Initializing Weaviate schema for class: {}",
(B[m[32m+            self.config.class_name
(B[m[32m+        );
(B[m[32m+
(B[m         let schema = serde_json::json!({
             "class": self.config.class_name,
             "description": "AgentMem memory storage",
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:146:
                 }
             ]
         });
[31m-        
(B[m[31m-        let mut request = self.client
(B[m[32m+
(B[m[32m+        let mut request = self
(B[m[32m+            .client
(B[m             .post(&format!("{}/v1/schema", self.config.url))
             .header("Content-Type", "application/json")
             .json(&schema);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:154:
[31m-        
(B[m[32m+
(B[m         if let Some(api_key) = &self.config.api_key {
             request = request.header("Authorization", format!("Bearer {}", api_key));
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:158:
[31m-        
(B[m[31m-        let response = request.send().await
(B[m[31m-            .map_err(|e| AgentMemError::network_error(&format!("Failed to create schema: {}", e)))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let response = request.send().await.map_err(|e| {
(B[m[32m+            AgentMemError::network_error(&format!("Failed to create schema: {}", e))
(B[m[32m+        })?;
(B[m[32m+
(B[m         if response.status().is_success() {
             info!("Weaviate schema initialized successfully");
             Ok(())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:165:
         } else {
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
[31m-            
(B[m[32m+
(B[m             // Schema might already exist, which is OK
             if status.as_u16() == 422 {
                 warn!("Schema already exists, continuing...");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:172:
                 Ok(())
             } else {
                 error!("Failed to initialize schema: {} - {}", status, error_text);
[31m-                Err(AgentMemError::storage_error(&format!("Schema initialization failed: {}", error_text)))
(B[m[32m+                Err(AgentMemError::storage_error(&format!(
(B[m[32m+                    "Schema initialization failed: {}",
(B[m[32m+                    error_text
(B[m[32m+                )))
(B[m             }
         }
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:179:
[31m-    
(B[m[32m+
(B[m     /// Build request with authentication
     fn build_request(&self, method: reqwest::Method, url: &str) -> reqwest::RequestBuilder {
         let mut request = self.client.request(method, url);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:183:
[31m-        
(B[m[32m+
(B[m         if let Some(api_key) = &self.config.api_key {
             request = request.header("Authorization", format!("Bearer {}", api_key));
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:187:
[31m-        
(B[m[32m+
(B[m         request
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:198:
         metadata: &HashMap<String, String>,
     ) -> Result<()> {
         debug!("Storing embedding for memory: {}", memory_id);
[31m-        
(B[m[32m+
(B[m         let mut properties = HashMap::new();
[31m-        properties.insert("memory_id".to_string(), serde_json::Value::String(memory_id.to_string()));
(B[m[31m-        
(B[m[32m+        properties.insert(
(B[m[32m+            "memory_id".to_string(),
(B[m[32m+            serde_json::Value::String(memory_id.to_string()),
(B[m[32m+        );
(B[m[32m+
(B[m         // Add metadata as properties
         for (key, value) in metadata {
             properties.insert(key.clone(), serde_json::Value::String(value.clone()));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:208:
         }
[31m-        
(B[m[32m+
(B[m         let object = WeaviateObject {
             id: Some(memory_id.to_string()),
             class: self.config.class_name.clone(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:213:
             properties,
             vector: Some(embedding.to_vec()),
         };
[31m-        
(B[m[31m-        let response = self.build_request(
(B[m[31m-            reqwest::Method::POST,
(B[m[31m-            &format!("{}/v1/objects", self.config.url)
(B[m[31m-        )
(B[m[31m-        .header("Content-Type", "application/json")
(B[m[31m-        .json(&object)
(B[m[31m-        .send()
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| AgentMemError::network_error(&format!("Failed to store embedding: {}", e)))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .build_request(
(B[m[32m+                reqwest::Method::POST,
(B[m[32m+                &format!("{}/v1/objects", self.config.url),
(B[m[32m+            )
(B[m[32m+            .header("Content-Type", "application/json")
(B[m[32m+            .json(&object)
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to store embedding: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         if response.status().is_success() {
             debug!("Successfully stored embedding for memory: {}", memory_id);
             Ok(())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:231:
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
             error!("Failed to store embedding: {} - {}", status, error_text);
[31m-            Err(AgentMemError::storage_error(&format!("Failed to store embedding: {}", error_text)))
(B[m[32m+            Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Failed to store embedding: {}",
(B[m[32m+                error_text
(B[m[32m+            )))
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     async fn search_similar(
         &self,
         query_embedding: &[f32],
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:242:
         threshold: Option<f32>,
     ) -> Result<Vec<SearchResult>> {
         debug!("Searching for similar embeddings with limit: {}", limit);
[31m-        
(B[m[32m+
(B[m         let query = serde_json::json!({
             "query": format!(
                 "{{
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:271:
                 limit
             )
         });
[31m-        
(B[m[31m-        let response = self.build_request(
(B[m[31m-            reqwest::Method::POST,
(B[m[31m-            &format!("{}/v1/graphql", self.config.url)
(B[m[31m-        )
(B[m[31m-        .header("Content-Type", "application/json")
(B[m[31m-        .json(&query)
(B[m[31m-        .send()
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| AgentMemError::network_error(&format!("Failed to search: {}", e)))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .build_request(
(B[m[32m+                reqwest::Method::POST,
(B[m[32m+                &format!("{}/v1/graphql", self.config.url),
(B[m[32m+            )
(B[m[32m+            .header("Content-Type", "application/json")
(B[m[32m+            .json(&query)
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m[32m+            .map_err(|e| AgentMemError::network_error(&format!("Failed to search: {}", e)))?;
(B[m[32m+
(B[m         if !response.status().is_success() {
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:288:
             error!("Search failed: {} - {}", status, error_text);
[31m-            return Err(AgentMemError::storage_error(&format!("Search failed: {}", error_text)));
(B[m[32m+            return Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Search failed: {}",
(B[m[32m+                error_text
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[31m-        let search_response: WeaviateSearchResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(&format!("Failed to parse search response: {}", e)))?;
(B[m[31m-        
(B[m[31m-        let results: Vec<SearchResult> = search_response.data.get
(B[m[32m+
(B[m[32m+        let search_response: WeaviateSearchResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(&format!("Failed to parse search response: {}", e))
(B[m[32m+        })?;
(B[m[32m+
(B[m[32m+        let results: Vec<SearchResult> = search_response
(B[m[32m+            .data
(B[m[32m+            .get
(B[m             .get(&self.config.class_name)
             .unwrap_or(&Vec::new())
             .iter()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:299:
             .filter_map(|result| {
                 let memory_id = result.memory_id.as_ref()?;
[31m-                let score = result.additional.as_ref()
(B[m[32m+                let score = result
(B[m[32m+                    .additional
(B[m[32m+                    .as_ref()
(B[m                     .and_then(|a| a.certainty)
                     .unwrap_or(0.0);
[31m-                
(B[m 
[31m-                
(B[m                 Some(SearchResult {
                     id: memory_id.clone(),
                     score,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:310:
                     metadata: {
                         let mut meta = HashMap::new();
                         if let Some(content) = &result.content {
[31m-                            meta.insert("content".to_string(), serde_json::Value::String(content.clone()));
(B[m[32m+                            meta.insert(
(B[m[32m+                                "content".to_string(),
(B[m[32m+                                serde_json::Value::String(content.clone()),
(B[m[32m+                            );
(B[m                         }
                         if let Some(agent_id) = &result.agent_id {
[31m-                            meta.insert("agent_id".to_string(), serde_json::Value::String(agent_id.clone()));
(B[m[32m+                            meta.insert(
(B[m[32m+                                "agent_id".to_string(),
(B[m[32m+                                serde_json::Value::String(agent_id.clone()),
(B[m[32m+                            );
(B[m                         }
                         if let Some(user_id) = &result.user_id {
[31m-                            meta.insert("user_id".to_string(), serde_json::Value::String(user_id.clone()));
(B[m[32m+                            meta.insert(
(B[m[32m+                                "user_id".to_string(),
(B[m[32m+                                serde_json::Value::String(user_id.clone()),
(B[m[32m+                            );
(B[m                         }
                         meta
                     },
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:323:
                 })
             })
             .collect();
[31m-        
(B[m[32m+
(B[m         debug!("Found {} similar embeddings", results.len());
         Ok(results)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:330:
[31m-    
(B[m[32m+
(B[m     async fn delete_embedding(&self, memory_id: &str) -> Result<()> {
         debug!("Deleting embedding for memory: {}", memory_id);
[31m-        
(B[m[31m-        let response = self.build_request(
(B[m[31m-            reqwest::Method::DELETE,
(B[m[31m-            &format!("{}/v1/objects/{}", self.config.url, memory_id)
(B[m[31m-        )
(B[m[31m-        .send()
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| AgentMemError::network_error(&format!("Failed to delete embedding: {}", e)))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .build_request(
(B[m[32m+                reqwest::Method::DELETE,
(B[m[32m+                &format!("{}/v1/objects/{}", self.config.url, memory_id),
(B[m[32m+            )
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to delete embedding: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         if response.status().is_success() {
             debug!("Successfully deleted embedding for memory: {}", memory_id);
             Ok(())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:346:
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
             error!("Failed to delete embedding: {} - {}", status, error_text);
[31m-            Err(AgentMemError::storage_error(&format!("Failed to delete embedding: {}", error_text)))
(B[m[32m+            Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Failed to delete embedding: {}",
(B[m[32m+                error_text
(B[m[32m+            )))
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     async fn update_embedding(
         &self,
         memory_id: &str,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:357:
         metadata: &HashMap<String, String>,
     ) -> Result<()> {
         debug!("Updating embedding for memory: {}", memory_id);
[31m-        
(B[m[32m+
(B[m         // Delete existing and create new (Weaviate doesn't have direct update for vectors)
         self.delete_embedding(memory_id).await?;
         self.store_embedding(memory_id, embedding, metadata).await
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:364:
     }
[31m-    
(B[m[32m+
(B[m     async fn get_embedding(&self, memory_id: &str) -> Result<Option<Vec<f32>>> {
         debug!("Getting embedding for memory: {}", memory_id);
[31m-        
(B[m[31m-        let response = self.build_request(
(B[m[31m-            reqwest::Method::GET,
(B[m[31m-            &format!("{}/v1/objects/{}", self.config.url, memory_id)
(B[m[31m-        )
(B[m[31m-        .send()
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| AgentMemError::network_error(&format!("Failed to get embedding: {}", e)))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .build_request(
(B[m[32m+                reqwest::Method::GET,
(B[m[32m+                &format!("{}/v1/objects/{}", self.config.url, memory_id),
(B[m[32m+            )
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to get embedding: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         if response.status().is_success() {
[31m-            let object: WeaviateObject = response.json().await
(B[m[31m-                .map_err(|e| AgentMemError::parsing_error(&format!("Failed to parse object: {}", e)))?;
(B[m[31m-            
(B[m[32m+            let object: WeaviateObject = response.json().await.map_err(|e| {
(B[m[32m+                AgentMemError::parsing_error(&format!("Failed to parse object: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m             Ok(object.vector)
         } else if response.status().as_u16() == 404 {
             Ok(None)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:385:
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
             error!("Failed to get embedding: {} - {}", status, error_text);
[31m-            Err(AgentMemError::storage_error(&format!("Failed to get embedding: {}", error_text)))
(B[m[32m+            Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Failed to get embedding: {}",
(B[m[32m+                error_text
(B[m[32m+            )))
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     async fn list_embeddings(&self, prefix: Option<&str>) -> Result<Vec<String>> {
         debug!("Listing embeddings with prefix: {:?}", prefix);
[31m-        
(B[m[32m+
(B[m         let query = serde_json::json!({
             "query": format!(
                 "{{
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:404:
                 self.config.class_name
             )
         });
[31m-        
(B[m[31m-        let response = self.build_request(
(B[m[31m-            reqwest::Method::POST,
(B[m[31m-            &format!("{}/v1/graphql", self.config.url)
(B[m[31m-        )
(B[m[31m-        .header("Content-Type", "application/json")
(B[m[31m-        .json(&query)
(B[m[31m-        .send()
(B[m[31m-        .await
(B[m[31m-        .map_err(|e| AgentMemError::network_error(&format!("Failed to list embeddings: {}", e)))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .build_request(
(B[m[32m+                reqwest::Method::POST,
(B[m[32m+                &format!("{}/v1/graphql", self.config.url),
(B[m[32m+            )
(B[m[32m+            .header("Content-Type", "application/json")
(B[m[32m+            .json(&query)
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(&format!("Failed to list embeddings: {}", e))
(B[m[32m+            })?;
(B[m[32m+
(B[m         if !response.status().is_success() {
             let status = response.status();
             let error_text = response.text().await.unwrap_or_default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:421:
             error!("Failed to list embeddings: {} - {}", status, error_text);
[31m-            return Err(AgentMemError::storage_error(&format!("Failed to list embeddings: {}", error_text)));
(B[m[32m+            return Err(AgentMemError::storage_error(&format!(
(B[m[32m+                "Failed to list embeddings: {}",
(B[m[32m+                error_text
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[31m-        let search_response: WeaviateSearchResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(&format!("Failed to parse list response: {}", e)))?;
(B[m[31m-        
(B[m[31m-        let mut memory_ids: Vec<String> = search_response.data.get
(B[m[32m+
(B[m[32m+        let search_response: WeaviateSearchResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(&format!("Failed to parse list response: {}", e))
(B[m[32m+        })?;
(B[m[32m+
(B[m[32m+        let mut memory_ids: Vec<String> = search_response
(B[m[32m+            .data
(B[m[32m+            .get
(B[m             .get(&self.config.class_name)
             .unwrap_or(&Vec::new())
             .iter()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:432:
             .filter_map(|result| result.memory_id.clone())
             .collect();
[31m-        
(B[m[32m+
(B[m         // Apply prefix filter if specified
         if let Some(prefix) = prefix {
             memory_ids.retain(|id| id.starts_with(prefix));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:438:
         }
[31m-        
(B[m[32m+
(B[m         debug!("Found {} embeddings", memory_ids.len());
         Ok(memory_ids)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/backends/weaviate.rs:461:
         let store = WeaviateStore::new(config);
         assert!(store.is_ok());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_config_default() {
         let config = WeaviateConfig::default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/factory.rs:1:
 //! 存储工厂模式实现
 
[31m-use crate::backends::{MemoryVectorStore, ChromaStore, QdrantStore, PineconeStore};
(B[m[31m-use agent_mem_traits::{VectorStore, VectorStoreConfig, Result, AgentMemError};
(B[m[32m+use crate::backends::{ChromaStore, MemoryVectorStore, PineconeStore, QdrantStore};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result, VectorStore, VectorStoreConfig};
(B[m use async_trait::async_trait;
 use std::sync::Arc;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/factory.rs:28:
         }
     }
 
[31m-    async fn search_vectors(&self, query_vector: Vec<f32>, limit: usize, threshold: Option<f32>) -> Result<Vec<agent_mem_traits::VectorSearchResult>> {
(B[m[32m+    async fn search_vectors(
(B[m[32m+        &self,
(B[m[32m+        query_vector: Vec<f32>,
(B[m[32m+        limit: usize,
(B[m[32m+        threshold: Option<f32>,
(B[m[32m+    ) -> Result<Vec<agent_mem_traits::VectorSearchResult>> {
(B[m         match self {
[31m-            VectorStoreEnum::Memory(store) => store.search_vectors(query_vector, limit, threshold).await,
(B[m[31m-            VectorStoreEnum::Chroma(store) => store.search_vectors(query_vector, limit, threshold).await,
(B[m[32m+            VectorStoreEnum::Memory(store) => {
(B[m[32m+                store.search_vectors(query_vector, limit, threshold).await
(B[m[32m+            }
(B[m[32m+            VectorStoreEnum::Chroma(store) => {
(B[m[32m+                store.search_vectors(query_vector, limit, threshold).await
(B[m[32m+            }
(B[m             #[cfg(feature = "qdrant")]
[31m-            VectorStoreEnum::Qdrant(store) => store.search_vectors(query_vector, limit, threshold).await,
(B[m[32m+            VectorStoreEnum::Qdrant(store) => {
(B[m[32m+                store.search_vectors(query_vector, limit, threshold).await
(B[m[32m+            }
(B[m             #[cfg(feature = "pinecone")]
[31m-            VectorStoreEnum::Pinecone(store) => store.search_vectors(query_vector, limit, threshold).await,
(B[m[32m+            VectorStoreEnum::Pinecone(store) => {
(B[m[32m+                store.search_vectors(query_vector, limit, threshold).await
(B[m[32m+            }
(B[m         }
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/factory.rs:100:
 
 impl StorageFactory {
     /// 根据配置创建向量存储实例
[31m-    pub async fn create_vector_store(config: &VectorStoreConfig) -> Result<Arc<dyn VectorStore + Send + Sync>> {
(B[m[32m+    pub async fn create_vector_store(
(B[m[32m+        config: &VectorStoreConfig,
(B[m[32m+    ) -> Result<Arc<dyn VectorStore + Send + Sync>> {
(B[m         let store_enum = match config.provider.as_str() {
             "memory" => {
                 let store = MemoryVectorStore::new(config.clone()).await?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/factory.rs:118:
                 }
                 #[cfg(not(feature = "qdrant"))]
                 {
[31m-                    return Err(AgentMemError::unsupported_provider("Qdrant feature not enabled"));
(B[m[32m+                    return Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Qdrant feature not enabled",
(B[m[32m+                    ));
(B[m                 }
             }
             "pinecone" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/factory.rs:129:
                 }
                 #[cfg(not(feature = "pinecone"))]
                 {
[31m-                    return Err(AgentMemError::unsupported_provider("Pinecone feature not enabled"));
(B[m[32m+                    return Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Pinecone feature not enabled",
(B[m[32m+                    ));
(B[m                 }
             }
             _ => return Err(AgentMemError::unsupported_provider(&config.provider)),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/factory.rs:167:
     }
 
     /// 创建Chroma存储
[31m-    pub async fn create_chroma_store(url: &str, collection_name: &str) -> Result<Arc<dyn VectorStore + Send + Sync>> {
(B[m[32m+    pub async fn create_chroma_store(
(B[m[32m+        url: &str,
(B[m[32m+        collection_name: &str,
(B[m[32m+    ) -> Result<Arc<dyn VectorStore + Send + Sync>> {
(B[m         let config = VectorStoreConfig {
             provider: "chroma".to_string(),
             url: Some(url.to_string()),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/factory.rs:179:
 
     /// 创建Qdrant存储
     #[cfg(feature = "qdrant")]
[31m-    pub async fn create_qdrant_store(url: &str, collection_name: &str) -> Result<Arc<dyn VectorStore + Send + Sync>> {
(B[m[32m+    pub async fn create_qdrant_store(
(B[m[32m+        url: &str,
(B[m[32m+        collection_name: &str,
(B[m[32m+    ) -> Result<Arc<dyn VectorStore + Send + Sync>> {
(B[m         let config = VectorStoreConfig {
             provider: "qdrant".to_string(),
             url: Some(url.to_string()),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/factory.rs:191:
 
     /// 创建Pinecone存储
     #[cfg(feature = "pinecone")]
[31m-    pub async fn create_pinecone_store(api_key: &str, index_name: &str, environment: &str) -> Result<Arc<dyn VectorStore + Send + Sync>> {
(B[m[32m+    pub async fn create_pinecone_store(
(B[m[32m+        api_key: &str,
(B[m[32m+        index_name: &str,
(B[m[32m+        environment: &str,
(B[m[32m+    ) -> Result<Arc<dyn VectorStore + Send + Sync>> {
(B[m         let config = VectorStoreConfig {
             provider: "pinecone".to_string(),
             api_key: Some(api_key.to_string()),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/factory.rs:198:
             index_name: Some(index_name.to_string()),
[31m-            url: Some(format!("https://{}-{}.svc.{}.pinecone.io", index_name, "default", environment)),
(B[m[32m+            url: Some(format!(
(B[m[32m+                "https://{}-{}.svc.{}.pinecone.io",
(B[m[32m+                index_name, "default", environment
(B[m[32m+            )),
(B[m             ..Default::default()
         };
         Self::create_vector_store(&config).await
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/factory.rs:231:
         #[cfg(feature = "pinecone")]
         assert!(StorageFactory::is_provider_supported("pinecone"));
 
[31m-        assert!(!StorageFactory::is_provider_supported("unsupported_provider"));
(B[m[32m+        assert!(!StorageFactory::is_provider_supported(
(B[m[32m+            "unsupported_provider"
(B[m[32m+        ));
(B[m     }
 
     #[test]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/factory.rs:268:
     #[cfg(feature = "pinecone")]
     #[tokio::test]
     async fn test_create_pinecone_store() {
[31m-        let result = StorageFactory::create_pinecone_store("test-key", "test-index", "us-east1-gcp").await;
(B[m[32m+        let result =
(B[m[32m+            StorageFactory::create_pinecone_store("test-key", "test-index", "us-east1-gcp").await;
(B[m         assert!(result.is_ok());
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/factory.rs:321:
         }
     }
 }
[32m+
(B[mDiff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:1:
 //! 图存储工厂实现
 
[31m-use crate::graph::{Neo4jStore, MemgraphStore};
(B[m[31m-use agent_mem_traits::{GraphStore, Result, AgentMemError};
(B[m[32m+use crate::graph::{MemgraphStore, Neo4jStore};
(B[m use agent_mem_config::memory::GraphStoreConfig;
[32m+use agent_mem_traits::{AgentMemError, GraphStore, Result};
(B[m use async_trait::async_trait;
 use std::sync::Arc;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:18:
 
 #[async_trait]
 impl GraphStore for GraphStoreEnum {
[31m-    async fn add_entities(&self, entities: &[agent_mem_traits::Entity], session: &agent_mem_traits::Session) -> Result<()> {
(B[m[32m+    async fn add_entities(
(B[m[32m+        &self,
(B[m[32m+        entities: &[agent_mem_traits::Entity],
(B[m[32m+        session: &agent_mem_traits::Session,
(B[m[32m+    ) -> Result<()> {
(B[m         match self {
             #[cfg(feature = "neo4j")]
             GraphStoreEnum::Neo4j(store) => store.add_entities(entities, session).await,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:29:
         }
     }
 
[31m-    async fn add_relations(&self, relations: &[agent_mem_traits::Relation], session: &agent_mem_traits::Session) -> Result<()> {
(B[m[32m+    async fn add_relations(
(B[m[32m+        &self,
(B[m[32m+        relations: &[agent_mem_traits::Relation],
(B[m[32m+        session: &agent_mem_traits::Session,
(B[m[32m+    ) -> Result<()> {
(B[m         match self {
             #[cfg(feature = "neo4j")]
             GraphStoreEnum::Neo4j(store) => store.add_relations(relations, session).await,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:40:
         }
     }
 
[31m-    async fn search_graph(&self, query: &str, session: &agent_mem_traits::Session) -> Result<Vec<agent_mem_traits::GraphResult>> {
(B[m[32m+    async fn search_graph(
(B[m[32m+        &self,
(B[m[32m+        query: &str,
(B[m[32m+        session: &agent_mem_traits::Session,
(B[m[32m+    ) -> Result<Vec<agent_mem_traits::GraphResult>> {
(B[m         match self {
             #[cfg(feature = "neo4j")]
             GraphStoreEnum::Neo4j(store) => store.search_graph(query, session).await,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:51:
         }
     }
 
[31m-    async fn get_neighbors(&self, entity_id: &str, depth: usize) -> Result<Vec<agent_mem_traits::Entity>> {
(B[m[32m+    async fn get_neighbors(
(B[m[32m+        &self,
(B[m[32m+        entity_id: &str,
(B[m[32m+        depth: usize,
(B[m[32m+    ) -> Result<Vec<agent_mem_traits::Entity>> {
(B[m         match self {
             #[cfg(feature = "neo4j")]
             GraphStoreEnum::Neo4j(store) => store.get_neighbors(entity_id, depth).await,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:79:
 
 impl GraphStoreFactory {
     /// 根据配置创建图存储实例
[31m-    pub async fn create_graph_store(config: &GraphStoreConfig) -> Result<Arc<dyn GraphStore + Send + Sync>> {
(B[m[32m+    pub async fn create_graph_store(
(B[m[32m+        config: &GraphStoreConfig,
(B[m[32m+    ) -> Result<Arc<dyn GraphStore + Send + Sync>> {
(B[m         match config.provider.as_str() {
             "neo4j" => {
                 #[cfg(feature = "neo4j")]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:90:
                 }
                 #[cfg(not(feature = "neo4j"))]
                 {
[31m-                    Err(AgentMemError::unsupported_provider("Neo4j feature not enabled"))
(B[m[32m+                    Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Neo4j feature not enabled",
(B[m[32m+                    ))
(B[m                 }
             }
             "memgraph" => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:102:
                 }
                 #[cfg(not(feature = "memgraph"))]
                 {
[31m-                    Err(AgentMemError::unsupported_provider("Memgraph feature not enabled"))
(B[m[32m+                    Err(AgentMemError::unsupported_provider(
(B[m[32m+                        "Memgraph feature not enabled",
(B[m[32m+                    ))
(B[m                 }
             }
             _ => Err(AgentMemError::unsupported_provider(&config.provider)),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:113:
     pub fn supported_providers() -> Vec<&'static str> {
         #[allow(unused_mut)]
         let mut providers = Vec::new();
[31m-        
(B[m[32m+
(B[m         #[cfg(feature = "neo4j")]
         providers.push("neo4j");
[31m-        
(B[m[32m+
(B[m         #[cfg(feature = "memgraph")]
         providers.push("memgraph");
[31m-        
(B[m[32m+
(B[m         providers
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:130:
 
     /// 创建Neo4j存储
     #[cfg(feature = "neo4j")]
[31m-    pub async fn create_neo4j_store(uri: &str, username: &str, password: &str) -> Result<Arc<dyn GraphStore + Send + Sync>> {
(B[m[32m+    pub async fn create_neo4j_store(
(B[m[32m+        uri: &str,
(B[m[32m+        username: &str,
(B[m[32m+        password: &str,
(B[m[32m+    ) -> Result<Arc<dyn GraphStore + Send + Sync>> {
(B[m         let config = GraphStoreConfig {
             provider: "neo4j".to_string(),
             uri: uri.to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:143:
 
     /// 创建Memgraph存储
     #[cfg(feature = "memgraph")]
[31m-    pub async fn create_memgraph_store(uri: &str, username: Option<&str>, password: Option<&str>) -> Result<Arc<dyn GraphStore + Send + Sync>> {
(B[m[32m+    pub async fn create_memgraph_store(
(B[m[32m+        uri: &str,
(B[m[32m+        username: Option<&str>,
(B[m[32m+        password: Option<&str>,
(B[m[32m+    ) -> Result<Arc<dyn GraphStore + Send + Sync>> {
(B[m         let config = GraphStoreConfig {
             provider: "memgraph".to_string(),
             uri: uri.to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:162:
     #[test]
     fn test_supported_providers() {
         let providers = GraphStoreFactory::supported_providers();
[31m-        
(B[m[32m+
(B[m         #[cfg(feature = "neo4j")]
         assert!(providers.contains(&"neo4j"));
[31m-        
(B[m[32m+
(B[m         #[cfg(feature = "memgraph")]
         assert!(providers.contains(&"memgraph"));
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:174:
     fn test_is_provider_supported() {
         #[cfg(feature = "neo4j")]
         assert!(GraphStoreFactory::is_provider_supported("neo4j"));
[31m-        
(B[m[32m+
(B[m         #[cfg(feature = "memgraph")]
         assert!(GraphStoreFactory::is_provider_supported("memgraph"));
[31m-        
(B[m[31m-        assert!(!GraphStoreFactory::is_provider_supported("unsupported_provider"));
(B[m[32m+
(B[m[32m+        assert!(!GraphStoreFactory::is_provider_supported(
(B[m[32m+            "unsupported_provider"
(B[m[32m+        ));
(B[m     }
 
     #[test]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:199:
     #[cfg(feature = "neo4j")]
     #[tokio::test]
     async fn test_create_neo4j_store() {
[31m-        let result = GraphStoreFactory::create_neo4j_store(
(B[m[31m-            "bolt://localhost:7687",
(B[m[31m-            "neo4j",
(B[m[31m-            "password"
(B[m[31m-        ).await;
(B[m[32m+        let result =
(B[m[32m+            GraphStoreFactory::create_neo4j_store("bolt://localhost:7687", "neo4j", "password")
(B[m[32m+                .await;
(B[m         assert!(result.is_ok());
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/factory.rs:213:
         let result = GraphStoreFactory::create_memgraph_store(
             "bolt://localhost:7687",
             Some("memgraph"),
[31m-            Some("password")
(B[m[31m-        ).await;
(B[m[32m+            Some("password"),
(B[m[32m+        )
(B[m[32m+        .await;
(B[m         assert!(result.is_ok());
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:1:
 //! Memgraph图存储实现
 
[31m-use agent_mem_traits::{GraphStore, Entity, Relation, Session, GraphResult, Result, AgentMemError};
(B[m use agent_mem_config::memory::GraphStoreConfig;
[32m+use agent_mem_traits::{AgentMemError, Entity, GraphResult, GraphStore, Relation, Result, Session};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:65:
             config.uri.clone()
         } else {
             // 将bolt://转换为http://，Memgraph默认HTTP端口是7444
[31m-            config.uri.replace("bolt://", "http://").replace(":7687", ":7444")
(B[m[32m+            config
(B[m[32m+                .uri
(B[m[32m+                .replace("bolt://", "http://")
(B[m[32m+                .replace(":7687", ":7444")
(B[m         };
 
         // 创建认证头（如果提供了用户名和密码）
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:72:
[31m-        let auth_header = if let (Some(username), Some(password)) = (&config.username, &config.password) {
(B[m[31m-            let auth_string = format!("{}:{}", username, password);
(B[m[31m-            Some(format!("Basic {}", base64::encode(&auth_string)))
(B[m[31m-        } else {
(B[m[31m-            None
(B[m[31m-        };
(B[m[32m+        let auth_header =
(B[m[32m+            if let (Some(username), Some(password)) = (&config.username, &config.password) {
(B[m[32m+                let auth_string = format!("{}:{}", username, password);
(B[m[32m+                Some(format!("Basic {}", base64::encode(&auth_string)))
(B[m[32m+            } else {
(B[m[32m+                None
(B[m[32m+            };
(B[m 
         let client = Client::builder()
             .timeout(Duration::from_secs(30))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:81:
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(format!("Failed to create HTTP client: {}", e)))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m 
         let store = Self {
             config,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:104:
         };
 
         let url = format!("{}/db/data/transaction/commit", self.base_url);
[31m-        
(B[m[31m-        let mut request = self.client
(B[m[32m+
(B[m[32m+        let mut request = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Content-Type", "application/json")
             .json(&query);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:114:
             request = request.header("Authorization", auth);
         }
 
[31m-        let response = request.send().await
(B[m[32m+        let response = request
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m             .map_err(|e| AgentMemError::network_error(format!("Connection test failed: {}", e)))?;
 
         if !response.status().is_success() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:121:
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Memgraph connection test failed {}: {}", status, error_text
(B[m[32m+                "Memgraph connection test failed {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:129:
[31m-        let result: MemgraphQueryResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let result: MemgraphQueryResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         if !result.errors.is_empty() {
             return Err(AgentMemError::storage_error(format!(
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:134:
[31m-                "Memgraph error: {}", result.errors[0].message
(B[m[32m+                "Memgraph error: {}",
(B[m[32m+                result.errors[0].message
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:139:
     }
 
     /// 执行Cypher查询
[31m-    async fn execute_query(&self, statement: &str, parameters: Option<HashMap<String, serde_json::Value>>) -> Result<MemgraphQueryResponse> {
(B[m[32m+    async fn execute_query(
(B[m[32m+        &self,
(B[m[32m+        statement: &str,
(B[m[32m+        parameters: Option<HashMap<String, serde_json::Value>>,
(B[m[32m+    ) -> Result<MemgraphQueryResponse> {
(B[m         let query = MemgraphQueryRequest {
             statements: vec![MemgraphStatement {
                 statement: statement.to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:148:
         };
 
         let url = format!("{}/db/data/transaction/commit", self.base_url);
[31m-        
(B[m[31m-        let mut request = self.client
(B[m[32m+
(B[m[32m+        let mut request = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Content-Type", "application/json")
             .json(&query);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:158:
             request = request.header("Authorization", auth);
         }
 
[31m-        let response = request.send().await
(B[m[32m+        let response = request
(B[m[32m+            .send()
(B[m[32m+            .await
(B[m             .map_err(|e| AgentMemError::network_error(format!("Query execution failed: {}", e)))?;
 
         if !response.status().is_success() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:165:
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Memgraph query failed {}: {}", status, error_text
(B[m[32m+                "Memgraph query failed {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:173:
[31m-        let result: MemgraphQueryResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let result: MemgraphQueryResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         if !result.errors.is_empty() {
             return Err(AgentMemError::storage_error(format!(
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:178:
[31m-                "Memgraph error: {}", result.errors[0].message
(B[m[32m+                "Memgraph error: {}",
(B[m[32m+                result.errors[0].message
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:185:
     /// 将Entity转换为Cypher参数
     fn entity_to_parameters(&self, entity: &Entity) -> HashMap<String, serde_json::Value> {
         let mut params = HashMap::new();
[31m-        params.insert("id".to_string(), serde_json::Value::String(entity.id.clone()));
(B[m[31m-        params.insert("entity_type".to_string(), serde_json::Value::String(entity.entity_type.clone()));
(B[m[31m-        params.insert("name".to_string(), serde_json::Value::String(entity.name.clone()));
(B[m[32m+        params.insert(
(B[m[32m+            "id".to_string(),
(B[m[32m+            serde_json::Value::String(entity.id.clone()),
(B[m[32m+        );
(B[m[32m+        params.insert(
(B[m[32m+            "entity_type".to_string(),
(B[m[32m+            serde_json::Value::String(entity.entity_type.clone()),
(B[m[32m+        );
(B[m[32m+        params.insert(
(B[m[32m+            "name".to_string(),
(B[m[32m+            serde_json::Value::String(entity.name.clone()),
(B[m[32m+        );
(B[m 
         // 添加属性
         for (key, value) in &entity.attributes {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:200:
     /// 将Relation转换为Cypher参数
     fn relation_to_parameters(&self, relation: &Relation) -> HashMap<String, serde_json::Value> {
         let mut params = HashMap::new();
[31m-        params.insert("source".to_string(), serde_json::Value::String(relation.source.clone()));
(B[m[31m-        params.insert("target".to_string(), serde_json::Value::String(relation.target.clone()));
(B[m[31m-        params.insert("relation_type".to_string(), serde_json::Value::String(relation.relation.clone()));
(B[m[31m-        params.insert("confidence".to_string(), serde_json::Value::Number(serde_json::Number::from_f64(relation.confidence as f64).unwrap()));
(B[m[32m+        params.insert(
(B[m[32m+            "source".to_string(),
(B[m[32m+            serde_json::Value::String(relation.source.clone()),
(B[m[32m+        );
(B[m[32m+        params.insert(
(B[m[32m+            "target".to_string(),
(B[m[32m+            serde_json::Value::String(relation.target.clone()),
(B[m[32m+        );
(B[m[32m+        params.insert(
(B[m[32m+            "relation_type".to_string(),
(B[m[32m+            serde_json::Value::String(relation.relation.clone()),
(B[m[32m+        );
(B[m[32m+        params.insert(
(B[m[32m+            "confidence".to_string(),
(B[m[32m+            serde_json::Value::Number(
(B[m[32m+                serde_json::Number::from_f64(relation.confidence as f64).unwrap(),
(B[m[32m+            ),
(B[m[32m+        );
(B[m 
         params
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:220:
                     e += $properties
                 RETURN e
             "#;
[31m-            
(B[m[32m+
(B[m             let mut parameters = self.entity_to_parameters(entity);
[31m-            
(B[m[32m+
(B[m             // 将属性作为单独的参数传递
             let attributes: HashMap<String, serde_json::Value> = entity.attributes.clone();
[31m-            parameters.insert("properties".to_string(), serde_json::Value::Object(
(B[m[31m-                attributes.into_iter().collect()
(B[m[31m-            ));
(B[m[31m-            
(B[m[32m+            parameters.insert(
(B[m[32m+                "properties".to_string(),
(B[m[32m+                serde_json::Value::Object(attributes.into_iter().collect()),
(B[m[32m+            );
(B[m[32m+
(B[m             self.execute_query(statement, Some(parameters)).await?;
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:248:
 
             self.execute_query(statement, Some(parameters)).await?;
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:261:
             RETURN e, collect(r) as relations, collect(related) as related_entities
             LIMIT 10
         "#;
[31m-        
(B[m[32m+
(B[m         let mut parameters = HashMap::new();
[31m-        parameters.insert("query".to_string(), serde_json::Value::String(query.to_string()));
(B[m[31m-        
(B[m[32m+        parameters.insert(
(B[m[32m+            "query".to_string(),
(B[m[32m+            serde_json::Value::String(query.to_string()),
(B[m[32m+        );
(B[m[32m+
(B[m         let response = self.execute_query(statement, Some(parameters)).await?;
[31m-        
(B[m[32m+
(B[m         let mut results = Vec::new();
[31m-        
(B[m[32m+
(B[m         for result in response.results {
             for data_row in result.data {
                 if let Some(_entity_data) = data_row.row.get(0) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:279:
                         name: "parsed_name".to_string(),
                         attributes: HashMap::new(),
                     };
[31m-                    
(B[m[32m+
(B[m                     let graph_result = GraphResult {
                         entity,
                         relations: Vec::new(), // 实际实现需要解析关系
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:286:
                         score: 1.0,
                     };
[31m-                    
(B[m[32m+
(B[m                     results.push(graph_result);
                 }
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:292:
         }
[31m-        
(B[m[32m+
(B[m         Ok(results)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:297:
     async fn get_neighbors(&self, entity_id: &str, depth: usize) -> Result<Vec<Entity>> {
[31m-        let statement = format!(r#"
(B[m[32m+        let statement = format!(
(B[m[32m+            r#"
(B[m             MATCH (start:Entity {{id: $entity_id}})
             MATCH (start)-[*1..{}]-(neighbor:Entity)
             RETURN DISTINCT neighbor
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:302:
             LIMIT 50
[31m-        "#, depth);
(B[m[31m-        
(B[m[32m+        "#,
(B[m[32m+            depth
(B[m[32m+        );
(B[m[32m+
(B[m         let mut parameters = HashMap::new();
[31m-        parameters.insert("entity_id".to_string(), serde_json::Value::String(entity_id.to_string()));
(B[m[31m-        
(B[m[32m+        parameters.insert(
(B[m[32m+            "entity_id".to_string(),
(B[m[32m+            serde_json::Value::String(entity_id.to_string()),
(B[m[32m+        );
(B[m[32m+
(B[m         let response = self.execute_query(&statement, Some(parameters)).await?;
[31m-        
(B[m[32m+
(B[m         let mut entities = Vec::new();
[31m-        
(B[m[32m+
(B[m         for result in response.results {
             for data_row in result.data {
                 if let Some(_entity_data) = data_row.row.get(0) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:319:
                         name: "neighbor_name".to_string(),
                         attributes: HashMap::new(),
                     };
[31m-                    
(B[m[32m+
(B[m                     entities.push(entity);
                 }
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:326:
         }
[31m-        
(B[m[32m+
(B[m         Ok(entities)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:341:
         const CHARS: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
         let mut result = String::new();
         let bytes = input.as_bytes();
[31m-        
(B[m[32m+
(B[m         for chunk in bytes.chunks(3) {
             let mut buf = [0u8; 3];
             for (i, &byte) in chunk.iter().enumerate() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:348:
                 buf[i] = byte;
             }
[31m-            
(B[m[32m+
(B[m             let b = ((buf[0] as u32) << 16) | ((buf[1] as u32) << 8) | (buf[2] as u32);
[31m-            
(B[m[32m+
(B[m             result.push(CHARS[((b >> 18) & 63) as usize] as char);
             result.push(CHARS[((b >> 12) & 63) as usize] as char);
[31m-            result.push(if chunk.len() > 1 { CHARS[((b >> 6) & 63) as usize] as char } else { '=' });
(B[m[31m-            result.push(if chunk.len() > 2 { CHARS[(b & 63) as usize] as char } else { '=' });
(B[m[32m+            result.push(if chunk.len() > 1 {
(B[m[32m+                CHARS[((b >> 6) & 63) as usize] as char
(B[m[32m+            } else {
(B[m[32m+                '='
(B[m[32m+            });
(B[m[32m+            result.push(if chunk.len() > 2 {
(B[m[32m+                CHARS[(b & 63) as usize] as char
(B[m[32m+            } else {
(B[m[32m+                '='
(B[m[32m+            });
(B[m         }
[31m-        
(B[m[32m+
(B[m         result
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:399:
         };
 
         let mut properties = HashMap::new();
[31m-        properties.insert("key1".to_string(), serde_json::Value::String("value1".to_string()));
(B[m[32m+        properties.insert(
(B[m[32m+            "key1".to_string(),
(B[m[32m+            serde_json::Value::String("value1".to_string()),
(B[m[32m+        );
(B[m 
         let entity = Entity {
             id: "test-id".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:409:
         };
 
         let params = store.entity_to_parameters(&entity);
[31m-        assert_eq!(params.get("id").unwrap(), &serde_json::Value::String("test-id".to_string()));
(B[m[31m-        assert_eq!(params.get("entity_type").unwrap(), &serde_json::Value::String("Person".to_string()));
(B[m[31m-        assert_eq!(params.get("name").unwrap(), &serde_json::Value::String("Test Person".to_string()));
(B[m[31m-        assert_eq!(params.get("key1").unwrap(), &serde_json::Value::String("value1".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            params.get("id").unwrap(),
(B[m[32m+            &serde_json::Value::String("test-id".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            params.get("entity_type").unwrap(),
(B[m[32m+            &serde_json::Value::String("Person".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            params.get("name").unwrap(),
(B[m[32m+            &serde_json::Value::String("Test Person".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            params.get("key1").unwrap(),
(B[m[32m+            &serde_json::Value::String("value1".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:444:
         };
 
         let params = store.relation_to_parameters(&relation);
[31m-        assert_eq!(params.get("source").unwrap(), &serde_json::Value::String("person1".to_string()));
(B[m[31m-        assert_eq!(params.get("target").unwrap(), &serde_json::Value::String("person2".to_string()));
(B[m[31m-        assert_eq!(params.get("relation_type").unwrap(), &serde_json::Value::String("KNOWS".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            params.get("source").unwrap(),
(B[m[32m+            &serde_json::Value::String("person1".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            params.get("target").unwrap(),
(B[m[32m+            &serde_json::Value::String("person2".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            params.get("relation_type").unwrap(),
(B[m[32m+            &serde_json::Value::String("KNOWS".to_string())
(B[m[32m+        );
(B[m 
         // 检查confidence值（允许浮点数精度误差）
         if let Some(serde_json::Value::Number(n)) = params.get("confidence") {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/memgraph.rs:453:
             let confidence = n.as_f64().unwrap();
[31m-            assert!((confidence - 0.9).abs() < 1e-6, "Expected confidence ~0.9, got {}", confidence);
(B[m[32m+            assert!(
(B[m[32m+                (confidence - 0.9).abs() < 1e-6,
(B[m[32m+                "Expected confidence ~0.9, got {}",
(B[m[32m+                confidence
(B[m[32m+            );
(B[m         } else {
             panic!("Expected confidence to be a number");
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/mod.rs:1:
 //! 图存储模块
[31m-//! 
(B[m[32m+//!
(B[m //! 提供图数据库集成，支持实体关系存储和图查询
 
 pub mod factory;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/mod.rs:6:
[31m-pub mod neo4j;
(B[m pub mod memgraph;
[32m+pub mod neo4j;
(B[m 
 pub use factory::GraphStoreFactory;
[31m-pub use neo4j::Neo4jStore;
(B[m pub use memgraph::MemgraphStore;
[32m+pub use neo4j::Neo4jStore;
(B[m 
 // 重新导出常用类型
[31m-pub use agent_mem_traits::{GraphStore, Entity, Relation, Session, GraphResult, Result};
(B[m[32m+pub use agent_mem_traits::{Entity, GraphResult, GraphStore, Relation, Result, Session};
(B[m 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:1:
 //! Neo4j图存储实现
 
[31m-use agent_mem_traits::{GraphStore, Entity, Relation, Session, GraphResult, Result, AgentMemError};
(B[m use agent_mem_config::memory::GraphStoreConfig;
[32m+use agent_mem_traits::{AgentMemError, Entity, GraphResult, GraphStore, Relation, Result, Session};
(B[m use async_trait::async_trait;
 use reqwest::Client;
 use serde::{Deserialize, Serialize};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:60:
 impl Neo4jStore {
     /// 创建新的Neo4j存储实例
     pub async fn new(config: GraphStoreConfig) -> Result<Self> {
[31m-        let username = config.username.as_ref()
(B[m[32m+        let username = config
(B[m[32m+            .username
(B[m[32m+            .as_ref()
(B[m             .ok_or_else(|| AgentMemError::config_error("Neo4j username is required"))?;
[31m-        let password = config.password.as_ref()
(B[m[32m+        let password = config
(B[m[32m+            .password
(B[m[32m+            .as_ref()
(B[m             .ok_or_else(|| AgentMemError::config_error("Neo4j password is required"))?;
 
         // 构建基础URL
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:70:
             config.uri.clone()
         } else {
             // 将bolt://转换为http://
[31m-            config.uri.replace("bolt://", "http://").replace(":7687", ":7474")
(B[m[32m+            config
(B[m[32m+                .uri
(B[m[32m+                .replace("bolt://", "http://")
(B[m[32m+                .replace(":7687", ":7474")
(B[m         };
 
         // 创建基本认证头
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:80:
         let client = Client::builder()
             .timeout(Duration::from_secs(30))
             .build()
[31m-            .map_err(|e| AgentMemError::network_error(format!("Failed to create HTTP client: {}", e)))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                AgentMemError::network_error(format!("Failed to create HTTP client: {}", e))
(B[m[32m+            })?;
(B[m 
         let store = Self {
             config,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:104:
             }],
         };
 
[31m-        let url = format!("{}/db/{}/tx/commit", self.base_url, 
(B[m[31m-                         self.config.database.as_ref().unwrap_or(&"neo4j".to_string()));
(B[m[31m-        
(B[m[31m-        let response = self.client
(B[m[32m+        let url = format!(
(B[m[32m+            "{}/db/{}/tx/commit",
(B[m[32m+            self.base_url,
(B[m[32m+            self.config
(B[m[32m+                .database
(B[m[32m+                .as_ref()
(B[m[32m+                .unwrap_or(&"neo4j".to_string())
(B[m[32m+        );
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Authorization", &self.auth_header)
             .header("Content-Type", "application/json")
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:118:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Neo4j connection test failed {}: {}", status, error_text
(B[m[32m+                "Neo4j connection test failed {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:128:
[31m-        let result: Neo4jQueryResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let result: Neo4jQueryResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         if !result.errors.is_empty() {
             return Err(AgentMemError::storage_error(format!(
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:133:
[31m-                "Neo4j error: {}", result.errors[0].message
(B[m[32m+                "Neo4j error: {}",
(B[m[32m+                result.errors[0].message
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:138:
     }
 
     /// 执行Cypher查询
[31m-    async fn execute_query(&self, statement: &str, parameters: Option<HashMap<String, serde_json::Value>>) -> Result<Neo4jQueryResponse> {
(B[m[32m+    async fn execute_query(
(B[m[32m+        &self,
(B[m[32m+        statement: &str,
(B[m[32m+        parameters: Option<HashMap<String, serde_json::Value>>,
(B[m[32m+    ) -> Result<Neo4jQueryResponse> {
(B[m         let query = Neo4jQueryRequest {
             statements: vec![Neo4jStatement {
                 statement: statement.to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:146:
             }],
         };
 
[31m-        let url = format!("{}/db/{}/tx/commit", self.base_url, 
(B[m[31m-                         self.config.database.as_ref().unwrap_or(&"neo4j".to_string()));
(B[m[31m-        
(B[m[31m-        let response = self.client
(B[m[32m+        let url = format!(
(B[m[32m+            "{}/db/{}/tx/commit",
(B[m[32m+            self.base_url,
(B[m[32m+            self.config
(B[m[32m+                .database
(B[m[32m+                .as_ref()
(B[m[32m+                .unwrap_or(&"neo4j".to_string())
(B[m[32m+        );
(B[m[32m+
(B[m[32m+        let response = self
(B[m[32m+            .client
(B[m             .post(&url)
             .header("Authorization", &self.auth_header)
             .header("Content-Type", "application/json")
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:160:
 
         if !response.status().is_success() {
             let status = response.status();
[31m-            let error_text = response.text().await
(B[m[32m+            let error_text = response
(B[m[32m+                .text()
(B[m[32m+                .await
(B[m                 .unwrap_or_else(|_| "Unknown error".to_string());
             return Err(AgentMemError::storage_error(format!(
[31m-                "Neo4j query failed {}: {}", status, error_text
(B[m[32m+                "Neo4j query failed {}: {}",
(B[m[32m+                status, error_text
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:170:
[31m-        let result: Neo4jQueryResponse = response.json().await
(B[m[31m-            .map_err(|e| AgentMemError::parsing_error(format!("Failed to parse response: {}", e)))?;
(B[m[32m+        let result: Neo4jQueryResponse = response.json().await.map_err(|e| {
(B[m[32m+            AgentMemError::parsing_error(format!("Failed to parse response: {}", e))
(B[m[32m+        })?;
(B[m 
         if !result.errors.is_empty() {
             return Err(AgentMemError::storage_error(format!(
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:175:
[31m-                "Neo4j error: {}", result.errors[0].message
(B[m[32m+                "Neo4j error: {}",
(B[m[32m+                result.errors[0].message
(B[m             )));
         }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:182:
     /// 将Entity转换为Cypher参数
     fn entity_to_parameters(&self, entity: &Entity) -> HashMap<String, serde_json::Value> {
         let mut params = HashMap::new();
[31m-        params.insert("id".to_string(), serde_json::Value::String(entity.id.clone()));
(B[m[31m-        params.insert("entity_type".to_string(), serde_json::Value::String(entity.entity_type.clone()));
(B[m[31m-        params.insert("name".to_string(), serde_json::Value::String(entity.name.clone()));
(B[m[32m+        params.insert(
(B[m[32m+            "id".to_string(),
(B[m[32m+            serde_json::Value::String(entity.id.clone()),
(B[m[32m+        );
(B[m[32m+        params.insert(
(B[m[32m+            "entity_type".to_string(),
(B[m[32m+            serde_json::Value::String(entity.entity_type.clone()),
(B[m[32m+        );
(B[m[32m+        params.insert(
(B[m[32m+            "name".to_string(),
(B[m[32m+            serde_json::Value::String(entity.name.clone()),
(B[m[32m+        );
(B[m 
         // 添加属性
         for (key, value) in &entity.attributes {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:197:
     /// 将Relation转换为Cypher参数
     fn relation_to_parameters(&self, relation: &Relation) -> HashMap<String, serde_json::Value> {
         let mut params = HashMap::new();
[31m-        params.insert("source".to_string(), serde_json::Value::String(relation.source.clone()));
(B[m[31m-        params.insert("target".to_string(), serde_json::Value::String(relation.target.clone()));
(B[m[31m-        params.insert("relation_type".to_string(), serde_json::Value::String(relation.relation.clone()));
(B[m[31m-        params.insert("confidence".to_string(), serde_json::Value::Number(serde_json::Number::from_f64(relation.confidence as f64).unwrap()));
(B[m[32m+        params.insert(
(B[m[32m+            "source".to_string(),
(B[m[32m+            serde_json::Value::String(relation.source.clone()),
(B[m[32m+        );
(B[m[32m+        params.insert(
(B[m[32m+            "target".to_string(),
(B[m[32m+            serde_json::Value::String(relation.target.clone()),
(B[m[32m+        );
(B[m[32m+        params.insert(
(B[m[32m+            "relation_type".to_string(),
(B[m[32m+            serde_json::Value::String(relation.relation.clone()),
(B[m[32m+        );
(B[m[32m+        params.insert(
(B[m[32m+            "confidence".to_string(),
(B[m[32m+            serde_json::Value::Number(
(B[m[32m+                serde_json::Number::from_f64(relation.confidence as f64).unwrap(),
(B[m[32m+            ),
(B[m[32m+        );
(B[m 
         params
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:217:
                     e += $properties
                 RETURN e
             "#;
[31m-            
(B[m[32m+
(B[m             let mut parameters = self.entity_to_parameters(entity);
[31m-            
(B[m[32m+
(B[m             // 将属性作为单独的参数传递
             let attributes: HashMap<String, serde_json::Value> = entity.attributes.clone();
[31m-            parameters.insert("properties".to_string(), serde_json::Value::Object(
(B[m[31m-                attributes.into_iter().collect()
(B[m[31m-            ));
(B[m[31m-            
(B[m[32m+            parameters.insert(
(B[m[32m+                "properties".to_string(),
(B[m[32m+                serde_json::Value::Object(attributes.into_iter().collect()),
(B[m[32m+            );
(B[m[32m+
(B[m             self.execute_query(statement, Some(parameters)).await?;
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:245:
 
             self.execute_query(statement, Some(parameters)).await?;
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:258:
             RETURN e, collect(r) as relations, collect(related) as related_entities
             LIMIT 10
         "#;
[31m-        
(B[m[32m+
(B[m         let mut parameters = HashMap::new();
[31m-        parameters.insert("query".to_string(), serde_json::Value::String(query.to_string()));
(B[m[31m-        
(B[m[32m+        parameters.insert(
(B[m[32m+            "query".to_string(),
(B[m[32m+            serde_json::Value::String(query.to_string()),
(B[m[32m+        );
(B[m[32m+
(B[m         let response = self.execute_query(statement, Some(parameters)).await?;
[31m-        
(B[m[32m+
(B[m         let mut results = Vec::new();
[31m-        
(B[m[32m+
(B[m         for result in response.results {
             for data_row in result.data {
                 if let Some(entity_data) = data_row.row.get(0) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:276:
                         name: "parsed_name".to_string(),
                         attributes: HashMap::new(),
                     };
[31m-                    
(B[m[32m+
(B[m                     let graph_result = GraphResult {
                         entity,
                         relations: Vec::new(), // 实际实现需要解析关系
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:283:
                         score: 1.0,
                     };
[31m-                    
(B[m[32m+
(B[m                     results.push(graph_result);
                 }
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:289:
         }
[31m-        
(B[m[32m+
(B[m         Ok(results)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:294:
     async fn get_neighbors(&self, entity_id: &str, depth: usize) -> Result<Vec<Entity>> {
[31m-        let statement = format!(r#"
(B[m[32m+        let statement = format!(
(B[m[32m+            r#"
(B[m             MATCH (start:Entity {{id: $entity_id}})
             MATCH (start)-[*1..{}]-(neighbor:Entity)
             RETURN DISTINCT neighbor
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:299:
             LIMIT 50
[31m-        "#, depth);
(B[m[31m-        
(B[m[32m+        "#,
(B[m[32m+            depth
(B[m[32m+        );
(B[m[32m+
(B[m         let mut parameters = HashMap::new();
[31m-        parameters.insert("entity_id".to_string(), serde_json::Value::String(entity_id.to_string()));
(B[m[31m-        
(B[m[32m+        parameters.insert(
(B[m[32m+            "entity_id".to_string(),
(B[m[32m+            serde_json::Value::String(entity_id.to_string()),
(B[m[32m+        );
(B[m[32m+
(B[m         let response = self.execute_query(&statement, Some(parameters)).await?;
[31m-        
(B[m[32m+
(B[m         let mut entities = Vec::new();
[31m-        
(B[m[32m+
(B[m         for result in response.results {
             for data_row in result.data {
                 if let Some(_entity_data) = data_row.row.get(0) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:316:
                         name: "neighbor_name".to_string(),
                         attributes: HashMap::new(),
                     };
[31m-                    
(B[m[32m+
(B[m                     entities.push(entity);
                 }
             }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:323:
         }
[31m-        
(B[m[32m+
(B[m         Ok(entities)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:336:
 mod base64 {
     pub fn encode(input: &str) -> String {
         use std::collections::HashMap;
[31m-        
(B[m[32m+
(B[m         const CHARS: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
         let mut result = String::new();
         let bytes = input.as_bytes();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:343:
[31m-        
(B[m[32m+
(B[m         for chunk in bytes.chunks(3) {
             let mut buf = [0u8; 3];
             for (i, &byte) in chunk.iter().enumerate() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:347:
                 buf[i] = byte;
             }
[31m-            
(B[m[32m+
(B[m             let b = ((buf[0] as u32) << 16) | ((buf[1] as u32) << 8) | (buf[2] as u32);
[31m-            
(B[m[32m+
(B[m             result.push(CHARS[((b >> 18) & 63) as usize] as char);
             result.push(CHARS[((b >> 12) & 63) as usize] as char);
[31m-            result.push(if chunk.len() > 1 { CHARS[((b >> 6) & 63) as usize] as char } else { '=' });
(B[m[31m-            result.push(if chunk.len() > 2 { CHARS[(b & 63) as usize] as char } else { '=' });
(B[m[32m+            result.push(if chunk.len() > 1 {
(B[m[32m+                CHARS[((b >> 6) & 63) as usize] as char
(B[m[32m+            } else {
(B[m[32m+                '='
(B[m[32m+            });
(B[m[32m+            result.push(if chunk.len() > 2 {
(B[m[32m+                CHARS[(b & 63) as usize] as char
(B[m[32m+            } else {
(B[m[32m+                '='
(B[m[32m+            });
(B[m         }
[31m-        
(B[m[32m+
(B[m         result
     }
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:412:
         };
 
         let mut properties = HashMap::new();
[31m-        properties.insert("key1".to_string(), serde_json::Value::String("value1".to_string()));
(B[m[32m+        properties.insert(
(B[m[32m+            "key1".to_string(),
(B[m[32m+            serde_json::Value::String("value1".to_string()),
(B[m[32m+        );
(B[m 
         let entity = Entity {
             id: "test-id".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/graph/neo4j.rs:422:
         };
 
         let params = store.entity_to_parameters(&entity);
[31m-        assert_eq!(params.get("id").unwrap(), &serde_json::Value::String("test-id".to_string()));
(B[m[31m-        assert_eq!(params.get("entity_type").unwrap(), &serde_json::Value::String("Person".to_string()));
(B[m[31m-        assert_eq!(params.get("name").unwrap(), &serde_json::Value::String("Test Person".to_string()));
(B[m[31m-        assert_eq!(params.get("key1").unwrap(), &serde_json::Value::String("value1".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            params.get("id").unwrap(),
(B[m[32m+            &serde_json::Value::String("test-id".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            params.get("entity_type").unwrap(),
(B[m[32m+            &serde_json::Value::String("Person".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            params.get("name").unwrap(),
(B[m[32m+            &serde_json::Value::String("Test Person".to_string())
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            params.get("key1").unwrap(),
(B[m[32m+            &serde_json::Value::String("value1".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/lib.rs:1:
 //! # Agent Memory Storage
[31m-//! 
(B[m[32m+//!
(B[m //! 存储后端模块，为AgentMem记忆平台提供多种存储解决方案。
[31m-//! 
(B[m[32m+//!
(B[m //! 本模块提供：
 //! - 统一的存储接口抽象
 //! - 多种向量存储后端支持
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/lib.rs:9:
 //! - 存储工厂模式
 //! - 特性门控支持
 
[31m-pub mod factory;
(B[m pub mod backends;
[31m-pub mod vector;
(B[m[32m+pub mod factory;
(B[m pub mod graph;
[32m+pub mod vector;
(B[m 
 pub use factory::StorageFactory;
 pub use graph::GraphStoreFactory;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/lib.rs:19:
 
 // 重新导出常用类型
[31m-pub use agent_mem_traits::{VectorStore, VectorStoreConfig, Result, AgentMemError};
(B[m[32m+pub use agent_mem_traits::{AgentMemError, Result, VectorStore, VectorStoreConfig};
(B[m 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/mod.rs:1:
 //! 向量操作工具模块
 
[31m-pub mod utils;
(B[m pub mod similarity;
[32m+pub mod utils;
(B[m 
[31m-pub use utils::*;
(B[m pub use similarity::*;
[32m+pub use utils::*;
(B[m 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:1:
 //! 向量相似度计算函数
 
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m 
 /// 相似度计算方法枚举
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:25:
     /// 返回值范围：[-1, 1]，1表示完全相同，-1表示完全相反，0表示正交
     pub fn cosine_similarity(a: &[f32], b: &[f32]) -> Result<f32> {
         if a.len() != b.len() {
[31m-            return Err(AgentMemError::validation_error("Vector dimensions must match"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Vector dimensions must match",
(B[m[32m+            ));
(B[m         }
 
         let dot_product: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:43:
     /// 返回值范围：[0, +∞)，0表示完全相同，值越大表示差异越大
     pub fn euclidean_distance(a: &[f32], b: &[f32]) -> Result<f32> {
         if a.len() != b.len() {
[31m-            return Err(AgentMemError::validation_error("Vector dimensions must match"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Vector dimensions must match",
(B[m[32m+            ));
(B[m         }
 
[31m-        let distance = a.iter()
(B[m[32m+        let distance = a
(B[m[32m+            .iter()
(B[m             .zip(b.iter())
             .map(|(x, y)| (x - y).powi(2))
             .sum::<f32>()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:59:
     /// 返回值范围：[0, +∞)，0表示完全相同，值越大表示差异越大
     pub fn manhattan_distance(a: &[f32], b: &[f32]) -> Result<f32> {
         if a.len() != b.len() {
[31m-            return Err(AgentMemError::validation_error("Vector dimensions must match"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Vector dimensions must match",
(B[m[32m+            ));
(B[m         }
 
[31m-        let distance = a.iter()
(B[m[31m-            .zip(b.iter())
(B[m[31m-            .map(|(x, y)| (x - y).abs())
(B[m[31m-            .sum();
(B[m[32m+        let distance = a.iter().zip(b.iter()).map(|(x, y)| (x - y).abs()).sum();
(B[m 
         Ok(distance)
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:74:
     /// 返回值范围：(-∞, +∞)，值越大表示相似度越高
     pub fn dot_product_similarity(a: &[f32], b: &[f32]) -> Result<f32> {
         if a.len() != b.len() {
[31m-            return Err(AgentMemError::validation_error("Vector dimensions must match"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Vector dimensions must match",
(B[m[32m+            ));
(B[m         }
 
         let dot_product = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:85:
     /// 返回值范围：[0, n]，其中n是向量维度，0表示完全相同
     pub fn hamming_distance(a: &[bool], b: &[bool]) -> Result<usize> {
         if a.len() != b.len() {
[31m-            return Err(AgentMemError::validation_error("Vector dimensions must match"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Vector dimensions must match",
(B[m[32m+            ));
(B[m         }
 
[31m-        let distance = a.iter()
(B[m[32m+        let distance = a
(B[m[32m+            .iter()
(B[m             .zip(b.iter())
             .map(|(x, y)| if x != y { 1 } else { 0 })
             .sum();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:106:
     /// 使用公式：distance = (1 - similarity) / similarity
     pub fn similarity_to_distance(similarity: f32) -> Result<f32> {
         if similarity <= 0.0 {
[31m-            return Err(AgentMemError::validation_error("Similarity must be positive"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Similarity must be positive",
(B[m[32m+            ));
(B[m         }
         if similarity > 1.0 {
[31m-            return Err(AgentMemError::validation_error("Similarity must not exceed 1.0"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Similarity must not exceed 1.0",
(B[m[32m+            ));
(B[m         }
 
         Ok((1.0 - similarity) / similarity)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:137:
                 SimilarityMetric::DotProduct => Self::dot_product_similarity(query, vector)?,
                 SimilarityMetric::Hamming => {
                     return Err(AgentMemError::validation_error(
[31m-                        "Hamming distance requires boolean vectors"
(B[m[32m+                        "Hamming distance requires boolean vectors",
(B[m                     ));
                 }
             };
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:158:
         }
 
         let similarities = Self::batch_similarity(query, vectors, metric)?;
[31m-        
(B[m[32m+
(B[m         let max_index = similarities
             .iter()
             .enumerate()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:180:
         }
 
         let similarities = Self::batch_similarity(query, vectors, metric)?;
[31m-        
(B[m[31m-        let mut indexed_similarities: Vec<(usize, f32)> = similarities
(B[m[31m-            .into_iter()
(B[m[31m-            .enumerate()
(B[m[31m-            .collect();
(B[m 
[32m+        let mut indexed_similarities: Vec<(usize, f32)> =
(B[m[32m+            similarities.into_iter().enumerate().collect();
(B[m[32m+
(B[m         // 按相似度降序排序
[31m-        indexed_similarities.sort_by(|(_, a), (_, b)| b.partial_cmp(a).unwrap_or(std::cmp::Ordering::Equal));
(B[m[31m-        
(B[m[32m+        indexed_similarities
(B[m[32m+            .sort_by(|(_, a), (_, b)| b.partial_cmp(a).unwrap_or(std::cmp::Ordering::Equal));
(B[m[32m+
(B[m         // 取前K个
         indexed_similarities.truncate(k);
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:196:
     }
 
     /// 计算向量集合的平均相似度
[31m-    pub fn average_similarity(
(B[m[31m-        vectors: &[Vec<f32>],
(B[m[31m-        metric: SimilarityMetric,
(B[m[31m-    ) -> Result<f32> {
(B[m[32m+    pub fn average_similarity(vectors: &[Vec<f32>], metric: SimilarityMetric) -> Result<f32> {
(B[m         if vectors.len() < 2 {
             return Ok(0.0);
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:219:
                         let distance = Self::manhattan_distance(&vectors[i], &vectors[j])?;
                         Self::distance_to_similarity(distance)
                     }
[31m-                    SimilarityMetric::DotProduct => Self::dot_product_similarity(&vectors[i], &vectors[j])?,
(B[m[32m+                    SimilarityMetric::DotProduct => {
(B[m[32m+                        Self::dot_product_similarity(&vectors[i], &vectors[j])?
(B[m[32m+                    }
(B[m                     SimilarityMetric::Hamming => {
                         return Err(AgentMemError::validation_error(
[31m-                            "Hamming distance requires boolean vectors"
(B[m[32m+                            "Hamming distance requires boolean vectors",
(B[m                         ));
                     }
                 };
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:304:
     #[test]
     fn test_batch_similarity() {
         let query = vec![1.0, 0.0];
[31m-        let vectors = vec![
(B[m[31m-            vec![1.0, 0.0],
(B[m[31m-            vec![0.0, 1.0],
(B[m[31m-            vec![-1.0, 0.0],
(B[m[31m-        ];
(B[m[32m+        let vectors = vec![vec![1.0, 0.0], vec![0.0, 1.0], vec![-1.0, 0.0]];
(B[m 
[31m-        let similarities = SimilarityCalculator::batch_similarity(
(B[m[31m-            &query,
(B[m[31m-            &vectors,
(B[m[31m-            SimilarityMetric::Cosine,
(B[m[31m-        ).unwrap();
(B[m[32m+        let similarities =
(B[m[32m+            SimilarityCalculator::batch_similarity(&query, &vectors, SimilarityMetric::Cosine)
(B[m[32m+                .unwrap();
(B[m 
[31m-        assert!((similarities[0] - 1.0).abs() < 1e-6);  // 相同
(B[m[31m-        assert!((similarities[1] - 0.0).abs() < 1e-6);  // 正交
(B[m[32m+        assert!((similarities[0] - 1.0).abs() < 1e-6); // 相同
(B[m[32m+        assert!((similarities[1] - 0.0).abs() < 1e-6); // 正交
(B[m         assert!((similarities[2] - (-1.0)).abs() < 1e-6); // 相反
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:325:
     fn test_find_most_similar() {
         let query = vec![1.0, 0.0];
         let vectors = vec![
[31m-            vec![0.0, 1.0],    // 正交
(B[m[31m-            vec![1.0, 0.0],    // 相同
(B[m[31m-            vec![-1.0, 0.0],   // 相反
(B[m[32m+            vec![0.0, 1.0],  // 正交
(B[m[32m+            vec![1.0, 0.0],  // 相同
(B[m[32m+            vec![-1.0, 0.0], // 相反
(B[m         ];
 
[31m-        let most_similar = SimilarityCalculator::find_most_similar(
(B[m[31m-            &query,
(B[m[31m-            &vectors,
(B[m[31m-            SimilarityMetric::Cosine,
(B[m[31m-        ).unwrap();
(B[m[32m+        let most_similar =
(B[m[32m+            SimilarityCalculator::find_most_similar(&query, &vectors, SimilarityMetric::Cosine)
(B[m[32m+                .unwrap();
(B[m 
         assert_eq!(most_similar, Some(1)); // 索引1是最相似的
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/similarity.rs:343:
     fn test_find_top_k_similar() {
         let query = vec![1.0, 0.0];
         let vectors = vec![
[31m-            vec![0.0, 1.0],    // 正交，相似度0
(B[m[31m-            vec![1.0, 0.0],    // 相同，相似度1
(B[m[31m-            vec![-1.0, 0.0],   // 相反，相似度-1
(B[m[31m-            vec![0.5, 0.0],    // 部分相似，相似度0.5
(B[m[32m+            vec![0.0, 1.0],  // 正交，相似度0
(B[m[32m+            vec![1.0, 0.0],  // 相同，相似度1
(B[m[32m+            vec![-1.0, 0.0], // 相反，相似度-1
(B[m[32m+            vec![0.5, 0.0],  // 部分相似，相似度0.5
(B[m         ];
 
[31m-        let top_k = SimilarityCalculator::find_top_k_similar(
(B[m[31m-            &query,
(B[m[31m-            &vectors,
(B[m[31m-            2,
(B[m[31m-            SimilarityMetric::Cosine,
(B[m[31m-        ).unwrap();
(B[m[32m+        let top_k =
(B[m[32m+            SimilarityCalculator::find_top_k_similar(&query, &vectors, 2, SimilarityMetric::Cosine)
(B[m[32m+                .unwrap();
(B[m 
         assert_eq!(top_k.len(), 2);
         assert_eq!(top_k[0].0, 1); // 最相似的是索引1
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:1:
 //! 向量操作工具函数
 
[31m-use agent_mem_traits::{Result, AgentMemError};
(B[m[32m+use agent_mem_traits::{AgentMemError, Result};
(B[m 
 /// 向量操作工具集
 pub struct VectorUtils;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:10:
     pub fn normalize_l2(vector: &mut [f32]) -> Result<()> {
         let norm = Self::l2_norm(vector);
         if norm == 0.0 {
[31m-            return Err(AgentMemError::validation_error("Cannot normalize zero vector"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Cannot normalize zero vector",
(B[m[32m+            ));
(B[m         }
[31m-        
(B[m[32m+
(B[m         for value in vector.iter_mut() {
             *value /= norm;
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:19:
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:33:
     /// 向量加法
     pub fn add_vectors(a: &[f32], b: &[f32]) -> Result<Vec<f32>> {
         if a.len() != b.len() {
[31m-            return Err(AgentMemError::validation_error("Vector dimensions must match"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Vector dimensions must match",
(B[m[32m+            ));
(B[m         }
[31m-        
(B[m[32m+
(B[m         Ok(a.iter().zip(b.iter()).map(|(x, y)| x + y).collect())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:42:
     /// 向量减法
     pub fn subtract_vectors(a: &[f32], b: &[f32]) -> Result<Vec<f32>> {
         if a.len() != b.len() {
[31m-            return Err(AgentMemError::validation_error("Vector dimensions must match"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Vector dimensions must match",
(B[m[32m+            ));
(B[m         }
[31m-        
(B[m[32m+
(B[m         Ok(a.iter().zip(b.iter()).map(|(x, y)| x - y).collect())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:56:
     /// 向量点积
     pub fn dot_product(a: &[f32], b: &[f32]) -> Result<f32> {
         if a.len() != b.len() {
[31m-            return Err(AgentMemError::validation_error("Vector dimensions must match"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Vector dimensions must match",
(B[m[32m+            ));
(B[m         }
[31m-        
(B[m[32m+
(B[m         Ok(a.iter().zip(b.iter()).map(|(x, y)| x * y).sum())
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:65:
     /// 向量平均值
     pub fn average_vectors(vectors: &[Vec<f32>]) -> Result<Vec<f32>> {
         if vectors.is_empty() {
[31m-            return Err(AgentMemError::validation_error("Cannot average empty vector list"));
(B[m[32m+            return Err(AgentMemError::validation_error(
(B[m[32m+                "Cannot average empty vector list",
(B[m[32m+            ));
(B[m         }
[31m-        
(B[m[32m+
(B[m         let dimension = vectors[0].len();
         for vector in vectors {
             if vector.len() != dimension {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:74:
[31m-                return Err(AgentMemError::validation_error("All vectors must have the same dimension"));
(B[m[32m+                return Err(AgentMemError::validation_error(
(B[m[32m+                    "All vectors must have the same dimension",
(B[m[32m+                ));
(B[m             }
         }
[31m-        
(B[m[32m+
(B[m         let mut result = vec![0.0; dimension];
         for vector in vectors {
             for (i, value) in vector.iter().enumerate() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:81:
                 result[i] += value;
             }
         }
[31m-        
(B[m[32m+
(B[m         let count = vectors.len() as f32;
         for value in result.iter_mut() {
             *value /= count;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:88:
         }
[31m-        
(B[m[32m+
(B[m         Ok(result)
     }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:143:
         }
 
         let mean = sum / vector.len() as f32;
[31m-        let variance = vector.iter()
(B[m[31m-            .map(|&x| (x - mean).powi(2))
(B[m[31m-            .sum::<f32>() / vector.len() as f32;
(B[m[32m+        let variance =
(B[m[32m+            vector.iter().map(|&x| (x - mean).powi(2)).sum::<f32>() / vector.len() as f32;
(B[m 
         VectorStats {
             dimension: vector.len(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:196:
     fn test_normalize_l2() {
         let mut vector = vec![3.0, 4.0];
         VectorUtils::normalize_l2(&mut vector).unwrap();
[31m-        
(B[m[32m+
(B[m         // 3-4-5三角形，标准化后应该是[0.6, 0.8]
         assert!((vector[0] - 0.6).abs() < 1e-6);
         assert!((vector[1] - 0.8).abs() < 1e-6);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:203:
[31m-        
(B[m[32m+
(B[m         // 验证L2范数为1
         let norm = VectorUtils::l2_norm(&vector);
         assert!((norm - 1.0).abs() < 1e-6);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:253:
 
     #[test]
     fn test_average_vectors() {
[31m-        let vectors = vec![
(B[m[31m-            vec![1.0, 2.0],
(B[m[31m-            vec![3.0, 4.0],
(B[m[31m-            vec![5.0, 6.0],
(B[m[31m-        ];
(B[m[32m+        let vectors = vec![vec![1.0, 2.0], vec![3.0, 4.0], vec![5.0, 6.0]];
(B[m         let result = VectorUtils::average_vectors(&vectors).unwrap();
         assert_eq!(result, vec![3.0, 4.0]);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:266:
     fn test_is_zero_vector() {
         let zero_vector = vec![0.0, 0.0, 0.0];
         assert!(VectorUtils::is_zero_vector(&zero_vector, 1e-6));
[31m-        
(B[m[32m+
(B[m         let non_zero_vector = vec![0.0, 0.0, 0.1];
         assert!(!VectorUtils::is_zero_vector(&non_zero_vector, 1e-6));
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:282:
     fn test_vector_stats() {
         let vector = vec![1.0, 2.0, 3.0, 4.0, 5.0];
         let stats = VectorUtils::vector_stats(&vector);
[31m-        
(B[m[32m+
(B[m         assert_eq!(stats.dimension, 5);
         assert_eq!(stats.min, 1.0);
         assert_eq!(stats.max, 5.0);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-storage/src/vector/utils.rs:294:
     fn test_dimension_mismatch_errors() {
         let a = vec![1.0, 2.0];
         let b = vec![1.0, 2.0, 3.0];
[31m-        
(B[m[32m+
(B[m         assert!(VectorUtils::add_vectors(&a, &b).is_err());
         assert!(VectorUtils::subtract_vectors(&a, &b).is_err());
         assert!(VectorUtils::dot_product(&a, &b).is_err());
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/embedder.rs:1:
 //! Embedder trait definitions
 
[31m-use async_trait::async_trait;
(B[m use crate::Result;
[32m+use async_trait::async_trait;
(B[m 
 /// Core trait for embedding providers
 #[async_trait]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/embedder.rs:8:
 pub trait Embedder: Send + Sync {
     /// Generate embeddings for text
     async fn embed(&self, text: &str) -> Result<Vec<f32>>;
[31m-    
(B[m[32m+
(B[m     /// Generate embeddings for multiple texts
     async fn embed_batch(&self, texts: &[String]) -> Result<Vec<Vec<f32>>>;
[31m-    
(B[m[32m+
(B[m     /// Get the dimension of embeddings produced by this embedder
     fn dimension(&self) -> usize;
[31m-    
(B[m[32m+
(B[m     /// Get the provider name
     fn provider_name(&self) -> &str;
[31m-    
(B[m[32m+
(B[m     /// Get the model name being used
     fn model_name(&self) -> &str;
[31m-    
(B[m[32m+
(B[m     /// Check if the embedder is available/healthy
     async fn health_check(&self) -> Result<bool>;
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/error.rs:7:
 pub enum AgentMemError {
     #[error("Memory operation failed: {0}")]
     MemoryError(String),
[31m-    
(B[m[32m+
(B[m     #[error("LLM provider error: {0}")]
     LLMError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Storage error: {0}")]
     StorageError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Embedding error: {0}")]
     EmbeddingError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Session error: {0}")]
     SessionError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Configuration error: {0}")]
     ConfigError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Serialization error: {0}")]
     SerializationError(#[from] serde_json::Error),
[31m-    
(B[m[32m+
(B[m     #[error("UUID error: {0}")]
     UuidError(#[from] uuid::Error),
[31m-    
(B[m[32m+
(B[m     #[error("IO error: {0}")]
     IoError(#[from] std::io::Error),
[31m-    
(B[m[32m+
(B[m     #[error("Unsupported provider: {0}")]
     UnsupportedProvider(String),
[31m-    
(B[m[32m+
(B[m     #[error("Invalid configuration: {0}")]
     InvalidConfig(String),
[31m-    
(B[m[32m+
(B[m     #[error("Network error: {0}")]
     NetworkError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Authentication error: {0}")]
     AuthError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Rate limit exceeded: {0}")]
     RateLimitError(String),
[31m-    
(B[m[32m+
(B[m     #[error("Timeout error: {0}")]
     TimeoutError(String),
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/error.rs:76:
     pub fn memory_error(msg: impl Into<String>) -> Self {
         Self::MemoryError(msg.into())
     }
[31m-    
(B[m[32m+
(B[m     pub fn llm_error(msg: impl Into<String>) -> Self {
         Self::LLMError(msg.into())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/error.rs:83:
[31m-    
(B[m[32m+
(B[m     pub fn storage_error(msg: impl Into<String>) -> Self {
         Self::StorageError(msg.into())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/error.rs:87:
[31m-    
(B[m[32m+
(B[m     pub fn embedding_error(msg: impl Into<String>) -> Self {
         Self::EmbeddingError(msg.into())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/error.rs:91:
[31m-    
(B[m[32m+
(B[m     pub fn session_error(msg: impl Into<String>) -> Self {
         Self::SessionError(msg.into())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/error.rs:95:
[31m-    
(B[m[32m+
(B[m     pub fn config_error(msg: impl Into<String>) -> Self {
         Self::ConfigError(msg.into())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/error.rs:99:
[31m-    
(B[m[32m+
(B[m     pub fn unsupported_provider(provider: impl Into<String>) -> Self {
         Self::UnsupportedProvider(provider.into())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/error.rs:103:
[31m-    
(B[m[32m+
(B[m     pub fn invalid_config(msg: impl Into<String>) -> Self {
         Self::InvalidConfig(msg.into())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/error.rs:107:
[31m-    
(B[m[32m+
(B[m     pub fn network_error(msg: impl Into<String>) -> Self {
         Self::NetworkError(msg.into())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/error.rs:111:
[31m-    
(B[m[32m+
(B[m     pub fn auth_error(msg: impl Into<String>) -> Self {
         Self::AuthError(msg.into())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/error.rs:115:
[31m-    
(B[m[32m+
(B[m     pub fn rate_limit_error(msg: impl Into<String>) -> Self {
         Self::RateLimitError(msg.into())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/error.rs:119:
[31m-    
(B[m[32m+
(B[m     pub fn timeout_error(msg: impl Into<String>) -> Self {
         Self::TimeoutError(msg.into())
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/lib.rs:1:
 //! # Agent Memory Traits
[31m-//! 
(B[m[32m+//!
(B[m //! Core traits and abstractions for the AgentMem memory platform.
 //! This crate defines the fundamental interfaces that all components must implement.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/lib.rs:6:
[31m-pub mod memory;
(B[m[31m-pub mod llm;
(B[m[31m-pub mod storage;
(B[m pub mod embedder;
[31m-pub mod session;
(B[m pub mod error;
[32m+pub mod llm;
(B[m[32m+pub mod memory;
(B[m[32m+pub mod session;
(B[m[32m+pub mod storage;
(B[m pub mod types;
 
 // Re-export main traits
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/lib.rs:15:
[31m-pub use memory::MemoryProvider;
(B[m[31m-pub use llm::{LLMProvider, ModelInfo};
(B[m[31m-pub use storage::{VectorStore, EmbeddingVectorStore, LegacyVectorStore, GraphStore, KeyValueStore, HistoryStore, VectorStoreStats, GraphResult};
(B[m pub use embedder::Embedder;
[31m-pub use session::SessionManager;
(B[m pub use error::{AgentMemError, Result};
[32m+pub use llm::{LLMProvider, ModelInfo};
(B[m[32m+pub use memory::MemoryProvider;
(B[m[32m+pub use session::SessionManager;
(B[m[32m+pub use storage::{
(B[m[32m+    EmbeddingVectorStore, GraphResult, GraphStore, HistoryStore, KeyValueStore, LegacyVectorStore,
(B[m[32m+    VectorStore, VectorStoreStats,
(B[m[32m+};
(B[m pub use types::*;
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/llm.rs:1:
 //! LLM provider trait definitions
 
[32m+use crate::{Message, Result};
(B[m use async_trait::async_trait;
[31m-use crate::{Result, Message};
(B[m 
 /// Model information structure
 #[derive(Debug, Clone)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/llm.rs:20:
     async fn generate(&self, messages: &[Message]) -> Result<String>;
 
     /// Generate a streaming response (optional)
[31m-    async fn generate_stream(&self, messages: &[Message]) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>>;
(B[m[32m+    async fn generate_stream(
(B[m[32m+        &self,
(B[m[32m+        messages: &[Message],
(B[m[32m+    ) -> Result<Box<dyn futures::Stream<Item = Result<String>> + Send + Unpin>>;
(B[m 
     /// Get model information
     fn get_model_info(&self) -> ModelInfo;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/memory.rs:1:
 //! Memory provider trait definitions
 
[32m+use crate::{HistoryEntry, MemoryItem, Message, Result, Session};
(B[m use async_trait::async_trait;
[31m-use crate::{Result, MemoryItem, Message, Session, HistoryEntry};
(B[m 
 /// Core trait for memory providers
 #[async_trait]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/memory.rs:8:
 pub trait MemoryProvider: Send + Sync {
     /// Add new memories from messages
     async fn add(&self, messages: &[Message], session: &Session) -> Result<Vec<MemoryItem>>;
[31m-    
(B[m[32m+
(B[m     /// Get a specific memory by ID
     async fn get(&self, id: &str) -> Result<Option<MemoryItem>>;
[31m-    
(B[m[32m+
(B[m     /// Search memories by query
[31m-    async fn search(&self, query: &str, session: &Session, limit: usize) -> Result<Vec<MemoryItem>>;
(B[m[31m-    
(B[m[32m+    async fn search(&self, query: &str, session: &Session, limit: usize)
(B[m[32m+        -> Result<Vec<MemoryItem>>;
(B[m[32m+
(B[m     /// Update an existing memory
     async fn update(&self, id: &str, data: &str) -> Result<()>;
[31m-    
(B[m[32m+
(B[m     /// Delete a memory
     async fn delete(&self, id: &str) -> Result<()>;
[31m-    
(B[m[32m+
(B[m     /// Get history of changes for a memory
     async fn history(&self, id: &str) -> Result<Vec<HistoryEntry>>;
[31m-    
(B[m[32m+
(B[m     /// Get all memories for a session
     async fn get_all(&self, session: &Session) -> Result<Vec<MemoryItem>>;
[31m-    
(B[m[32m+
(B[m     /// Reset all memories (for testing)
     async fn reset(&self) -> Result<()>;
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/session.rs:1:
 //! Session management trait definitions
 
[32m+use crate::{Filters, Metadata, Result, Session};
(B[m use async_trait::async_trait;
[31m-use crate::{Result, Session, Filters, Metadata};
(B[m 
 /// Core trait for session managers
 #[async_trait]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/session.rs:8:
 pub trait SessionManager: Send + Sync {
     /// Create a new session
[31m-    async fn create_session(&self, user_id: Option<String>, agent_id: Option<String>, run_id: Option<String>) -> Result<Session>;
(B[m[31m-    
(B[m[32m+    async fn create_session(
(B[m[32m+        &self,
(B[m[32m+        user_id: Option<String>,
(B[m[32m+        agent_id: Option<String>,
(B[m[32m+        run_id: Option<String>,
(B[m[32m+    ) -> Result<Session>;
(B[m[32m+
(B[m     /// Get an existing session
     async fn get_session(&self, session_id: &str) -> Result<Option<Session>>;
[31m-    
(B[m[32m+
(B[m     /// Update session metadata
     async fn update_session(&self, session_id: &str, metadata: &Metadata) -> Result<()>;
[31m-    
(B[m[32m+
(B[m     /// Delete a session
     async fn delete_session(&self, session_id: &str) -> Result<()>;
[31m-    
(B[m[32m+
(B[m     /// Build filters for a session
     fn build_filters(&self, session: &Session) -> Filters;
[31m-    
(B[m[32m+
(B[m     /// Build metadata for a session
     fn build_metadata(&self, session: &Session) -> Metadata;
[31m-    
(B[m[32m+
(B[m     /// Validate a session
     fn validate_session(&self, session: &Session) -> Result<()>;
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/storage.rs:1:
 //! Storage trait definitions
 
[32m+use crate::{
(B[m[32m+    Entity, Filters, HistoryEntry, Metadata, Relation, Result, SearchResult, Session, Vector,
(B[m[32m+    VectorData, VectorSearchResult,
(B[m[32m+};
(B[m use async_trait::async_trait;
[31m-use crate::{Result, Vector, SearchResult, Filters, Metadata, Entity, Relation, Session, HistoryEntry, VectorData, VectorSearchResult};
(B[m 
 /// Legacy vector store trait (kept for compatibility)
 #[async_trait]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/storage.rs:10:
     async fn insert(&self, vectors: &[Vector], metadata: &[Metadata]) -> Result<Vec<String>>;
 
     /// Search for similar vectors
[31m-    async fn search(&self, query: &Vector, limit: usize, filters: &Filters) -> Result<Vec<SearchResult>>;
(B[m[32m+    async fn search(
(B[m[32m+        &self,
(B[m[32m+        query: &Vector,
(B[m[32m+        limit: usize,
(B[m[32m+        filters: &Filters,
(B[m[32m+    ) -> Result<Vec<SearchResult>>;
(B[m 
     /// Update a vector and its metadata
     async fn update(&self, id: &str, vector: &Vector, metadata: &Metadata) -> Result<()>;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/storage.rs:32:
     async fn add_vectors(&self, vectors: Vec<VectorData>) -> Result<Vec<String>>;
 
     /// Search for similar vectors
[31m-    async fn search_vectors(&self, query_vector: Vec<f32>, limit: usize, threshold: Option<f32>) -> Result<Vec<VectorSearchResult>>;
(B[m[32m+    async fn search_vectors(
(B[m[32m+        &self,
(B[m[32m+        query_vector: Vec<f32>,
(B[m[32m+        limit: usize,
(B[m[32m+        threshold: Option<f32>,
(B[m[32m+    ) -> Result<Vec<VectorSearchResult>>;
(B[m 
     /// Delete vectors by IDs
     async fn delete_vectors(&self, ids: Vec<String>) -> Result<()>;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/storage.rs:92:
 pub trait GraphStore: Send + Sync {
     /// Add entities to the graph
     async fn add_entities(&self, entities: &[Entity], session: &Session) -> Result<()>;
[31m-    
(B[m[32m+
(B[m     /// Add relations to the graph
     async fn add_relations(&self, relations: &[Relation], session: &Session) -> Result<()>;
[31m-    
(B[m[32m+
(B[m     /// Search the graph
     async fn search_graph(&self, query: &str, session: &Session) -> Result<Vec<GraphResult>>;
[31m-    
(B[m[32m+
(B[m     /// Get neighbors of an entity
     async fn get_neighbors(&self, entity_id: &str, depth: usize) -> Result<Vec<Entity>>;
[31m-    
(B[m[32m+
(B[m     /// Reset the graph store (for testing)
     async fn reset(&self) -> Result<()>;
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/storage.rs:111:
 pub trait KeyValueStore: Send + Sync {
     /// Set a key-value pair
     async fn set(&self, key: &str, value: &str) -> Result<()>;
[31m-    
(B[m[32m+
(B[m     /// Get a value by key
     async fn get(&self, key: &str) -> Result<Option<String>>;
[31m-    
(B[m[32m+
(B[m     /// Delete a key
     async fn delete(&self, key: &str) -> Result<()>;
[31m-    
(B[m[32m+
(B[m     /// Check if a key exists
     async fn exists(&self, key: &str) -> Result<bool>;
[31m-    
(B[m[32m+
(B[m     /// Set with expiration
     async fn set_with_expiry(&self, key: &str, value: &str, seconds: u64) -> Result<()>;
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/storage.rs:130:
 pub trait HistoryStore: Send + Sync {
     /// Add a history entry
     async fn add_history_entry(&self, memory_id: &str, entry: &HistoryEntry) -> Result<()>;
[31m-    
(B[m[32m+
(B[m     /// Get history for a memory
     async fn get_history(&self, memory_id: &str) -> Result<Vec<HistoryEntry>>;
[31m-    
(B[m[32m+
(B[m     /// Delete history for a memory
     async fn delete_history(&self, memory_id: &str) -> Result<()>;
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/types.rs:1:
 //! Core data types for AgentMem
 
[32m+use chrono::{DateTime, Utc};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use uuid::Uuid;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/types.rs:6:
[31m-use chrono::{DateTime, Utc};
(B[m 
 /// A message in a conversation
 #[derive(Debug, Clone, Serialize, Deserialize)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/types.rs:28:
             timestamp: Some(Utc::now()),
         }
     }
[31m-    
(B[m[32m+
(B[m     pub fn user(content: &str) -> Self {
         Self {
             role: MessageRole::User,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/types.rs:36:
             timestamp: Some(Utc::now()),
         }
     }
[31m-    
(B[m[32m+
(B[m     pub fn assistant(content: &str) -> Self {
         Self {
             role: MessageRole::Assistant,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/types.rs:82:
             ..Default::default()
         }
     }
[31m-    
(B[m[32m+
(B[m     pub fn with_user_id(mut self, user_id: Option<String>) -> Self {
         self.user_id = user_id;
         self
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/types.rs:89:
     }
[31m-    
(B[m[32m+
(B[m     pub fn with_agent_id(mut self, agent_id: Option<String>) -> Self {
         self.agent_id = agent_id;
         self
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/types.rs:94:
     }
[31m-    
(B[m[32m+
(B[m     pub fn with_run_id(mut self, run_id: Option<String>) -> Self {
         self.run_id = run_id;
         self
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/types.rs:102:
 /// Types of memory
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub enum MemoryType {
[31m-    Factual,      // 事实性记忆
(B[m[31m-    Episodic,     // 情节性记忆
(B[m[31m-    Procedural,   // 程序性记忆
(B[m[31m-    Semantic,     // 语义记忆
(B[m[31m-    Working,      // 工作记忆
(B[m[32m+    Factual,    // 事实性记忆
(B[m[32m+    Episodic,   // 情节性记忆
(B[m[32m+    Procedural, // 程序性记忆
(B[m[32m+    Semantic,   // 语义记忆
(B[m[32m+    Working,    // 工作记忆
(B[m }
 
 /// An extracted fact from content
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-traits/src/types.rs:173:
     pub fn new() -> Self {
         Self::default()
     }
[31m-    
(B[m[32m+
(B[m     pub fn add(&mut self, key: &str, value: serde_json::Value) {
         self.filters.insert(key.to_string(), value);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/hash.rs:1:
 //! Hashing utilities
 
[31m-use sha2::{Sha256, Digest};
(B[m[32m+use sha2::{Digest, Sha256};
(B[m 
 /// Generate SHA256 hash of text content
 pub fn hash_content(content: &str) -> String {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/hash.rs:44:
         let content = "test content";
         let hash = hash_content(content);
         assert_eq!(hash.len(), 64); // SHA256 produces 64 character hex string
[31m-        
(B[m[32m+
(B[m         // Same content should produce same hash
         let hash2 = hash_content(content);
         assert_eq!(hash, hash2);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/hash.rs:61:
     fn test_memory_hash() {
         let content1 = "  Test Content  ";
         let content2 = "  test content  ";
[31m-        
(B[m[32m+
(B[m         let hash1 = memory_hash(content1);
         let hash2 = memory_hash(content2);
[31m-        
(B[m[32m+
(B[m         // Should be the same after normalization
         assert_eq!(hash1, hash2);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/hash.rs:74:
         let content1 = "identical content";
         let content2 = "identical content";
         let content3 = "different content";
[31m-        
(B[m[32m+
(B[m         assert!(same_content_hash(content1, content2));
         assert!(!same_content_hash(content1, content3));
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/hash.rs:85:
         let timestamp = Utc::now();
         let id = generate_content_id(content, &timestamp);
         assert_eq!(id.len(), 8);
[31m-        
(B[m[32m+
(B[m         // Different timestamps should produce different IDs
         let timestamp2 = timestamp + chrono::Duration::seconds(1);
         let id2 = generate_content_id(content, &timestamp2);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/json.rs:1:
 //! JSON processing utilities (inspired by mem0)
 
[32m+use agent_mem_traits::Result;
(B[m use regex::Regex;
 use serde_json::Value;
[31m-use agent_mem_traits::Result;
(B[m 
 /// Extract JSON from text, handling code blocks and other formats
 pub fn extract_json(text: &str) -> Result<String> {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/json.rs:9:
     let text = text.trim();
[31m-    
(B[m[32m+
(B[m     // Try to match JSON in code blocks first
     let code_block_regex = Regex::new(r"```(?:json)?\s*(.*?)\s*```").unwrap();
     if let Some(captures) = code_block_regex.captures(text) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/json.rs:14:
         let json_content = captures.get(1).unwrap().as_str();
         return Ok(json_content.to_string());
     }
[31m-    
(B[m[32m+
(B[m     // Try to find JSON object boundaries
     if let Some(start) = text.find('{') {
         if let Some(end) = text.rfind('}') {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/json.rs:27:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Try to find JSON array boundaries
     if let Some(start) = text.find('[') {
         if let Some(end) = text.rfind(']') {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/json.rs:40:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // If no JSON structure found, assume the entire text is JSON
     Ok(text.to_string())
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/json.rs:49:
 pub fn remove_code_blocks(content: &str) -> String {
     let pattern = r"^```[a-zA-Z0-9]*\n([\s\S]*?)\n```$";
     let regex = Regex::new(pattern).unwrap();
[31m-    
(B[m[32m+
(B[m     if let Some(captures) = regex.captures(content.trim()) {
         captures.get(1).unwrap().as_str().trim().to_string()
     } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/json.rs:93:
 ```
 That's it.
         "#;
[31m-        
(B[m[32m+
(B[m         let result = extract_json(text).unwrap();
         assert_eq!(result, r#"{"name": "test", "value": 42}"#);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/lib.rs:1:
 //! # Agent Memory Utils
[31m-//! 
(B[m[32m+//!
(B[m //! Utility functions and helpers for the AgentMem memory platform.
 
[31m-pub mod json;
(B[m[31m-pub mod text;
(B[m pub mod hash;
[32m+pub mod json;
(B[m pub mod telemetry;
[32m+pub mod text;
(B[m 
[31m-pub use json::*;
(B[m[31m-pub use text::*;
(B[m pub use hash::*;
[32m+pub use json::*;
(B[m pub use telemetry::*;
[32m+pub use text::*;
(B[m 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:1:
 //! Telemetry and monitoring utilities
 
[31m-use std::collections::HashMap;
(B[m[31m-use std::time::{Duration, Instant};
(B[m use chrono::{DateTime, Utc};
 use serde::{Deserialize, Serialize};
[32m+use std::collections::HashMap;
(B[m[32m+use std::time::{Duration, Instant};
(B[m 
 /// Performance metrics for operations
 #[derive(Debug, Clone, Serialize, Deserialize)]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:25:
             metadata: HashMap::new(),
         }
     }
[31m-    
(B[m[32m+
(B[m     pub fn with_duration(mut self, duration: Duration) -> Self {
         self.duration_ms = duration.as_millis() as u64;
         self
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:32:
     }
[31m-    
(B[m[32m+
(B[m     pub fn with_success(mut self, success: bool) -> Self {
         self.success = success;
         self
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:37:
     }
[31m-    
(B[m[32m+
(B[m     pub fn with_metadata(mut self, key: &str, value: serde_json::Value) -> Self {
         self.metadata.insert(key.to_string(), value);
         self
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:55:
             operation: operation.to_string(),
         }
     }
[31m-    
(B[m[32m+
(B[m     pub fn finish(self) -> PerformanceMetrics {
         let duration = self.start.elapsed();
         PerformanceMetrics::new(&self.operation).with_duration(duration)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:62:
     }
[31m-    
(B[m[31m-    pub fn finish_with_result<T>(self, result: &Result<T, impl std::error::Error>) -> PerformanceMetrics {
(B[m[32m+
(B[m[32m+    pub fn finish_with_result<T>(
(B[m[32m+        self,
(B[m[32m+        result: &Result<T, impl std::error::Error>,
(B[m[32m+    ) -> PerformanceMetrics {
(B[m         let duration = self.start.elapsed();
         PerformanceMetrics::new(&self.operation)
             .with_duration(duration)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:84:
     pub fn new() -> Self {
         Self::default()
     }
[31m-    
(B[m[32m+
(B[m     pub fn record_operation(&mut self, metrics: &PerformanceMetrics) {
         self.total_operations += 1;
         self.total_duration_ms += metrics.duration_ms;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:91:
[31m-        
(B[m[32m+
(B[m         if metrics.success {
             self.successful_operations += 1;
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:95:
             self.failed_operations += 1;
         }
[31m-        
(B[m[31m-        *self.operations_by_type.entry(metrics.operation.clone()).or_insert(0) += 1;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        *self
(B[m[32m+            .operations_by_type
(B[m[32m+            .entry(metrics.operation.clone())
(B[m[32m+            .or_insert(0) += 1;
(B[m[32m+
(B[m         // Update average
         self.average_duration_ms = self.total_duration_ms as f64 / self.total_operations as f64;
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:103:
[31m-    
(B[m[32m+
(B[m     pub fn success_rate(&self) -> f64 {
         if self.total_operations == 0 {
             0.0
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:111:
 }
 
 /// Process telemetry filters (inspired by mem0)
[31m-pub fn process_telemetry_filters(filters: &HashMap<String, String>) -> (Vec<String>, HashMap<String, String>) {
(B[m[32m+pub fn process_telemetry_filters(
(B[m[32m+    filters: &HashMap<String, String>,
(B[m[32m+) -> (Vec<String>, HashMap<String, String>) {
(B[m     let mut encoded_ids = HashMap::new();
     let filter_keys: Vec<String> = filters.keys().cloned().collect();
[31m-    
(B[m[32m+
(B[m     for (key, value) in filters {
         if ["user_id", "agent_id", "run_id"].contains(&key.as_str()) {
             // Simple hash encoding for privacy
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:122:
             encoded_ids.insert(key.clone(), encoded);
         }
     }
[31m-    
(B[m[32m+
(B[m     (filter_keys, encoded_ids)
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:157:
         let metrics = PerformanceMetrics::new("test_operation")
             .with_duration(Duration::from_millis(100))
             .with_success(true)
[31m-            .with_metadata("test_key", serde_json::Value::String("test_value".to_string()));
(B[m[31m-        
(B[m[32m+            .with_metadata(
(B[m[32m+                "test_key",
(B[m[32m+                serde_json::Value::String("test_value".to_string()),
(B[m[32m+            );
(B[m[32m+
(B[m         assert_eq!(metrics.operation, "test_operation");
         assert_eq!(metrics.duration_ms, 100);
         assert!(metrics.success);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:170:
         let timer = Timer::new("test_timer");
         thread::sleep(Duration::from_millis(10));
         let metrics = timer.finish();
[31m-        
(B[m[32m+
(B[m         assert_eq!(metrics.operation, "test_timer");
         assert!(metrics.duration_ms >= 10);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:178:
     #[test]
     fn test_usage_stats() {
         let mut stats = UsageStats::new();
[31m-        
(B[m[32m+
(B[m         let metrics1 = PerformanceMetrics::new("op1")
             .with_duration(Duration::from_millis(100))
             .with_success(true);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:185:
[31m-        
(B[m[32m+
(B[m         let metrics2 = PerformanceMetrics::new("op2")
             .with_duration(Duration::from_millis(200))
             .with_success(false);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:189:
[31m-        
(B[m[32m+
(B[m         stats.record_operation(&metrics1);
         stats.record_operation(&metrics2);
[31m-        
(B[m[32m+
(B[m         assert_eq!(stats.total_operations, 2);
         assert_eq!(stats.successful_operations, 1);
         assert_eq!(stats.failed_operations, 1);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/telemetry.rs:202:
         let mut filters = HashMap::new();
         filters.insert("user_id".to_string(), "user123".to_string());
         filters.insert("other_key".to_string(), "other_value".to_string());
[31m-        
(B[m[32m+
(B[m         let (filter_keys, encoded_ids) = process_telemetry_filters(&filters);
[31m-        
(B[m[32m+
(B[m         assert_eq!(filter_keys.len(), 2);
         assert!(encoded_ids.contains_key("user_id"));
         assert!(!encoded_ids.contains_key("other_key"));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/text.rs:44:
         .map(|m| m.as_str().to_lowercase())
         .filter(|word| word.len() >= min_length)
         .collect();
[31m-    
(B[m[32m+
(B[m     // Remove duplicates and sort
     keywords.sort();
     keywords.dedup();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/text.rs:54:
 /// Check if text contains any of the given patterns
 pub fn contains_patterns(text: &str, patterns: &[&str]) -> bool {
     let text_lower = text.to_lowercase();
[31m-    patterns.iter().any(|pattern| text_lower.contains(&pattern.to_lowercase()))
(B[m[32m+    patterns
(B[m[32m+        .iter()
(B[m[32m+        .any(|pattern| text_lower.contains(&pattern.to_lowercase()))
(B[m }
 
 /// Remove URLs from text
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/text.rs:73:
 pub fn jaccard_similarity(text1: &str, text2: &str) -> f32 {
     let words1: std::collections::HashSet<&str> = text1.split_whitespace().collect();
     let words2: std::collections::HashSet<&str> = text2.split_whitespace().collect();
[31m-    
(B[m[32m+
(B[m     let intersection = words1.intersection(&words2).count();
     let union = words1.union(&words2).count();
[31m-    
(B[m[32m+
(B[m     if union == 0 {
         0.0
     } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/crates/agent-mem-utils/src/text.rs:99:
     fn test_extract_sentences() {
         let text = "First sentence. Second sentence! Third sentence?";
         let sentences = extract_sentences(text);
[31m-        assert_eq!(sentences, vec!["First sentence", "Second sentence", "Third sentence"]);
(B[m[32m+        assert_eq!(
(B[m[32m+            sentences,
(B[m[32m+            vec!["First sentence", "Second sentence", "Third sentence"]
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:1:
 //! AgentMem Client SDK Demo
[31m-//! 
(B[m[32m+//!
(B[m //! This demo showcases the AgentMem HTTP client SDK functionality.
 
 use agent_mem_client::{
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:6:
[31m-    AsyncAgentMemClient, ClientConfig, AddMemoryRequest, SearchMemoriesRequest
(B[m[32m+    AddMemoryRequest, AsyncAgentMemClient, ClientConfig, SearchMemoriesRequest,
(B[m };
 use agent_mem_core::MemoryType;
 use anyhow::Result;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:10:
 use std::collections::HashMap;
[31m-use tracing::{info, error};
(B[m[32m+use tracing::{error, info};
(B[m 
 #[tokio::main]
 async fn main() -> Result<()> {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:15:
     // Initialize tracing
     tracing_subscriber::fmt::init();
[31m-    
(B[m[32m+
(B[m     info!("🚀 Starting AgentMem Client SDK Demo");
[31m-    
(B[m[32m+
(B[m     // Create client configuration
     let config = ClientConfig::new("http://localhost:8082")
         .with_timeout(std::time::Duration::from_secs(30))
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:23:
         .with_max_retries(3)
         .with_logging(true);
[31m-    
(B[m[32m+
(B[m     info!("📋 Client Configuration:");
     info!("  - Base URL: {}", config.base_url);
     info!("  - Timeout: {:?}", config.timeout);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:29:
     info!("  - Max Retries: {}", config.max_retries);
     info!("  - Logging: {}", config.enable_logging);
[31m-    
(B[m[32m+
(B[m     // Create client
     let client = AsyncAgentMemClient::new(config)?;
     info!("✅ Client created successfully");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:35:
[31m-    
(B[m[32m+
(B[m     // Test health check
     info!("🔍 Testing health check...");
     match client.health_check().await {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:48:
             return Ok(());
         }
     }
[31m-    
(B[m[32m+
(B[m     // Test metrics
     info!("📊 Testing metrics endpoint...");
     match client.get_metrics().await {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:61:
             error!("❌ Metrics failed: {}", e);
         }
     }
[31m-    
(B[m[32m+
(B[m     // Test adding memories
     info!("💾 Testing memory operations...");
[31m-    
(B[m[32m+
(B[m     // Create test memories
     let memories = vec![
         AddMemoryRequest::new("demo_agent", "I learned about Rust programming today")
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:71:
             .with_user_id("demo_user")
             .with_memory_type(MemoryType::Episodic)
             .with_importance(0.8),
[31m-        
(B[m         AddMemoryRequest::new("demo_agent", "The weather is sunny and warm")
             .with_user_id("demo_user")
             .with_memory_type(MemoryType::Episodic)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:78:
             .with_importance(0.5),
[31m-        
(B[m         AddMemoryRequest::new("demo_agent", "I need to remember to buy groceries")
             .with_user_id("demo_user")
             .with_memory_type(MemoryType::Procedural)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:83:
             .with_importance(0.7),
     ];
[31m-    
(B[m[32m+
(B[m     let mut memory_ids = Vec::new();
[31m-    
(B[m[32m+
(B[m     for (i, memory_request) in memories.iter().enumerate() {
         info!("📝 Adding memory {}: {}", i + 1, memory_request.content);
[31m-        
(B[m[32m+
(B[m         match client.add_memory(memory_request.clone()).await {
             Ok(response) => {
                 info!("✅ Memory added successfully: {}", response.message);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:98:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Test searching memories
     if !memory_ids.is_empty() {
         info!("🔍 Testing memory search...");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:105:
[31m-        
(B[m[31m-        let search_queries = vec![
(B[m[31m-            "Rust programming",
(B[m[31m-            "weather",
(B[m[31m-            "groceries",
(B[m[31m-            "learning",
(B[m[31m-        ];
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let search_queries = vec!["Rust programming", "weather", "groceries", "learning"];
(B[m[32m+
(B[m         for query in search_queries {
             info!("🔎 Searching for: '{}'", query);
[31m-            
(B[m[32m+
(B[m             let search_request = SearchMemoriesRequest::new(query)
                 .with_agent_id("demo_agent")
                 .with_limit(5)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:119:
                 .with_threshold(0.1);
[31m-            
(B[m[32m+
(B[m             match client.search_memories(search_request).await {
                 Ok(results) => {
[31m-                    info!("✅ Search completed: {} results found", results.results.len());
(B[m[32m+                    info!(
(B[m[32m+                        "✅ Search completed: {} results found",
(B[m[32m+                        results.results.len()
(B[m[32m+                    );
(B[m                     for (i, result) in results.results.iter().enumerate() {
[31m-                        info!("   {}. {} (score: {:.3})", 
(B[m[31m-                              i + 1, 
(B[m[31m-                              result.memory.content, 
(B[m[31m-                              result.score);
(B[m[32m+                        info!(
(B[m[32m+                            "   {}. {} (score: {:.3})",
(B[m[32m+                            i + 1,
(B[m[32m+                            result.memory.content,
(B[m[32m+                            result.score
(B[m[32m+                        );
(B[m                     }
                 }
                 Err(e) => {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:133:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         // Test getting individual memories
         info!("📖 Testing individual memory retrieval...");
         for (i, memory_id) in memory_ids.iter().enumerate() {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:140:
             info!("📄 Getting memory {}: {}", i + 1, memory_id);
[31m-            
(B[m[32m+
(B[m             match client.get_memory(memory_id).await {
                 Ok(memory) => {
                     info!("✅ Memory retrieved: {}", memory.content);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:152:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     info!("🎉 Client SDK demo completed successfully!");
     info!("📚 The AgentMem client SDK provides:");
     info!("   - Async and sync interfaces");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/client-demo/src/main.rs:161:
     info!("   - Type-safe request/response models");
     info!("   - Comprehensive error handling");
     info!("   - Built-in logging and metrics");
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:1:
 //! Demo of the current AgentMem functionality
 
 use agent_mem_config::{ConfigFactory, MemoryConfig};
[31m-use agent_mem_traits::{Message, Session, LLMConfig, VectorStoreConfig, MemoryProvider};
(B[m[31m-use agent_mem_utils::{extract_json, clean_text, hash_content, Timer};
(B[m[31m-use agent_mem_core::{MemoryManager, MemoryType, MemoryQuery};
(B[m[31m-use agent_mem_llm::{LLMFactory, LLMClient, prompts::PromptManager};
(B[m[31m-use agent_mem_storage::{StorageFactory, vector::{VectorUtils, SimilarityCalculator, SimilarityMetric}};
(B[m[31m-use agent_mem_embeddings::{EmbeddingFactory, EmbeddingConfig, utils::EmbeddingUtils};
(B[m[32m+use agent_mem_core::{MemoryManager, MemoryQuery, MemoryType};
(B[m[32m+use agent_mem_embeddings::{utils::EmbeddingUtils, EmbeddingConfig, EmbeddingFactory};
(B[m use agent_mem_intelligence::{
[31m-    similarity::{SemanticSimilarity, TextualSimilarity, HybridSimilarity},
(B[m[31m-    clustering::{MemoryClusterer, KMeansClusterer, ClusteringConfig},
(B[m[32m+    clustering::{ClusteringConfig, KMeansClusterer, MemoryClusterer},
(B[m     importance::{ImportanceEvaluator, MemoryInfo},
[31m-    reasoning::{MemoryReasoner, MemoryData},
(B[m[32m+    reasoning::{MemoryData, MemoryReasoner},
(B[m[32m+    similarity::{HybridSimilarity, SemanticSimilarity, TextualSimilarity},
(B[m };
[32m+use agent_mem_llm::{prompts::PromptManager, LLMClient, LLMFactory};
(B[m[32m+use agent_mem_storage::{
(B[m[32m+    vector::{SimilarityCalculator, SimilarityMetric, VectorUtils},
(B[m[32m+    StorageFactory,
(B[m[32m+};
(B[m[32m+use agent_mem_traits::{LLMConfig, MemoryProvider, Message, Session, VectorStoreConfig};
(B[m[32m+use agent_mem_utils::{clean_text, extract_json, hash_content, Timer};
(B[m 
 #[tokio::main]
 async fn main() -> Result<(), Box<dyn std::error::Error>> {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:19:
     println!("🚀 AgentMem v2.0 Demo");
     println!("===================");
[31m-    
(B[m[32m+
(B[m     // 1. Configuration Demo
     println!("\n1. 📋 Configuration System Demo");
     let config = ConfigFactory::create_memory_config();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:25:
     println!("   Default LLM Provider: {}", config.llm.provider);
     println!("   Default Vector Store: {}", config.vector_store.provider);
[31m-    
(B[m[32m+
(B[m     // Create different LLM configs
     let openai_config = ConfigFactory::create_llm_config("openai");
     let anthropic_config = ConfigFactory::create_llm_config("anthropic");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:31:
     println!("   OpenAI Model: {}", openai_config.model);
     println!("   Anthropic Model: {}", anthropic_config.model);
[31m-    
(B[m[32m+
(B[m     // 2. Data Types Demo
     println!("\n2. 🗂️ Data Types Demo");
     let session = Session::new()
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:38:
         .with_agent_id(Some("assistant".to_string()));
     println!("   Session ID: {}", session.id);
     println!("   User ID: {:?}", session.user_id);
[31m-    
(B[m[32m+
(B[m     let message = Message::user("I love playing tennis on weekends");
     println!("   Message: {}", message.content);
     println!("   Role: {:?}", message.role);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:45:
[31m-    
(B[m[32m+
(B[m     // 3. Utils Demo
     println!("\n3. 🛠️ Utils Demo");
[31m-    
(B[m[32m+
(B[m     // JSON extraction
     let json_text = r#"
     Here's the result:
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:56:
     "#;
     let extracted = extract_json(json_text)?;
     println!("   Extracted JSON: {}", extracted);
[31m-    
(B[m[32m+
(B[m     // Text processing
     let messy_text = "  This   has    extra   spaces  and needs cleaning  ";
     let cleaned = clean_text(messy_text);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:63:
     println!("   Cleaned text: '{}'", cleaned);
[31m-    
(B[m[32m+
(B[m     // Hashing
     let content = "I love playing tennis";
     let hash = hash_content(content);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:68:
     println!("   Content hash: {}", &hash[..16]);
[31m-    
(B[m[32m+
(B[m     // Performance timing
     let timer = Timer::new("demo_operation");
     std::thread::sleep(std::time::Duration::from_millis(10));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:73:
     let metrics = timer.finish();
     println!("   Operation took: {}ms", metrics.duration_ms);
[31m-    
(B[m[32m+
(B[m     // 4. Configuration Validation Demo
     println!("\n4. ✅ Configuration Validation Demo");
     let mut valid_config = MemoryConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:90:
         },
         ..Default::default()
     };
[31m-    
(B[m[32m+
(B[m     match agent_mem_config::validate_memory_config(&valid_config) {
         Ok(_) => println!("   ✅ Configuration is valid"),
         Err(e) => println!("   ❌ Configuration error: {}", e),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:97:
     }
[31m-    
(B[m[32m+
(B[m     // Test invalid config
     valid_config.llm.api_key = None;
     match agent_mem_config::validate_memory_config(&valid_config) {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:102:
         Ok(_) => println!("   ✅ Configuration is valid"),
         Err(e) => println!("   ❌ Configuration error: {}", e),
     }
[31m-    
(B[m[32m+
(B[m     // 5. Memory Management Demo
     println!("\n5. 🧠 Memory Management Demo");
     let memory_manager = MemoryManager::new();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:109:
 
     // Add some memories
[31m-    let memory_id1 = memory_manager.add_memory(
(B[m[31m-        "demo-agent".to_string(),
(B[m[31m-        Some("demo-user".to_string()),
(B[m[31m-        "I love playing tennis on weekends".to_string(),
(B[m[31m-        Some(MemoryType::Episodic),
(B[m[31m-        Some(0.8),
(B[m[31m-        None,
(B[m[31m-    ).await?;
(B[m[32m+    let memory_id1 = memory_manager
(B[m[32m+        .add_memory(
(B[m[32m+            "demo-agent".to_string(),
(B[m[32m+            Some("demo-user".to_string()),
(B[m[32m+            "I love playing tennis on weekends".to_string(),
(B[m[32m+            Some(MemoryType::Episodic),
(B[m[32m+            Some(0.8),
(B[m[32m+            None,
(B[m[32m+        )
(B[m[32m+        .await?;
(B[m     println!("   Added episodic memory: {}", &memory_id1[..8]);
 
[31m-    let memory_id2 = memory_manager.add_memory(
(B[m[31m-        "demo-agent".to_string(),
(B[m[31m-        Some("demo-user".to_string()),
(B[m[31m-        "Tennis is played with a racket and ball".to_string(),
(B[m[31m-        Some(MemoryType::Semantic),
(B[m[31m-        Some(0.9),
(B[m[31m-        None,
(B[m[31m-    ).await?;
(B[m[32m+    let memory_id2 = memory_manager
(B[m[32m+        .add_memory(
(B[m[32m+            "demo-agent".to_string(),
(B[m[32m+            Some("demo-user".to_string()),
(B[m[32m+            "Tennis is played with a racket and ball".to_string(),
(B[m[32m+            Some(MemoryType::Semantic),
(B[m[32m+            Some(0.9),
(B[m[32m+            None,
(B[m[32m+        )
(B[m[32m+        .await?;
(B[m     println!("   Added semantic memory: {}", &memory_id2[..8]);
 
     // Search memories
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:141:
     println!("   Average importance: {:.2}", stats.average_importance);
 
     // Update a memory
[31m-    memory_manager.update_memory(
(B[m[31m-        &memory_id1,
(B[m[31m-        Some("I love playing tennis and badminton on weekends".to_string()),
(B[m[31m-        Some(0.85),
(B[m[31m-        None,
(B[m[31m-    ).await?;
(B[m[32m+    memory_manager
(B[m[32m+        .update_memory(
(B[m[32m+            &memory_id1,
(B[m[32m+            Some("I love playing tennis and badminton on weekends".to_string()),
(B[m[32m+            Some(0.85),
(B[m[32m+            None,
(B[m[32m+        )
(B[m[32m+        .await?;
(B[m     println!("   Updated memory: {}", &memory_id1[..8]);
 
     // Get memory history
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:157:
     println!("\n6. 🤖 LLM Integration Demo");
 
     // 演示LLM工厂模式
[31m-    println!("   Supported LLM providers: {:?}", LLMFactory::supported_providers());
(B[m[32m+    println!(
(B[m[32m+        "   Supported LLM providers: {:?}",
(B[m[32m+        LLMFactory::supported_providers()
(B[m[32m+    );
(B[m 
     // 创建一个模拟的LLM配置（不会实际调用API）
     let llm_config = LLMConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:172:
     // 创建LLM客户端
     let llm_client = LLMClient::new(&llm_config)?;
     let model_info = llm_client.get_model_info();
[31m-    println!("   LLM Model: {} ({})", model_info.model, model_info.provider);
(B[m[32m+    println!(
(B[m[32m+        "   LLM Model: {} ({})",
(B[m[32m+        model_info.model, model_info.provider
(B[m[32m+    );
(B[m     println!("   Max tokens: {}", model_info.max_tokens);
     println!("   Supports functions: {}", model_info.supports_functions);
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:182:
     println!("   Available prompt templates: {}", templates.len());
 
     // 构建记忆提取提示词
[31m-    let extraction_prompt = prompt_manager.build_memory_extraction_prompt(
(B[m[31m-        "用户说：我喜欢在周末打网球，这是我最喜欢的运动。"
(B[m[31m-    )?;
(B[m[31m-    println!("   Built memory extraction prompt with {} messages", extraction_prompt.len());
(B[m[32m+    let extraction_prompt = prompt_manager
(B[m[32m+        .build_memory_extraction_prompt("用户说：我喜欢在周末打网球，这是我最喜欢的运动。")?;
(B[m[32m+    println!(
(B[m[32m+        "   Built memory extraction prompt with {} messages",
(B[m[32m+        extraction_prompt.len()
(B[m[32m+    );
(B[m 
     // 构建记忆摘要提示词
     let summarization_prompt = prompt_manager.build_memory_summarization_prompt(
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:192:
[31m-        "记忆1：用户喜欢网球\n记忆2：用户周末有空\n记忆3：网球是用户最喜欢的运动"
(B[m[32m+        "记忆1：用户喜欢网球\n记忆2：用户周末有空\n记忆3：网球是用户最喜欢的运动",
(B[m     )?;
[31m-    println!("   Built memory summarization prompt with {} messages", summarization_prompt.len());
(B[m[32m+    println!(
(B[m[32m+        "   Built memory summarization prompt with {} messages",
(B[m[32m+        summarization_prompt.len()
(B[m[32m+    );
(B[m 
     // 验证配置
     llm_client.validate_config()?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:201:
     println!("\n7. 🗄️ Storage Integration Demo");
 
     // 演示存储工厂模式
[31m-    println!("   Supported storage providers: {:?}", StorageFactory::supported_providers());
(B[m[32m+    println!(
(B[m[32m+        "   Supported storage providers: {:?}",
(B[m[32m+        StorageFactory::supported_providers()
(B[m[32m+    );
(B[m 
     // 创建内存向量存储（3维向量用于演示）
     let config = VectorStoreConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:220:
         dimension: Some(1536),
         ..Default::default()
     };
[31m-    println!("   Configured Qdrant store: {} at {}",
(B[m[31m-             qdrant_config.collection_name.as_ref().unwrap(),
(B[m[31m-             qdrant_config.url.as_ref().unwrap());
(B[m[32m+    println!(
(B[m[32m+        "   Configured Qdrant store: {} at {}",
(B[m[32m+        qdrant_config.collection_name.as_ref().unwrap(),
(B[m[32m+        qdrant_config.url.as_ref().unwrap()
(B[m[32m+    );
(B[m 
     let pinecone_config = VectorStoreConfig {
         provider: "pinecone".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:232:
         dimension: Some(1536),
         ..Default::default()
     };
[31m-    println!("   Configured Pinecone store: {} with API key",
(B[m[31m-             pinecone_config.index_name.as_ref().unwrap());
(B[m[32m+    println!(
(B[m[32m+        "   Configured Pinecone store: {} with API key",
(B[m[32m+        pinecone_config.index_name.as_ref().unwrap()
(B[m[32m+    );
(B[m 
     // 添加一些测试向量
     use agent_mem_traits::VectorData;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:293:
         vec![0.0, 1.0, 0.0],
         vec![0.0, 0.0, 1.0],
     ];
[31m-    let similarities = SimilarityCalculator::batch_similarity(&query, &vectors, SimilarityMetric::Cosine)?;
(B[m[32m+    let similarities =
(B[m[32m+        SimilarityCalculator::batch_similarity(&query, &vectors, SimilarityMetric::Cosine)?;
(B[m     println!("   Batch similarities: {:?}", similarities);
 
     // 8. 嵌入模型集成演示
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:300:
     println!("\n8. 🔢 Embedding Integration Demo");
 
     // 演示嵌入工厂模式
[31m-    println!("   Supported embedding providers: {:?}", EmbeddingFactory::supported_providers());
(B[m[32m+    println!(
(B[m[32m+        "   Supported embedding providers: {:?}",
(B[m[32m+        EmbeddingFactory::supported_providers()
(B[m[32m+    );
(B[m 
     // 创建嵌入配置（不会实际调用API）
     let embedding_config = EmbeddingConfig::openai(Some("demo-key".to_string()));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:307:
[31m-    println!("   Created OpenAI embedding config: {} ({}D)",
(B[m[31m-             embedding_config.model, embedding_config.dimension);
(B[m[32m+    println!(
(B[m[32m+        "   Created OpenAI embedding config: {} ({}D)",
(B[m[32m+        embedding_config.model, embedding_config.dimension
(B[m[32m+    );
(B[m 
     // 演示不同的配置选项
     let config_3_small = EmbeddingConfig::openai_3_small(Some("demo-key".to_string()));
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:312:
[31m-    println!("   OpenAI 3-small config: {} ({}D)",
(B[m[31m-             config_3_small.model, config_3_small.dimension);
(B[m[32m+    println!(
(B[m[32m+        "   OpenAI 3-small config: {} ({}D)",
(B[m[32m+        config_3_small.model, config_3_small.dimension
(B[m[32m+    );
(B[m 
     let config_3_large = EmbeddingConfig::openai_3_large(Some("demo-key".to_string()));
[31m-    println!("   OpenAI 3-large config: {} ({}D)",
(B[m[31m-             config_3_large.model, config_3_large.dimension);
(B[m[32m+    println!(
(B[m[32m+        "   OpenAI 3-large config: {} ({}D)",
(B[m[32m+        config_3_large.model, config_3_large.dimension
(B[m[32m+    );
(B[m 
     let hf_config = EmbeddingConfig::huggingface("sentence-transformers/all-MiniLM-L6-v2");
[31m-    println!("   HuggingFace config: {} ({}D)",
(B[m[31m-             hf_config.model, hf_config.dimension);
(B[m[32m+    println!(
(B[m[32m+        "   HuggingFace config: {} ({}D)",
(B[m[32m+        hf_config.model, hf_config.dimension
(B[m[32m+    );
(B[m 
     // 演示嵌入工具函数
     let test_embedding1 = vec![0.1, 0.2, 0.3, 0.4, 0.5];
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:326:
 
     // 计算余弦相似度
     let cosine_sim = EmbeddingUtils::cosine_similarity(&test_embedding1, &test_embedding2)?;
[31m-    println!("   Cosine similarity between test embeddings: {:.4}", cosine_sim);
(B[m[32m+    println!(
(B[m[32m+        "   Cosine similarity between test embeddings: {:.4}",
(B[m[32m+        cosine_sim
(B[m[32m+    );
(B[m 
     // 计算L2范数
     let l2_norm = EmbeddingUtils::l2_norm(&test_embedding1);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:349:
 
     // 嵌入统计信息
     let stats = EmbeddingUtils::embedding_stats(&test_embedding1);
[31m-    println!("   Embedding stats - dim: {}, mean: {:.3}, std: {:.3}",
(B[m[31m-             stats.dimension, stats.mean, stats.std_dev);
(B[m[32m+    println!(
(B[m[32m+        "   Embedding stats - dim: {}, mean: {:.3}, std: {:.3}",
(B[m[32m+        stats.dimension, stats.mean, stats.std_dev
(B[m[32m+    );
(B[m 
     // 文本分割演示
     let long_text = "This is a very long text that needs to be split into smaller chunks for embedding processing because it exceeds the maximum token limit";
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:378:
     let vector3 = vec![0.1, 0.2, 1.0];
 
     let sim_result = semantic_similarity.detect_similarity(&vector1, &vector2)?;
[31m-    println!("   Semantic similarity between vector1 and vector2: {:.3} ({})",
(B[m[31m-             sim_result.similarity, if sim_result.is_similar { "similar" } else { "not similar" });
(B[m[32m+    println!(
(B[m[32m+        "   Semantic similarity between vector1 and vector2: {:.3} ({})",
(B[m[32m+        sim_result.similarity,
(B[m[32m+        if sim_result.is_similar {
(B[m[32m+            "similar"
(B[m[32m+        } else {
(B[m[32m+            "not similar"
(B[m[32m+        }
(B[m[32m+    );
(B[m 
     let sim_result2 = semantic_similarity.detect_similarity(&vector1, &vector3)?;
[31m-    println!("   Semantic similarity between vector1 and vector3: {:.3} ({})",
(B[m[31m-             sim_result2.similarity, if sim_result2.is_similar { "similar" } else { "not similar" });
(B[m[32m+    println!(
(B[m[32m+        "   Semantic similarity between vector1 and vector3: {:.3} ({})",
(B[m[32m+        sim_result2.similarity,
(B[m[32m+        if sim_result2.is_similar {
(B[m[32m+            "similar"
(B[m[32m+        } else {
(B[m[32m+            "not similar"
(B[m[32m+        }
(B[m[32m+    );
(B[m 
     // 文本相似度计算
     let textual_similarity = TextualSimilarity::default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:392:
     let text3 = "cooking recipes and kitchen utensils";
 
     let text_sim = textual_similarity.calculate_similarity(text1, text2)?;
[31m-    println!("   Text similarity between related texts: {:.3} (matched keywords: {})",
(B[m[31m-             text_sim.similarity, text_sim.matched_keywords.len());
(B[m[32m+    println!(
(B[m[32m+        "   Text similarity between related texts: {:.3} (matched keywords: {})",
(B[m[32m+        text_sim.similarity,
(B[m[32m+        text_sim.matched_keywords.len()
(B[m[32m+    );
(B[m 
     let text_sim2 = textual_similarity.calculate_similarity(text1, text3)?;
[31m-    println!("   Text similarity between unrelated texts: {:.3} (matched keywords: {})",
(B[m[31m-             text_sim2.similarity, text_sim2.matched_keywords.len());
(B[m[32m+    println!(
(B[m[32m+        "   Text similarity between unrelated texts: {:.3} (matched keywords: {})",
(B[m[32m+        text_sim2.similarity,
(B[m[32m+        text_sim2.matched_keywords.len()
(B[m[32m+    );
(B[m 
     // 混合相似度计算
     let hybrid_similarity = HybridSimilarity::default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:404:
     let hybrid_result = hybrid_similarity.calculate_similarity(text1, text2, &vector1, &vector2)?;
[31m-    println!("   Hybrid similarity (semantic: {:.3}, textual: {:.3}, final: {:.3})",
(B[m[31m-             hybrid_result.semantic_similarity, hybrid_result.textual_similarity, hybrid_result.similarity);
(B[m[32m+    println!(
(B[m[32m+        "   Hybrid similarity (semantic: {:.3}, textual: {:.3}, final: {:.3})",
(B[m[32m+        hybrid_result.semantic_similarity,
(B[m[32m+        hybrid_result.textual_similarity,
(B[m[32m+        hybrid_result.similarity
(B[m[32m+    );
(B[m 
     // K-means聚类演示
     let clusterer = KMeansClusterer::default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:410:
     let cluster_vectors = vec![
[31m-        vec![1.0, 1.0],    // 群组1
(B[m[32m+        vec![1.0, 1.0], // 群组1
(B[m         vec![1.1, 0.9],
         vec![0.9, 1.1],
[31m-        vec![5.0, 5.0],    // 群组2
(B[m[32m+        vec![5.0, 5.0], // 群组2
(B[m         vec![5.1, 4.9],
         vec![4.9, 5.1],
     ];
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:418:
[31m-    let cluster_memory_ids: Vec<String> = (0..cluster_vectors.len()).map(|i| format!("mem_{}", i)).collect();
(B[m[32m+    let cluster_memory_ids: Vec<String> = (0..cluster_vectors.len())
(B[m[32m+        .map(|i| format!("mem_{}", i))
(B[m[32m+        .collect();
(B[m 
     let mut cluster_config = ClusteringConfig::default();
     cluster_config.num_clusters = Some(2);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:422:
     cluster_config.min_cluster_size = 1;
 
[31m-    let clusters = clusterer.cluster_memories(&cluster_vectors, &cluster_memory_ids, &cluster_config)?;
(B[m[32m+    let clusters =
(B[m[32m+        clusterer.cluster_memories(&cluster_vectors, &cluster_memory_ids, &cluster_config)?;
(B[m     println!("   K-means clustering created {} clusters", clusters.len());
     for (i, cluster) in clusters.iter().enumerate() {
[31m-        println!("     Cluster {}: {} memories, centroid: [{:.2}, {:.2}]",
(B[m[31m-                 i, cluster.size, cluster.centroid[0], cluster.centroid[1]);
(B[m[32m+        println!(
(B[m[32m+            "     Cluster {}: {} memories, centroid: [{:.2}, {:.2}]",
(B[m[32m+            i, cluster.size, cluster.centroid[0], cluster.centroid[1]
(B[m[32m+        );
(B[m     }
 
     // 重要性评估演示
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:443:
     };
 
     let importance_result = importance_evaluator.evaluate_importance(&memory_info, &[])?;
[31m-    println!("   Memory importance score: {:.3}", importance_result.importance_score);
(B[m[31m-    println!("   Importance factors: frequency={:.3}, recency={:.3}, content={:.3}",
(B[m[31m-             importance_result.factor_scores.get("frequency").unwrap_or(&0.0),
(B[m[31m-             importance_result.factor_scores.get("recency").unwrap_or(&0.0),
(B[m[31m-             importance_result.factor_scores.get("content").unwrap_or(&0.0));
(B[m[32m+    println!(
(B[m[32m+        "   Memory importance score: {:.3}",
(B[m[32m+        importance_result.importance_score
(B[m[32m+    );
(B[m[32m+    println!(
(B[m[32m+        "   Importance factors: frequency={:.3}, recency={:.3}, content={:.3}",
(B[m[32m+        importance_result
(B[m[32m+            .factor_scores
(B[m[32m+            .get("frequency")
(B[m[32m+            .unwrap_or(&0.0),
(B[m[32m+        importance_result
(B[m[32m+            .factor_scores
(B[m[32m+            .get("recency")
(B[m[32m+            .unwrap_or(&0.0),
(B[m[32m+        importance_result
(B[m[32m+            .factor_scores
(B[m[32m+            .get("content")
(B[m[32m+            .unwrap_or(&0.0)
(B[m[32m+    );
(B[m 
     // 记忆推理演示
     let reasoner = MemoryReasoner::default();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:464:
         embedding: Some(vec![0.9, 0.7, 0.8]),
     };
 
[31m-    let reasoning_results = reasoner.reason_by_similarity(&memory_data1, &[memory_data2.clone()])?;
(B[m[32m+    let reasoning_results =
(B[m[32m+        reasoner.reason_by_similarity(&memory_data1, &[memory_data2.clone()])?;
(B[m     if !reasoning_results.is_empty() {
[31m-        println!("   Reasoning found {} similar memories with confidence {:.3}",
(B[m[31m-                 reasoning_results.len(), reasoning_results[0].confidence);
(B[m[32m+        println!(
(B[m[32m+            "   Reasoning found {} similar memories with confidence {:.3}",
(B[m[32m+            reasoning_results.len(),
(B[m[32m+            reasoning_results[0].confidence
(B[m[32m+        );
(B[m     }
 
     let content_results = reasoner.reason_by_content_analysis(&[memory_data1, memory_data2])?;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/demo/src/main.rs:474:
[31m-    println!("   Content analysis found {} associations", content_results.len());
(B[m[32m+    println!(
(B[m[32m+        "   Content analysis found {} associations",
(B[m[32m+        content_results.len()
(B[m[32m+    );
(B[m 
     println!("\n🎉 Demo completed successfully!");
     println!("   ✅ Configuration system working");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:1:
 //! Phase 3 Demo - LLM and Storage Ecosystem Expansion
[31m-//! 
(B[m[32m+//!
(B[m //! This demo showcases the new LLM providers and vector storage backends
 //! added in Phase 3 of the AgentMem 2.0 development.
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:6:
[31m-use agent_mem_storage::backends::{
(B[m[31m-    WeaviateStore, MilvusStore, ElasticsearchStore,
(B[m[31m-};
(B[m[31m-use agent_mem_storage::backends::weaviate::WeaviateConfig;
(B[m[31m-use agent_mem_storage::backends::milvus::MilvusConfig;
(B[m[31m-use agent_mem_storage::backends::elasticsearch::ElasticsearchConfig;
(B[m use agent_mem_llm::providers::{
[31m-    ClaudeProvider, CohereProvider, MistralProvider, PerplexityProvider
(B[m[32m+    ClaudeProvider, CohereProvider, MistralProvider, PerplexityProvider,
(B[m };
[32m+use agent_mem_storage::backends::elasticsearch::ElasticsearchConfig;
(B[m[32m+use agent_mem_storage::backends::milvus::MilvusConfig;
(B[m[32m+use agent_mem_storage::backends::weaviate::WeaviateConfig;
(B[m[32m+use agent_mem_storage::backends::{ElasticsearchStore, MilvusStore, WeaviateStore};
(B[m use agent_mem_traits::{LLMProvider, Result};
 use std::collections::HashMap;
 use tokio;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:20:
 async fn main() -> Result<()> {
     println!("🚀 AgentMem 2.0 Phase 3 Demo");
     println!("===============================");
[31m-    
(B[m[32m+
(B[m     // Demo new LLM providers
     demo_llm_providers().await?;
[31m-    
(B[m[32m+
(B[m     // Demo new storage backends
     demo_storage_backends().await?;
[31m-    
(B[m[32m+
(B[m     println!("\n✅ Phase 3 Demo completed successfully!");
     println!("📊 Total test coverage: 321 tests passing");
     println!("🔧 New LLM providers: 4 (Claude, Cohere, Mistral, Perplexity)");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:33:
     println!("💾 New storage backends: 3 (Weaviate, Milvus, Elasticsearch)");
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:38:
 async fn demo_llm_providers() -> Result<()> {
     println!("\n🤖 New LLM Providers Demo");
     println!("-------------------------");
[31m-    
(B[m[32m+
(B[m     // Claude Provider Demo
     println!("1. Claude Provider (Anthropic)");
     let claude_config = agent_mem_llm::LLMConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:53:
         presence_penalty: None,
         response_format: None,
     };
[31m-    
(B[m[32m+
(B[m     match ClaudeProvider::new(claude_config) {
         Ok(provider) => {
             let model_info = provider.get_model_info();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:62:
         }
         Err(e) => println!("   ⚠️  Demo mode: {}", e),
     }
[31m-    
(B[m[32m+
(B[m     // Cohere Provider Demo
     println!("2. Cohere Provider (Enterprise NLP)");
     let cohere_config = agent_mem_llm::LLMConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:77:
         presence_penalty: None,
         response_format: None,
     };
[31m-    
(B[m[32m+
(B[m     match CohereProvider::new(cohere_config) {
         Ok(provider) => {
             let model_info = provider.get_model_info();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:86:
         }
         Err(e) => println!("   ⚠️  Demo mode: {}", e),
     }
[31m-    
(B[m[32m+
(B[m     // Mistral Provider Demo
     println!("3. Mistral Provider (Open Source)");
     let mistral_config = agent_mem_llm::LLMConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:101:
         presence_penalty: None,
         response_format: None,
     };
[31m-    
(B[m[32m+
(B[m     match MistralProvider::new(mistral_config) {
         Ok(provider) => {
             let model_info = provider.get_model_info();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:110:
         }
         Err(e) => println!("   ⚠️  Demo mode: {}", e),
     }
[31m-    
(B[m[32m+
(B[m     // Perplexity Provider Demo
     println!("4. Perplexity Provider (Search-Augmented)");
     let perplexity_config = agent_mem_llm::LLMConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:125:
         presence_penalty: None,
         response_format: None,
     };
[31m-    
(B[m[32m+
(B[m     match PerplexityProvider::new(perplexity_config) {
         Ok(provider) => {
             let model_info = provider.get_model_info();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:134:
         }
         Err(e) => println!("   ⚠️  Demo mode: {}", e),
     }
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:141:
 async fn demo_storage_backends() -> Result<()> {
     println!("\n💾 New Storage Backends Demo");
     println!("----------------------------");
[31m-    
(B[m[32m+
(B[m     // Weaviate Demo
     println!("1. Weaviate (Semantic Search Database)");
     let weaviate_config = WeaviateConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:150:
         class_name: "DemoMemory".to_string(),
         timeout_seconds: 30,
     };
[31m-    
(B[m[32m+
(B[m     match WeaviateStore::new(weaviate_config) {
         Ok(_store) => {
             println!("   ✅ Weaviate store initialized");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:157:
             println!("   ✅ Supports GraphQL queries");
             println!("   ✅ Built-in semantic search");
[31m-            
(B[m[32m+
(B[m             // Demo embedding storage (would work with real Weaviate instance)
             let metadata = HashMap::from([
                 ("content".to_string(), "Demo memory content".to_string()),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:167:
         }
         Err(e) => println!("   ⚠️  Demo mode: {}", e),
     }
[31m-    
(B[m[32m+
(B[m     // Milvus Demo
     println!("2. Milvus (High-Performance Vector DB)");
     let milvus_config = MilvusConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:179:
         metric_type: "COSINE".to_string(),
         timeout_seconds: 30,
     };
[31m-    
(B[m[32m+
(B[m     match MilvusStore::new(milvus_config) {
         Ok(_store) => {
             println!("   ✅ Milvus store initialized");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:186:
             println!("   ✅ High-performance vector search");
             println!("   ✅ Scalable architecture");
[31m-            
(B[m[32m+
(B[m             let metadata = HashMap::from([
                 ("content".to_string(), "High-performance memory".to_string()),
                 ("user_id".to_string(), "demo-user".to_string()),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:195:
         }
         Err(e) => println!("   ⚠️  Demo mode: {}", e),
     }
[31m-    
(B[m[32m+
(B[m     // Elasticsearch Demo
     println!("3. Elasticsearch (Enterprise Search Engine)");
     let es_config = ElasticsearchConfig {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:207:
         dimension: 1536,
         timeout_seconds: 30,
     };
[31m-    
(B[m[32m+
(B[m     match ElasticsearchStore::new(es_config) {
         Ok(_store) => {
             println!("   ✅ Elasticsearch store initialized");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:214:
             println!("   ✅ Enterprise-grade search");
             println!("   ✅ Dense vector support");
[31m-            
(B[m[32m+
(B[m             let metadata = HashMap::from([
[31m-                ("content".to_string(), "Enterprise memory storage".to_string()),
(B[m[32m+                (
(B[m[32m+                    "content".to_string(),
(B[m[32m+                    "Enterprise memory storage".to_string(),
(B[m[32m+                ),
(B[m                 ("category".to_string(), "business".to_string()),
             ]);
             let embedding = vec![0.5, 0.6, 0.7, 0.8, 0.9]; // Demo embedding
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:223:
         }
         Err(e) => println!("   ⚠️  Demo mode: {}", e),
     }
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:230:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_demo_runs() {
         // Test that the demo runs without panicking
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:237:
         let result = tokio::spawn(async {
             demo_llm_providers().await.unwrap();
             demo_storage_backends().await.unwrap();
[31m-        }).await;
(B[m[31m-        
(B[m[32m+        })
(B[m[32m+        .await;
(B[m[32m+
(B[m         assert!(result.is_ok());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_config_creation() {
         // Test that all config structs can be created
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase3-demo/src/main.rs:248:
         let _weaviate_config = WeaviateConfig::default();
         let _milvus_config = MilvusConfig::default();
         let _es_config = ElasticsearchConfig::default();
[31m-        
(B[m[32m+
(B[m         // Test LLM configs
         let _claude_config = agent_mem_llm::LLMConfig {
             provider: "claude".to_string(),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:1:
 //! Phase 4 Performance and Scalability Demo
[31m-//! 
(B[m[32m+//!
(B[m //! This demo showcases the performance optimization features implemented in Phase 4:
 //! - Async batch processing
 //! - Multi-level caching
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:9:
 //! - Performance metrics collection
 
 use agent_mem_performance::{
[31m-    PerformanceManager, PerformanceConfig,
(B[m[31m-    BatchProcessor, BatchConfig,
(B[m[31m-    CacheManager, CacheConfig,
(B[m[31m-    ObjectPool, MemoryPool, PoolConfig,
(B[m[31m-    MetricsCollector, ConcurrencyManager, ConcurrencyConfig,
(B[m[31m-    QueryOptimizer,
(B[m[31m-    batch::BatchItem,
(B[m[31m-    query::QueryRequest,
(B[m[32m+    batch::BatchItem, query::QueryRequest, BatchConfig, BatchProcessor, CacheConfig, CacheManager,
(B[m[32m+    ConcurrencyConfig, ConcurrencyManager, MemoryPool, MetricsCollector, ObjectPool,
(B[m[32m+    PerformanceConfig, PerformanceManager, PoolConfig, QueryOptimizer,
(B[m };
 use agent_mem_traits::Result;
 use async_trait::async_trait;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:24:
 use std::sync::Arc;
 use std::time::{Duration, Instant};
 use tokio::time::sleep;
[31m-use tracing::{info, warn, error};
(B[m[32m+use tracing::{error, info, warn};
(B[m use uuid::Uuid;
 
 /// Simple error type for demo
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:55:
     async fn process(&self) -> std::result::Result<Self::Output, Self::Error> {
         // Simulate processing time
         sleep(Duration::from_millis(self.processing_time_ms)).await;
[31m-        Ok(format!("Processed task {} with {} bytes", self.id, self.data.len()))
(B[m[32m+        Ok(format!(
(B[m[32m+            "Processed task {} with {} bytes",
(B[m[32m+            self.id,
(B[m[32m+            self.data.len()
(B[m[32m+        ))
(B[m     }
 
     fn size(&self) -> usize {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:63:
     }
 
     fn priority(&self) -> u8 {
[31m-        if self.data.len() > 1000 { 2 } else { 1 }
(B[m[32m+        if self.data.len() > 1000 {
(B[m[32m+            2
(B[m[32m+        } else {
(B[m[32m+            1
(B[m[32m+        }
(B[m     }
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:103:
 
 async fn demo_performance_manager() -> Result<()> {
     info!("\n📊 Demo 1: Performance Manager");
[31m-    
(B[m[32m+
(B[m     let config = PerformanceConfig::default();
     let manager = PerformanceManager::new(config).await?;
[31m-    
(B[m[32m+
(B[m     info!("✓ Performance manager created with default configuration");
[31m-    
(B[m[32m+
(B[m     let stats = manager.get_stats().await?;
[31m-    info!("✓ Performance stats retrieved: cache hit rate = {:.2}%", stats.cache.hit_rate * 100.0);
(B[m[31m-    
(B[m[32m+    info!(
(B[m[32m+        "✓ Performance stats retrieved: cache hit rate = {:.2}%",
(B[m[32m+        stats.cache.hit_rate * 100.0
(B[m[32m+    );
(B[m[32m+
(B[m     manager.shutdown().await?;
     info!("✓ Performance manager shutdown completed");
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:121:
 async fn demo_batch_processing() -> Result<()> {
     info!("\n⚡ Demo 2: Batch Processing");
[31m-    
(B[m[32m+
(B[m     let config = BatchConfig {
         max_batch_size: 5,
         max_wait_time_ms: 100,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:127:
         concurrency: 2,
         ..Default::default()
     };
[31m-    
(B[m[32m+
(B[m     let processor = BatchProcessor::new(config).await?;
     info!("✓ Batch processor created with max batch size: 5");
[31m-    
(B[m[32m+
(B[m     // Submit multiple tasks
     let mut handles = Vec::new();
     for i in 0..10 {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:139:
             data: vec![0u8; 100 * (i + 1)], // Variable size data
             processing_time_ms: 10,
         };
[31m-        
(B[m[32m+
(B[m         let handle = tokio::spawn(async move {
             // Note: This is a simplified example - actual implementation would need proper type handling
             format!("Task {} completed", i)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:146:
         });
         handles.push(handle);
     }
[31m-    
(B[m[32m+
(B[m     // Wait for all tasks to complete
     for handle in handles {
         let result = handle.await.unwrap();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:153:
         info!("✓ {}", result);
     }
[31m-    
(B[m[32m+
(B[m     let stats = processor.get_stats().await?;
[31m-    info!("✓ Batch processing stats: {} items processed", stats.processed_items);
(B[m[31m-    
(B[m[32m+    info!(
(B[m[32m+        "✓ Batch processing stats: {} items processed",
(B[m[32m+        stats.processed_items
(B[m[32m+    );
(B[m[32m+
(B[m     processor.shutdown().await?;
     Ok(())
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:162:
 
 async fn demo_caching() -> Result<()> {
     info!("\n🗄️ Demo 3: Multi-level Caching");
[31m-    
(B[m[32m+
(B[m     let config = CacheConfig {
         l1_size: 100,
         l2_size: 500,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:170:
         default_ttl_seconds: 300,
         ..Default::default()
     };
[31m-    
(B[m[32m+
(B[m     let cache = CacheManager::new(config).await?;
     info!("✓ Multi-level cache created (L1: 100, L2: 500, L3: 1000)");
[31m-    
(B[m[32m+
(B[m     // Cache some data
     for i in 0..10 {
         let key = format!("key-{}", i);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:181:
         cache.put(&key, value, None).await?;
     }
     info!("✓ Cached 10 items across cache levels");
[31m-    
(B[m[32m+
(B[m     // Retrieve data (should hit different cache levels)
     for i in 0..10 {
         let key = format!("key-{}", i);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:189:
             info!("✓ Retrieved {}: {} bytes", key, value.len());
         }
     }
[31m-    
(B[m[32m+
(B[m     let stats = cache.get_stats().await?;
[31m-    info!("✓ Cache stats: L1 hits: {}, L2 hits: {}, L3 hits: {}", 
(B[m[31m-          stats.l1_hits, stats.l2_hits, stats.l3_hits);
(B[m[31m-    
(B[m[32m+    info!(
(B[m[32m+        "✓ Cache stats: L1 hits: {}, L2 hits: {}, L3 hits: {}",
(B[m[32m+        stats.l1_hits, stats.l2_hits, stats.l3_hits
(B[m[32m+    );
(B[m[32m+
(B[m     cache.shutdown().await?;
     Ok(())
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:200:
 
 async fn demo_pools() -> Result<()> {
     info!("\n🏊 Demo 4: Object and Memory Pools");
[31m-    
(B[m[32m+
(B[m     let config = PoolConfig {
         initial_size: 10,
         max_size: 100,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:207:
         ..Default::default()
     };
[31m-    
(B[m[32m+
(B[m     // Object pool demo
     let object_pool = ObjectPool::new(config.clone())?;
     info!("✓ Object pool created with max size: 100");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:213:
[31m-    
(B[m[32m+
(B[m     // Memory pool demo
     let memory_pool = MemoryPool::new(config)?;
     info!("✓ Memory pool created");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:217:
[31m-    
(B[m[32m+
(B[m     // Allocate some memory blocks
     let mut blocks = Vec::new();
     for i in 0..5 {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:223:
         info!("✓ Allocated memory block of {} bytes", size);
         blocks.push(block);
     }
[31m-    
(B[m[32m+
(B[m     let pool_stats = object_pool.get_stats()?;
     let memory_stats = memory_pool.get_stats()?;
[31m-    
(B[m[31m-    info!("✓ Pool stats: {} objects created", pool_stats.created_objects);
(B[m[31m-    info!("✓ Memory stats: {} bytes allocated", memory_stats.total_allocated);
(B[m[31m-    
(B[m[32m+
(B[m[32m+    info!(
(B[m[32m+        "✓ Pool stats: {} objects created",
(B[m[32m+        pool_stats.created_objects
(B[m[32m+    );
(B[m[32m+    info!(
(B[m[32m+        "✓ Memory stats: {} bytes allocated",
(B[m[32m+        memory_stats.total_allocated
(B[m[32m+    );
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:236:
 async fn demo_concurrency() -> Result<()> {
     info!("\n🔄 Demo 5: Concurrency Control");
[31m-    
(B[m[32m+
(B[m     let config = ConcurrencyConfig {
         max_concurrent_tasks: 5,
         rate_limit_rps: 10,
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:242:
         circuit_breaker_threshold: 3,
         ..Default::default()
     };
[31m-    
(B[m[32m+
(B[m     let concurrency_manager = Arc::new(ConcurrencyManager::new(config)?);
     info!("✓ Concurrency manager created with max 5 concurrent tasks, 10 RPS limit");
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:252:
         let manager = Arc::clone(&concurrency_manager);
         let handle = tokio::spawn(async move {
             let task_id = i;
[31m-            manager.execute(move || async move {
(B[m[31m-                info!("Executing task {}", task_id);
(B[m[31m-                sleep(Duration::from_millis(100)).await;
(B[m[31m-                Ok::<String, agent_mem_traits::AgentMemError>(format!("Task {} completed", task_id))
(B[m[31m-            }).await
(B[m[32m+            manager
(B[m[32m+                .execute(move || async move {
(B[m[32m+                    info!("Executing task {}", task_id);
(B[m[32m+                    sleep(Duration::from_millis(100)).await;
(B[m[32m+                    Ok::<String, agent_mem_traits::AgentMemError>(format!(
(B[m[32m+                        "Task {} completed",
(B[m[32m+                        task_id
(B[m[32m+                    ))
(B[m[32m+                })
(B[m[32m+                .await
(B[m         });
         handles.push(handle);
     }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:270:
     }
 
     let stats = concurrency_manager.get_stats().await?;
[31m-    info!("✓ Concurrency stats: {} completed tasks", stats.completed_tasks);
(B[m[31m-    
(B[m[32m+    info!(
(B[m[32m+        "✓ Concurrency stats: {} completed tasks",
(B[m[32m+        stats.completed_tasks
(B[m[32m+    );
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:278:
 async fn demo_query_optimization() -> Result<()> {
     info!("\n🔍 Demo 6: Query Optimization");
[31m-    
(B[m[32m+
(B[m     let optimizer = QueryOptimizer::new(true)?;
     info!("✓ Query optimizer created");
[31m-    
(B[m[32m+
(B[m     // Create sample queries
     let queries = vec![
         QueryRequest {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:307:
             },
         },
     ];
[31m-    
(B[m[32m+
(B[m     for (i, query) in queries.iter().enumerate() {
         let plan = optimizer.optimize_query(query).await?;
[31m-        info!("✓ Query {} optimized: {} steps, estimated cost: {:.2}ms", 
(B[m[31m-              i + 1, plan.execution_steps.len(), plan.estimated_cost);
(B[m[31m-        
(B[m[32m+        info!(
(B[m[32m+            "✓ Query {} optimized: {} steps, estimated cost: {:.2}ms",
(B[m[32m+            i + 1,
(B[m[32m+            plan.execution_steps.len(),
(B[m[32m+            plan.estimated_cost
(B[m[32m+        );
(B[m[32m+
(B[m         // Simulate query execution
         let plan_clone = plan.clone();
[31m-        let result = optimizer.execute_query(&plan, move |_| {
(B[m[31m-            let plan = plan_clone.clone();
(B[m[31m-            async move {
(B[m[31m-                sleep(Duration::from_millis((plan.estimated_cost / 10.0) as u64)).await;
(B[m[31m-                Ok::<String, agent_mem_traits::AgentMemError>(format!("Query executed with {} steps", plan.execution_steps.len()))
(B[m[31m-            }
(B[m[31m-        }).await?;
(B[m[31m-        
(B[m[32m+        let result = optimizer
(B[m[32m+            .execute_query(&plan, move |_| {
(B[m[32m+                let plan = plan_clone.clone();
(B[m[32m+                async move {
(B[m[32m+                    sleep(Duration::from_millis((plan.estimated_cost / 10.0) as u64)).await;
(B[m[32m+                    Ok::<String, agent_mem_traits::AgentMemError>(format!(
(B[m[32m+                        "Query executed with {} steps",
(B[m[32m+                        plan.execution_steps.len()
(B[m[32m+                    ))
(B[m[32m+                }
(B[m[32m+            })
(B[m[32m+            .await?;
(B[m[32m+
(B[m         info!("✓ {}", result);
     }
[31m-    
(B[m[32m+
(B[m     let stats = optimizer.get_statistics().await?;
[31m-    info!("✓ Optimizer stats: {} queries optimized, {:.2}% cache hit rate", 
(B[m[31m-          stats.optimized_queries, stats.cache_hit_rate * 100.0);
(B[m[31m-    
(B[m[32m+    info!(
(B[m[32m+        "✓ Optimizer stats: {} queries optimized, {:.2}% cache hit rate",
(B[m[32m+        stats.optimized_queries,
(B[m[32m+        stats.cache_hit_rate * 100.0
(B[m[32m+    );
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:336:
 async fn demo_metrics() -> Result<()> {
     info!("\n📈 Demo 7: Performance Metrics");
[31m-    
(B[m[32m+
(B[m     let metrics = MetricsCollector::new(true)?;
     info!("✓ Metrics collector created");
[31m-    
(B[m[32m+
(B[m     // Simulate some operations with metrics
     for i in 0..5 {
         let start = Instant::now();
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:345:
         sleep(Duration::from_millis(50 + i * 10)).await;
         let duration = start.elapsed();
[31m-        
(B[m[32m+
(B[m         let success = i % 4 != 0; // Simulate some failures
         metrics.record_request(duration, success).await;
[31m-        
(B[m[32m+
(B[m         if success {
             info!("✓ Request {} completed in {:?}", i + 1, duration);
         } else {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:354:
             warn!("✗ Request {} failed after {:?}", i + 1, duration);
         }
     }
[31m-    
(B[m[32m+
(B[m     // Update other metrics
     metrics.update_memory_usage(1024 * 1024).await; // 1MB
     metrics.update_cache_hit_rate(0.85).await; // 85%
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:361:
     metrics.update_active_connections(42).await;
     metrics.record_custom_metric("custom_metric", 123.45).await;
[31m-    
(B[m[32m+
(B[m     let stats = metrics.get_metrics().await?;
     info!("✓ Metrics summary:");
     info!("  - Total requests: {}", stats.request_count);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:367:
     info!("  - Error count: {}", stats.error_count);
[31m-    info!("  - Average response time: {:.2}ms", stats.average_response_time_ms);
(B[m[31m-    info!("  - Throughput: {:.2} req/s", stats.throughput_requests_per_second);
(B[m[32m+    info!(
(B[m[32m+        "  - Average response time: {:.2}ms",
(B[m[32m+        stats.average_response_time_ms
(B[m[32m+    );
(B[m[32m+    info!(
(B[m[32m+        "  - Throughput: {:.2} req/s",
(B[m[32m+        stats.throughput_requests_per_second
(B[m[32m+    );
(B[m     info!("  - Memory usage: {} bytes", stats.memory_usage_bytes);
     info!("  - Cache hit rate: {:.2}%", stats.cache_hit_rate * 100.0);
     info!("  - Active connections: {}", stats.active_connections);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/phase4-demo/src/main.rs:373:
[31m-    
(B[m[32m+
(B[m     metrics.shutdown().await?;
     Ok(())
 }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:1:
 //! AgentMem Server Demo
[31m-//! 
(B[m[32m+//!
(B[m //! This demo starts the AgentMem server and demonstrates basic API usage.
 
 use agent_mem_server::{MemoryServer, ServerConfig};
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:7:
 use serde_json::json;
 use std::time::Duration;
 use tokio::time::sleep;
[31m-use tracing::{info, error};
(B[m[32m+use tracing::{error, info};
(B[m 
 #[tokio::main]
 async fn main() -> Result<(), Box<dyn std::error::Error>> {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:21:
     config.port = 8082; // Use different port for demo
     config.enable_auth = false;
     config.enable_logging = false; // Disable server logging to avoid conflicts
[31m-    
(B[m[32m+
(B[m     info!("📋 Server Configuration:");
     info!("  - Port: {}", config.port);
     info!("  - CORS: {}", config.enable_cors);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:28:
     info!("  - Auth: {}", config.enable_auth);
     info!("  - Logging: {}", config.enable_logging);
[31m-    
(B[m[32m+
(B[m     // Create and start server
     let server = MemoryServer::new(config).await?;
[31m-    
(B[m[32m+
(B[m     // Start server in background
     let server_handle = tokio::spawn(async move {
         if let Err(e) = server.start().await {
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:37:
             error!("Server error: {}", e);
         }
     });
[31m-    
(B[m[32m+
(B[m     // Wait for server to start
     info!("⏳ Waiting for server to start...");
     sleep(Duration::from_secs(2)).await;
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:44:
[31m-    
(B[m[32m+
(B[m     // Test the API
     let client = Client::new();
     let base_url = "http://localhost:8082";
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:48:
[31m-    
(B[m[32m+
(B[m     info!("🔍 Testing API endpoints...");
[31m-    
(B[m[32m+
(B[m     // Test health check
     match test_health_check(&client, base_url).await {
         Ok(_) => info!("✅ Health check passed"),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:54:
         Err(e) => error!("❌ Health check failed: {}", e),
     }
[31m-    
(B[m[32m+
(B[m     // Test metrics endpoint
     match test_metrics(&client, base_url).await {
         Ok(_) => info!("✅ Metrics endpoint passed"),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:60:
         Err(e) => error!("❌ Metrics endpoint failed: {}", e),
     }
[31m-    
(B[m[32m+
(B[m     // Test memory operations
     match test_memory_operations(&client, base_url).await {
         Ok(_) => info!("✅ Memory operations passed"),
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:66:
         Err(e) => error!("❌ Memory operations failed: {}", e),
     }
[31m-    
(B[m[32m+
(B[m     info!("🎉 Demo completed! Server is still running...");
     info!("📖 Visit http://localhost:8082/swagger-ui/ for API documentation");
     info!("🔍 Visit http://localhost:8082/health for health check");
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:72:
     info!("📊 Visit http://localhost:8082/metrics for metrics");
     info!("Press Ctrl+C to stop the server");
[31m-    
(B[m[32m+
(B[m     // Keep the server running
     server_handle.await?;
[31m-    
(B[m[32m+
(B[m     Ok(())
 }
 
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:81:
[31m-async fn test_health_check(client: &Client, base_url: &str) -> Result<(), Box<dyn std::error::Error>> {
(B[m[31m-    let response = client
(B[m[31m-        .get(&format!("{}/health", base_url))
(B[m[31m-        .send()
(B[m[31m-        .await?;
(B[m[31m-    
(B[m[32m+async fn test_health_check(
(B[m[32m+    client: &Client,
(B[m[32m+    base_url: &str,
(B[m[32m+) -> Result<(), Box<dyn std::error::Error>> {
(B[m[32m+    let response = client.get(&format!("{}/health", base_url)).send().await?;
(B[m[32m+
(B[m     if response.status().is_success() {
         let body: serde_json::Value = response.json().await?;
[31m-        info!("Health check response: {}", serde_json::to_string_pretty(&body)?);
(B[m[32m+        info!(
(B[m[32m+            "Health check response: {}",
(B[m[32m+            serde_json::to_string_pretty(&body)?
(B[m[32m+        );
(B[m         Ok(())
     } else {
         Err(format!("Health check failed with status: {}", response.status()).into())
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:94:
 }
 
 async fn test_metrics(client: &Client, base_url: &str) -> Result<(), Box<dyn std::error::Error>> {
[31m-    let response = client
(B[m[31m-        .get(&format!("{}/metrics", base_url))
(B[m[31m-        .send()
(B[m[31m-        .await?;
(B[m[31m-    
(B[m[32m+    let response = client.get(&format!("{}/metrics", base_url)).send().await?;
(B[m[32m+
(B[m     if response.status().is_success() {
         let body: serde_json::Value = response.json().await?;
         info!("Metrics response: {}", serde_json::to_string_pretty(&body)?);
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:108:
     }
 }
 
[31m-async fn test_memory_operations(client: &Client, base_url: &str) -> Result<(), Box<dyn std::error::Error>> {
(B[m[32m+async fn test_memory_operations(
(B[m[32m+    client: &Client,
(B[m[32m+    base_url: &str,
(B[m[32m+) -> Result<(), Box<dyn std::error::Error>> {
(B[m     // Test adding a memory
     let memory_request = json!({
         "agent_id": "demo_agent",
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:117:
         "memory_type": "Episodic",
         "importance": 0.8
     });
[31m-    
(B[m[31m-    info!("Adding memory: {}", serde_json::to_string_pretty(&memory_request)?);
(B[m[31m-    
(B[m[32m+
(B[m[32m+    info!(
(B[m[32m+        "Adding memory: {}",
(B[m[32m+        serde_json::to_string_pretty(&memory_request)?
(B[m[32m+    );
(B[m[32m+
(B[m     let response = client
         .post(&format!("{}/api/v1/memories", base_url))
         .json(&memory_request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:126:
         .send()
         .await?;
[31m-    
(B[m[32m+
(B[m     if response.status().is_success() {
         let body: serde_json::Value = response.json().await?;
[31m-        info!("Add memory response: {}", serde_json::to_string_pretty(&body)?);
(B[m[31m-        
(B[m[32m+        info!(
(B[m[32m+            "Add memory response: {}",
(B[m[32m+            serde_json::to_string_pretty(&body)?
(B[m[32m+        );
(B[m[32m+
(B[m         // Test searching memories
         let search_request = json!({
             "query": "demo memory",
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:136:
             "agent_id": "demo_agent",
             "limit": 10
         });
[31m-        
(B[m[31m-        info!("Searching memories: {}", serde_json::to_string_pretty(&search_request)?);
(B[m[31m-        
(B[m[32m+
(B[m[32m+        info!(
(B[m[32m+            "Searching memories: {}",
(B[m[32m+            serde_json::to_string_pretty(&search_request)?
(B[m[32m+        );
(B[m[32m+
(B[m         let search_response = client
             .post(&format!("{}/api/v1/memories/search", base_url))
             .json(&search_request)
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:145:
             .send()
             .await?;
[31m-        
(B[m[32m+
(B[m         if search_response.status().is_success() {
             let search_body: serde_json::Value = search_response.json().await?;
[31m-            info!("Search response: {}", serde_json::to_string_pretty(&search_body)?);
(B[m[32m+            info!(
(B[m[32m+                "Search response: {}",
(B[m[32m+                serde_json::to_string_pretty(&search_body)?
(B[m[32m+            );
(B[m         } else {
             error!("Search failed with status: {}", search_response.status());
         }
Diff in /Users/louloulin/Documents/linchong/cjproject/contextengine/agentmen/examples/server-demo/src/main.rs:154:
[31m-        
(B[m[32m+
(B[m         Ok(())
     } else {
         Err(format!("Add memory failed with status: {}", response.status()).into())
